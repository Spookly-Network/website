/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanM/YmMzYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0RkFBdUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/index.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz9iNTBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsaUVBQWtCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLDJFQUF1QjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBdUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQTJCO0FBQ3RELHNCQUFzQixtQkFBTyxDQUFDLHlGQUE4QjtBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBcUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKHRpbWVvdXRFcnJvck1lc3NhZ2UsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/adapters/xhr.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzP2NlZTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtEQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLDREQUFjO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFvQjtBQUM5QyxlQUFlLG1CQUFPLENBQUMsd0RBQVk7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtFQUFpQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQW1COztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBa0I7O0FBRXpDO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXdCOztBQUVyRDs7QUFFQTtBQUNBLHNCQUFzQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/axios.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanM/N2E3NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/Cancel.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz84ZGY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywyREFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/CancelToken.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcz8yZTY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/isCancel.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanM/MGEwNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLHlFQUFxQjtBQUM1Qyx5QkFBeUIsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsMkVBQW1CO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLG1FQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/Axios.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP2Y2YjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/InterceptorManager.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcz84M2I5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLG1GQUEwQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBd0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/buildFullPath.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanM/MmQ4MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxxRUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/createError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzPzUyNzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFpQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsdUVBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyx5REFBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzPzM4N2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/enhanceError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanM/NGE3YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/mergeConfig.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzPzQ2N2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsbUVBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/settle.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz9jNDAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/transformData.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzPzI0NDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QiwwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBK0I7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdFQUFnQjtBQUN0QyxHQUFHLGlCQUFpQixPQUFPLG1EQUFtRCxPQUFPO0FBQ3JGO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGlFQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/defaults.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcz8xZDJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/bind.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/MzBiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/buildURL.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanM/ZTY4MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/combineURLs.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcz83YWFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxTQUFTOztBQUVUO0FBQ0EsNERBQTRELHdCQUF3QjtBQUNwRjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQywrQkFBK0IsYUFBYSxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/cookies.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcz9kOTI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAbsoluteURL.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzPzVmMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAxiosError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzPzM5MzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isURLSameOrigin.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcz9jOGFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtREFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/normalizeHeaderName.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzP2MzNDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/parseHeaders.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzPzBkZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/spread.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzP2M1MzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGdFQUFnQjs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/utils.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swiper_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./swiper.min */ \"./resources/js/swiper.min.js\");\n/* harmony import */ var _swiper_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_swiper_min__WEBPACK_IMPORTED_MODULE_0__);\n__webpack_require__(/*! ./bootstrap */ \"./resources/js/bootstrap.js\");\n\n__webpack_require__(/*! ./bootstrap.bundle.min */ \"./resources/js/bootstrap.bundle.min.js\");\n\n\nvar swiper = new (_swiper_min__WEBPACK_IMPORTED_MODULE_0___default())('.swiper-container', {\n  spaceBetween: 30,\n  centeredSlides: true,\n  grabCursor: true,\n  keyboard: {\n    enabled: true\n  },\n  autoplay: {\n    delay: 5500,\n    disableOnInteraction: false\n  },\n  pagination: {\n    el: '.swiper-pagination',\n    type: 'progressbar'\n  },\n  navigation: {\n    nextEl: '.swiper-button-next',\n    prevEl: '.swiper-button-prev'\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYXBwLmpzPzZkNDAiXSwibmFtZXMiOlsicmVxdWlyZSIsInN3aXBlciIsIlN3aXBlciIsInNwYWNlQmV0d2VlbiIsImNlbnRlcmVkU2xpZGVzIiwiZ3JhYkN1cnNvciIsImtleWJvYXJkIiwiZW5hYmxlZCIsImF1dG9wbGF5IiwiZGVsYXkiLCJkaXNhYmxlT25JbnRlcmFjdGlvbiIsInBhZ2luYXRpb24iLCJlbCIsInR5cGUiLCJuYXZpZ2F0aW9uIiwibmV4dEVsIiwicHJldkVsIl0sIm1hcHBpbmdzIjoiOzs7QUFBQUEsbUJBQU8sQ0FBQyxnREFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHNFQUFELENBQVA7O0FBQ0E7QUFDQyxJQUFNQyxNQUFNLEdBQUcsSUFBSUMsb0RBQUosQ0FBVyxtQkFBWCxFQUFnQztBQUM1Q0MsY0FBWSxFQUFFLEVBRDhCO0FBRTVDQyxnQkFBYyxFQUFFLElBRjRCO0FBRzNDQyxZQUFVLEVBQUUsSUFIK0I7QUFJM0NDLFVBQVEsRUFBRTtBQUNOQyxXQUFPLEVBQUU7QUFESCxHQUppQztBQU81Q0MsVUFBUSxFQUFFO0FBQ05DLFNBQUssRUFBRSxJQUREO0FBRU5DLHdCQUFvQixFQUFFO0FBRmhCLEdBUGtDO0FBVzVDQyxZQUFVLEVBQUU7QUFDUkMsTUFBRSxFQUFFLG9CQURJO0FBRVJDLFFBQUksRUFBRTtBQUZFLEdBWGdDO0FBZTVDQyxZQUFVLEVBQUU7QUFDUkMsVUFBTSxFQUFFLHFCQURBO0FBRVJDLFVBQU0sRUFBRTtBQUZBO0FBZmdDLENBQWhDLENBQWYiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9ib290c3RyYXAnKTtcclxucmVxdWlyZSgnLi9ib290c3RyYXAuYnVuZGxlLm1pbicpXHJcbmltcG9ydCBTd2lwZXIgZnJvbSAnLi9zd2lwZXIubWluJ1xyXG4gY29uc3Qgc3dpcGVyID0gbmV3IFN3aXBlcignLnN3aXBlci1jb250YWluZXInLCB7XHJcbiAgICBzcGFjZUJldHdlZW46IDMwLFxyXG4gICAgY2VudGVyZWRTbGlkZXM6IHRydWUsXHJcbiAgICAgZ3JhYkN1cnNvcjogdHJ1ZSxcclxuICAgICBrZXlib2FyZDoge1xyXG4gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgIH0sXHJcbiAgICBhdXRvcGxheToge1xyXG4gICAgICAgIGRlbGF5OiA1NTAwLFxyXG4gICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgZWw6ICcuc3dpcGVyLXBhZ2luYXRpb24nLFxyXG4gICAgICAgIHR5cGU6ICdwcm9ncmVzc2JhcicsXHJcbiAgICB9LFxyXG4gICAgbmF2aWdhdGlvbjoge1xyXG4gICAgICAgIG5leHRFbDogJy5zd2lwZXItYnV0dG9uLW5leHQnLFxyXG4gICAgICAgIHByZXZFbDogJy5zd2lwZXItYnV0dG9uLXByZXYnLFxyXG4gICAgfSxcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.bundle.min.js":
/*!**********************************************!*\
  !*** ./resources/js/bootstrap.bundle.min.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\r\n  * Bootstrap v5.0.0-beta1 (https://getbootstrap.com/)\r\n  * Copyright 2011-2020 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n  */\n!function (t, e) {\n  \"object\" == ( false ? 0 : _typeof(exports)) && \"undefined\" != \"object\" ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(this, function () {\n  \"use strict\";\n\n  function t(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var i = e[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n    }\n  }\n\n  function e(e, n, i) {\n    return n && t(e.prototype, n), i && t(e, i), e;\n  }\n\n  function n() {\n    return (n = Object.assign || function (t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var n = arguments[e];\n\n        for (var i in n) {\n          Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n        }\n      }\n\n      return t;\n    }).apply(this, arguments);\n  }\n\n  function i(t, e) {\n    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n  }\n\n  var o,\n      r,\n      s = function s(t) {\n    do {\n      t += Math.floor(1e6 * Math.random());\n    } while (document.getElementById(t));\n\n    return t;\n  },\n      a = function a(t) {\n    var e = t.getAttribute(\"data-bs-target\");\n\n    if (!e || \"#\" === e) {\n      var n = t.getAttribute(\"href\");\n      e = n && \"#\" !== n ? n.trim() : null;\n    }\n\n    return e;\n  },\n      l = function l(t) {\n    var e = a(t);\n    return e && document.querySelector(e) ? e : null;\n  },\n      c = function c(t) {\n    var e = a(t);\n    return e ? document.querySelector(e) : null;\n  },\n      u = function u(t) {\n    if (!t) return 0;\n    var e = window.getComputedStyle(t),\n        n = e.transitionDuration,\n        i = e.transitionDelay,\n        o = Number.parseFloat(n),\n        r = Number.parseFloat(i);\n    return o || r ? (n = n.split(\",\")[0], i = i.split(\",\")[0], 1e3 * (Number.parseFloat(n) + Number.parseFloat(i))) : 0;\n  },\n      f = function f(t) {\n    t.dispatchEvent(new Event(\"transitionend\"));\n  },\n      d = function d(t) {\n    return (t[0] || t).nodeType;\n  },\n      h = function h(t, e) {\n    var n = !1,\n        i = e + 5;\n    t.addEventListener(\"transitionend\", function e() {\n      n = !0, t.removeEventListener(\"transitionend\", e);\n    }), setTimeout(function () {\n      n || f(t);\n    }, i);\n  },\n      p = function p(t, e, n) {\n    Object.keys(n).forEach(function (i) {\n      var o,\n          r = n[i],\n          s = e[i],\n          a = s && d(s) ? \"element\" : null == (o = s) ? \"\" + o : {}.toString.call(o).match(/\\s([a-z]+)/i)[1].toLowerCase();\n      if (!new RegExp(r).test(a)) throw new Error(t.toUpperCase() + ': Option \"' + i + '\" provided type \"' + a + '\" but expected type \"' + r + '\".');\n    });\n  },\n      g = function g(t) {\n    if (!t) return !1;\n\n    if (t.style && t.parentNode && t.parentNode.style) {\n      var e = getComputedStyle(t),\n          n = getComputedStyle(t.parentNode);\n      return \"none\" !== e.display && \"none\" !== n.display && \"hidden\" !== e.visibility;\n    }\n\n    return !1;\n  },\n      m = function m() {\n    return function () {};\n  },\n      v = function v(t) {\n    return t.offsetHeight;\n  },\n      _ = function _() {\n    var t = window.jQuery;\n    return t && !document.body.hasAttribute(\"data-bs-no-jquery\") ? t : null;\n  },\n      b = function b(t) {\n    \"loading\" === document.readyState ? document.addEventListener(\"DOMContentLoaded\", t) : t();\n  },\n      y = \"rtl\" === document.documentElement.dir,\n      w = (o = {}, r = 1, {\n    set: function set(t, e, n) {\n      void 0 === t.bsKey && (t.bsKey = {\n        key: e,\n        id: r\n      }, r++), o[t.bsKey.id] = n;\n    },\n    get: function get(t, e) {\n      if (!t || void 0 === t.bsKey) return null;\n      var n = t.bsKey;\n      return n.key === e ? o[n.id] : null;\n    },\n    \"delete\": function _delete(t, e) {\n      if (void 0 !== t.bsKey) {\n        var n = t.bsKey;\n        n.key === e && (delete o[n.id], delete t.bsKey);\n      }\n    }\n  }),\n      E = function E(t, e, n) {\n    w.set(t, e, n);\n  },\n      T = function T(t, e) {\n    return w.get(t, e);\n  },\n      k = function k(t, e) {\n    w[\"delete\"](t, e);\n  },\n      O = /[^.]*(?=\\..*)\\.|.*/,\n      L = /\\..*/,\n      A = /::\\d+$/,\n      C = {},\n      D = 1,\n      x = {\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  },\n      S = new Set([\"click\", \"dblclick\", \"mouseup\", \"mousedown\", \"contextmenu\", \"mousewheel\", \"DOMMouseScroll\", \"mouseover\", \"mouseout\", \"mousemove\", \"selectstart\", \"selectend\", \"keydown\", \"keypress\", \"keyup\", \"orientationchange\", \"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\", \"pointerdown\", \"pointermove\", \"pointerup\", \"pointerleave\", \"pointercancel\", \"gesturestart\", \"gesturechange\", \"gestureend\", \"focus\", \"blur\", \"change\", \"reset\", \"select\", \"submit\", \"focusin\", \"focusout\", \"load\", \"unload\", \"beforeunload\", \"resize\", \"move\", \"DOMContentLoaded\", \"readystatechange\", \"error\", \"abort\", \"scroll\"]);\n\n  function j(t, e) {\n    return e && e + \"::\" + D++ || t.uidEvent || D++;\n  }\n\n  function N(t) {\n    var e = j(t);\n    return t.uidEvent = e, C[e] = C[e] || {}, C[e];\n  }\n\n  function I(t, e, n) {\n    void 0 === n && (n = null);\n\n    for (var i = Object.keys(t), o = 0, r = i.length; o < r; o++) {\n      var s = t[i[o]];\n      if (s.originalHandler === e && s.delegationSelector === n) return s;\n    }\n\n    return null;\n  }\n\n  function P(t, e, n) {\n    var i = \"string\" == typeof e,\n        o = i ? n : e,\n        r = t.replace(L, \"\"),\n        s = x[r];\n    return s && (r = s), S.has(r) || (r = t), [i, o, r];\n  }\n\n  function M(t, e, n, i, o) {\n    if (\"string\" == typeof e && t) {\n      n || (n = i, i = null);\n      var r = P(e, n, i),\n          s = r[0],\n          a = r[1],\n          l = r[2],\n          c = N(t),\n          u = c[l] || (c[l] = {}),\n          f = I(u, a, s ? n : null);\n      if (f) f.oneOff = f.oneOff && o;else {\n        var d = j(a, e.replace(O, \"\")),\n            h = s ? function (t, e, n) {\n          return function i(o) {\n            for (var r = t.querySelectorAll(e), s = o.target; s && s !== this; s = s.parentNode) {\n              for (var a = r.length; a--;) {\n                if (r[a] === s) return o.delegateTarget = s, i.oneOff && H.off(t, o.type, n), n.apply(s, [o]);\n              }\n            }\n\n            return null;\n          };\n        }(t, n, i) : function (t, e) {\n          return function n(i) {\n            return i.delegateTarget = t, n.oneOff && H.off(t, i.type, e), e.apply(t, [i]);\n          };\n        }(t, n);\n        h.delegationSelector = s ? n : null, h.originalHandler = a, h.oneOff = o, h.uidEvent = d, u[d] = h, t.addEventListener(l, h, s);\n      }\n    }\n  }\n\n  function B(t, e, n, i, o) {\n    var r = I(e[n], i, o);\n    r && (t.removeEventListener(n, r, Boolean(o)), delete e[n][r.uidEvent]);\n  }\n\n  var H = {\n    on: function on(t, e, n, i) {\n      M(t, e, n, i, !1);\n    },\n    one: function one(t, e, n, i) {\n      M(t, e, n, i, !0);\n    },\n    off: function off(t, e, n, i) {\n      if (\"string\" == typeof e && t) {\n        var o = P(e, n, i),\n            r = o[0],\n            s = o[1],\n            a = o[2],\n            l = a !== e,\n            c = N(t),\n            u = e.startsWith(\".\");\n\n        if (void 0 === s) {\n          u && Object.keys(c).forEach(function (n) {\n            !function (t, e, n, i) {\n              var o = e[n] || {};\n              Object.keys(o).forEach(function (r) {\n                if (r.includes(i)) {\n                  var s = o[r];\n                  B(t, e, n, s.originalHandler, s.delegationSelector);\n                }\n              });\n            }(t, c, n, e.slice(1));\n          });\n          var f = c[a] || {};\n          Object.keys(f).forEach(function (n) {\n            var i = n.replace(A, \"\");\n\n            if (!l || e.includes(i)) {\n              var o = f[n];\n              B(t, c, a, o.originalHandler, o.delegationSelector);\n            }\n          });\n        } else {\n          if (!c || !c[a]) return;\n          B(t, c, a, s, r ? n : null);\n        }\n      }\n    },\n    trigger: function trigger(t, e, n) {\n      if (\"string\" != typeof e || !t) return null;\n\n      var i,\n          o = _(),\n          r = e.replace(L, \"\"),\n          s = e !== r,\n          a = S.has(r),\n          l = !0,\n          c = !0,\n          u = !1,\n          f = null;\n\n      return s && o && (i = o.Event(e, n), o(t).trigger(i), l = !i.isPropagationStopped(), c = !i.isImmediatePropagationStopped(), u = i.isDefaultPrevented()), a ? (f = document.createEvent(\"HTMLEvents\")).initEvent(r, l, !0) : f = new CustomEvent(e, {\n        bubbles: l,\n        cancelable: !0\n      }), void 0 !== n && Object.keys(n).forEach(function (t) {\n        Object.defineProperty(f, t, {\n          get: function get() {\n            return n[t];\n          }\n        });\n      }), u && f.preventDefault(), c && t.dispatchEvent(f), f.defaultPrevented && void 0 !== i && i.preventDefault(), f;\n    }\n  },\n      R = function () {\n    function t(t) {\n      t && (this._element = t, E(t, this.constructor.DATA_KEY, this));\n    }\n\n    return t.prototype.dispose = function () {\n      k(this._element, this.constructor.DATA_KEY), this._element = null;\n    }, t.getInstance = function (t) {\n      return T(t, this.DATA_KEY);\n    }, e(t, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return \"5.0.0-beta1\";\n      }\n    }]), t;\n  }(),\n      W = \"alert\",\n      K = function (t) {\n    function n() {\n      return t.apply(this, arguments) || this;\n    }\n\n    i(n, t);\n    var o = n.prototype;\n    return o.close = function (t) {\n      var e = t ? this._getRootElement(t) : this._element,\n          n = this._triggerCloseEvent(e);\n\n      null === n || n.defaultPrevented || this._removeElement(e);\n    }, o._getRootElement = function (t) {\n      return c(t) || t.closest(\".alert\");\n    }, o._triggerCloseEvent = function (t) {\n      return H.trigger(t, \"close.bs.alert\");\n    }, o._removeElement = function (t) {\n      var e = this;\n\n      if (t.classList.remove(\"show\"), t.classList.contains(\"fade\")) {\n        var n = u(t);\n        H.one(t, \"transitionend\", function () {\n          return e._destroyElement(t);\n        }), h(t, n);\n      } else this._destroyElement(t);\n    }, o._destroyElement = function (t) {\n      t.parentNode && t.parentNode.removeChild(t), H.trigger(t, \"closed.bs.alert\");\n    }, n.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.alert\");\n        e || (e = new n(this)), \"close\" === t && e[t](this);\n      });\n    }, n.handleDismiss = function (t) {\n      return function (e) {\n        e && e.preventDefault(), t.close(this);\n      };\n    }, e(n, null, [{\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.alert\";\n      }\n    }]), n;\n  }(R);\n\n  H.on(document, \"click.bs.alert.data-api\", '[data-bs-dismiss=\"alert\"]', K.handleDismiss(new K())), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[W];\n      t.fn[W] = K.jQueryInterface, t.fn[W].Constructor = K, t.fn[W].noConflict = function () {\n        return t.fn[W] = e, K.jQueryInterface;\n      };\n    }\n  });\n\n  var Q = function (t) {\n    function n() {\n      return t.apply(this, arguments) || this;\n    }\n\n    return i(n, t), n.prototype.toggle = function () {\n      this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(\"active\"));\n    }, n.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.button\");\n        e || (e = new n(this)), \"toggle\" === t && e[t]();\n      });\n    }, e(n, null, [{\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.button\";\n      }\n    }]), n;\n  }(R);\n\n  function U(t) {\n    return \"true\" === t || \"false\" !== t && (t === Number(t).toString() ? Number(t) : \"\" === t || \"null\" === t ? null : t);\n  }\n\n  function F(t) {\n    return t.replace(/[A-Z]/g, function (t) {\n      return \"-\" + t.toLowerCase();\n    });\n  }\n\n  H.on(document, \"click.bs.button.data-api\", '[data-bs-toggle=\"button\"]', function (t) {\n    t.preventDefault();\n    var e = t.target.closest('[data-bs-toggle=\"button\"]'),\n        n = T(e, \"bs.button\");\n    n || (n = new Q(e)), n.toggle();\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn.button;\n      t.fn.button = Q.jQueryInterface, t.fn.button.Constructor = Q, t.fn.button.noConflict = function () {\n        return t.fn.button = e, Q.jQueryInterface;\n      };\n    }\n  });\n\n  var Y = {\n    setDataAttribute: function setDataAttribute(t, e, n) {\n      t.setAttribute(\"data-bs-\" + F(e), n);\n    },\n    removeDataAttribute: function removeDataAttribute(t, e) {\n      t.removeAttribute(\"data-bs-\" + F(e));\n    },\n    getDataAttributes: function getDataAttributes(t) {\n      if (!t) return {};\n      var e = {};\n      return Object.keys(t.dataset).filter(function (t) {\n        return t.startsWith(\"bs\");\n      }).forEach(function (n) {\n        var i = n.replace(/^bs/, \"\");\n        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = U(t.dataset[n]);\n      }), e;\n    },\n    getDataAttribute: function getDataAttribute(t, e) {\n      return U(t.getAttribute(\"data-bs-\" + F(e)));\n    },\n    offset: function offset(t) {\n      var e = t.getBoundingClientRect();\n      return {\n        top: e.top + document.body.scrollTop,\n        left: e.left + document.body.scrollLeft\n      };\n    },\n    position: function position(t) {\n      return {\n        top: t.offsetTop,\n        left: t.offsetLeft\n      };\n    }\n  },\n      q = {\n    matches: function matches(t, e) {\n      return t.matches(e);\n    },\n    find: function find(t, e) {\n      var n;\n      return void 0 === e && (e = document.documentElement), (n = []).concat.apply(n, Element.prototype.querySelectorAll.call(e, t));\n    },\n    findOne: function findOne(t, e) {\n      return void 0 === e && (e = document.documentElement), Element.prototype.querySelector.call(e, t);\n    },\n    children: function children(t, e) {\n      var n,\n          i = (n = []).concat.apply(n, t.children);\n      return i.filter(function (t) {\n        return t.matches(e);\n      });\n    },\n    parents: function parents(t, e) {\n      for (var n = [], i = t.parentNode; i && i.nodeType === Node.ELEMENT_NODE && 3 !== i.nodeType;) {\n        this.matches(i, e) && n.push(i), i = i.parentNode;\n      }\n\n      return n;\n    },\n    prev: function prev(t, e) {\n      for (var n = t.previousElementSibling; n;) {\n        if (n.matches(e)) return [n];\n        n = n.previousElementSibling;\n      }\n\n      return [];\n    },\n    next: function next(t, e) {\n      for (var n = t.nextElementSibling; n;) {\n        if (this.matches(n, e)) return [n];\n        n = n.nextElementSibling;\n      }\n\n      return [];\n    }\n  },\n      z = \"carousel\",\n      V = \".bs.carousel\",\n      X = {\n    interval: 5e3,\n    keyboard: !0,\n    slide: !1,\n    pause: \"hover\",\n    wrap: !0,\n    touch: !0\n  },\n      $ = {\n    interval: \"(number|boolean)\",\n    keyboard: \"boolean\",\n    slide: \"(boolean|string)\",\n    pause: \"(string|boolean)\",\n    wrap: \"boolean\",\n    touch: \"boolean\"\n  },\n      G = {\n    TOUCH: \"touch\",\n    PEN: \"pen\"\n  },\n      Z = function (t) {\n    function o(e, n) {\n      var i;\n      return (i = t.call(this, e) || this)._items = null, i._interval = null, i._activeElement = null, i._isPaused = !1, i._isSliding = !1, i.touchTimeout = null, i.touchStartX = 0, i.touchDeltaX = 0, i._config = i._getConfig(n), i._indicatorsElement = q.findOne(\".carousel-indicators\", i._element), i._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, i._pointerEvent = Boolean(window.PointerEvent), i._addEventListeners(), i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.next = function () {\n      this._isSliding || this._slide(\"next\");\n    }, r.nextWhenVisible = function () {\n      !document.hidden && g(this._element) && this.next();\n    }, r.prev = function () {\n      this._isSliding || this._slide(\"prev\");\n    }, r.pause = function (t) {\n      t || (this._isPaused = !0), q.findOne(\".carousel-item-next, .carousel-item-prev\", this._element) && (f(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n    }, r.cycle = function (t) {\n      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));\n    }, r.to = function (t) {\n      var e = this;\n      this._activeElement = q.findOne(\".active.carousel-item\", this._element);\n\n      var n = this._getItemIndex(this._activeElement);\n\n      if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding) H.one(this._element, \"slid.bs.carousel\", function () {\n        return e.to(t);\n      });else {\n        if (n === t) return this.pause(), void this.cycle();\n        var i = t > n ? \"next\" : \"prev\";\n\n        this._slide(i, this._items[t]);\n      }\n    }, r.dispose = function () {\n      t.prototype.dispose.call(this), H.off(this._element, V), this._items = null, this._config = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null;\n    }, r._getConfig = function (t) {\n      return t = n({}, X, t), p(z, t, $), t;\n    }, r._handleSwipe = function () {\n      var t = Math.abs(this.touchDeltaX);\n\n      if (!(t <= 40)) {\n        var e = t / this.touchDeltaX;\n        this.touchDeltaX = 0, e > 0 && this.prev(), e < 0 && this.next();\n      }\n    }, r._addEventListeners = function () {\n      var t = this;\n      this._config.keyboard && H.on(this._element, \"keydown.bs.carousel\", function (e) {\n        return t._keydown(e);\n      }), \"hover\" === this._config.pause && (H.on(this._element, \"mouseenter.bs.carousel\", function (e) {\n        return t.pause(e);\n      }), H.on(this._element, \"mouseleave.bs.carousel\", function (e) {\n        return t.cycle(e);\n      })), this._config.touch && this._touchSupported && this._addTouchEventListeners();\n    }, r._addTouchEventListeners = function () {\n      var t = this,\n          e = function e(_e2) {\n        t._pointerEvent && G[_e2.pointerType.toUpperCase()] ? t.touchStartX = _e2.clientX : t._pointerEvent || (t.touchStartX = _e2.touches[0].clientX);\n      },\n          n = function n(e) {\n        t._pointerEvent && G[e.pointerType.toUpperCase()] && (t.touchDeltaX = e.clientX - t.touchStartX), t._handleSwipe(), \"hover\" === t._config.pause && (t.pause(), t.touchTimeout && clearTimeout(t.touchTimeout), t.touchTimeout = setTimeout(function (e) {\n          return t.cycle(e);\n        }, 500 + t._config.interval));\n      };\n\n      q.find(\".carousel-item img\", this._element).forEach(function (t) {\n        H.on(t, \"dragstart.bs.carousel\", function (t) {\n          return t.preventDefault();\n        });\n      }), this._pointerEvent ? (H.on(this._element, \"pointerdown.bs.carousel\", function (t) {\n        return e(t);\n      }), H.on(this._element, \"pointerup.bs.carousel\", function (t) {\n        return n(t);\n      }), this._element.classList.add(\"pointer-event\")) : (H.on(this._element, \"touchstart.bs.carousel\", function (t) {\n        return e(t);\n      }), H.on(this._element, \"touchmove.bs.carousel\", function (e) {\n        return function (e) {\n          e.touches && e.touches.length > 1 ? t.touchDeltaX = 0 : t.touchDeltaX = e.touches[0].clientX - t.touchStartX;\n        }(e);\n      }), H.on(this._element, \"touchend.bs.carousel\", function (t) {\n        return n(t);\n      }));\n    }, r._keydown = function (t) {\n      if (!/input|textarea/i.test(t.target.tagName)) switch (t.key) {\n        case \"ArrowLeft\":\n          t.preventDefault(), this.prev();\n          break;\n\n        case \"ArrowRight\":\n          t.preventDefault(), this.next();\n      }\n    }, r._getItemIndex = function (t) {\n      return this._items = t && t.parentNode ? q.find(\".carousel-item\", t.parentNode) : [], this._items.indexOf(t);\n    }, r._getItemByDirection = function (t, e) {\n      var n = \"next\" === t,\n          i = \"prev\" === t,\n          o = this._getItemIndex(e),\n          r = this._items.length - 1;\n\n      if ((i && 0 === o || n && o === r) && !this._config.wrap) return e;\n      var s = (o + (\"prev\" === t ? -1 : 1)) % this._items.length;\n      return -1 === s ? this._items[this._items.length - 1] : this._items[s];\n    }, r._triggerSlideEvent = function (t, e) {\n      var n = this._getItemIndex(t),\n          i = this._getItemIndex(q.findOne(\".active.carousel-item\", this._element));\n\n      return H.trigger(this._element, \"slide.bs.carousel\", {\n        relatedTarget: t,\n        direction: e,\n        from: i,\n        to: n\n      });\n    }, r._setActiveIndicatorElement = function (t) {\n      if (this._indicatorsElement) {\n        for (var e = q.find(\".active\", this._indicatorsElement), n = 0; n < e.length; n++) {\n          e[n].classList.remove(\"active\");\n        }\n\n        var i = this._indicatorsElement.children[this._getItemIndex(t)];\n\n        i && i.classList.add(\"active\");\n      }\n    }, r._updateInterval = function () {\n      var t = this._activeElement || q.findOne(\".active.carousel-item\", this._element);\n\n      if (t) {\n        var e = Number.parseInt(t.getAttribute(\"data-bs-interval\"), 10);\n        e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n      }\n    }, r._slide = function (t, e) {\n      var n,\n          i,\n          o,\n          r = this,\n          s = q.findOne(\".active.carousel-item\", this._element),\n          a = this._getItemIndex(s),\n          l = e || s && this._getItemByDirection(t, s),\n          c = this._getItemIndex(l),\n          f = Boolean(this._interval);\n\n      if (\"next\" === t ? (n = \"carousel-item-start\", i = \"carousel-item-next\", o = \"left\") : (n = \"carousel-item-end\", i = \"carousel-item-prev\", o = \"right\"), l && l.classList.contains(\"active\")) this._isSliding = !1;else if (!this._triggerSlideEvent(l, o).defaultPrevented && s && l) {\n        if (this._isSliding = !0, f && this.pause(), this._setActiveIndicatorElement(l), this._activeElement = l, this._element.classList.contains(\"slide\")) {\n          l.classList.add(i), v(l), s.classList.add(n), l.classList.add(n);\n          var d = u(s);\n          H.one(s, \"transitionend\", function () {\n            l.classList.remove(n, i), l.classList.add(\"active\"), s.classList.remove(\"active\", i, n), r._isSliding = !1, setTimeout(function () {\n              H.trigger(r._element, \"slid.bs.carousel\", {\n                relatedTarget: l,\n                direction: o,\n                from: a,\n                to: c\n              });\n            }, 0);\n          }), h(s, d);\n        } else s.classList.remove(\"active\"), l.classList.add(\"active\"), this._isSliding = !1, H.trigger(this._element, \"slid.bs.carousel\", {\n          relatedTarget: l,\n          direction: o,\n          from: a,\n          to: c\n        });\n\n        f && this.cycle();\n      }\n    }, o.carouselInterface = function (t, e) {\n      var i = T(t, \"bs.carousel\"),\n          r = n({}, X, Y.getDataAttributes(t));\n      \"object\" == _typeof(e) && (r = n({}, r, e));\n      var s = \"string\" == typeof e ? e : r.slide;\n      if (i || (i = new o(t, r)), \"number\" == typeof e) i.to(e);else if (\"string\" == typeof s) {\n        if (void 0 === i[s]) throw new TypeError('No method named \"' + s + '\"');\n        i[s]();\n      } else r.interval && r.ride && (i.pause(), i.cycle());\n    }, o.jQueryInterface = function (t) {\n      return this.each(function () {\n        o.carouselInterface(this, t);\n      });\n    }, o.dataApiClickHandler = function (t) {\n      var e = c(this);\n\n      if (e && e.classList.contains(\"carousel\")) {\n        var i = n({}, Y.getDataAttributes(e), Y.getDataAttributes(this)),\n            r = this.getAttribute(\"data-bs-slide-to\");\n        r && (i.interval = !1), o.carouselInterface(e, i), r && T(e, \"bs.carousel\").to(r), t.preventDefault();\n      }\n    }, e(o, null, [{\n      key: \"Default\",\n      get: function get() {\n        return X;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.carousel\";\n      }\n    }]), o;\n  }(R);\n\n  H.on(document, \"click.bs.carousel.data-api\", \"[data-bs-slide], [data-bs-slide-to]\", Z.dataApiClickHandler), H.on(window, \"load.bs.carousel.data-api\", function () {\n    for (var t = q.find('[data-bs-ride=\"carousel\"]'), e = 0, n = t.length; e < n; e++) {\n      Z.carouselInterface(t[e], T(t[e], \"bs.carousel\"));\n    }\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[z];\n      t.fn[z] = Z.jQueryInterface, t.fn[z].Constructor = Z, t.fn[z].noConflict = function () {\n        return t.fn[z] = e, Z.jQueryInterface;\n      };\n    }\n  });\n\n  var J = \"collapse\",\n      tt = {\n    toggle: !0,\n    parent: \"\"\n  },\n      et = {\n    toggle: \"boolean\",\n    parent: \"(string|element)\"\n  },\n      nt = function (t) {\n    function o(e, n) {\n      var i;\n      (i = t.call(this, e) || this)._isTransitioning = !1, i._config = i._getConfig(n), i._triggerArray = q.find('[data-bs-toggle=\"collapse\"][href=\"#' + e.id + '\"],[data-bs-toggle=\"collapse\"][data-bs-target=\"#' + e.id + '\"]');\n\n      for (var o = q.find('[data-bs-toggle=\"collapse\"]'), r = 0, s = o.length; r < s; r++) {\n        var a = o[r],\n            c = l(a),\n            u = q.find(c).filter(function (t) {\n          return t === e;\n        });\n        null !== c && u.length && (i._selector = c, i._triggerArray.push(a));\n      }\n\n      return i._parent = i._config.parent ? i._getParent() : null, i._config.parent || i._addAriaAndCollapsedClass(i._element, i._triggerArray), i._config.toggle && i.toggle(), i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.toggle = function () {\n      this._element.classList.contains(\"show\") ? this.hide() : this.show();\n    }, r.show = function () {\n      var t = this;\n\n      if (!this._isTransitioning && !this._element.classList.contains(\"show\")) {\n        var e, n;\n        this._parent && 0 === (e = q.find(\".show, .collapsing\", this._parent).filter(function (e) {\n          return \"string\" == typeof t._config.parent ? e.getAttribute(\"data-bs-parent\") === t._config.parent : e.classList.contains(\"collapse\");\n        })).length && (e = null);\n        var i = q.findOne(this._selector);\n\n        if (e) {\n          var r = e.find(function (t) {\n            return i !== t;\n          });\n          if ((n = r ? T(r, \"bs.collapse\") : null) && n._isTransitioning) return;\n        }\n\n        if (!H.trigger(this._element, \"show.bs.collapse\").defaultPrevented) {\n          e && e.forEach(function (t) {\n            i !== t && o.collapseInterface(t, \"hide\"), n || E(t, \"bs.collapse\", null);\n          });\n\n          var s = this._getDimension();\n\n          this._element.classList.remove(\"collapse\"), this._element.classList.add(\"collapsing\"), this._element.style[s] = 0, this._triggerArray.length && this._triggerArray.forEach(function (t) {\n            t.classList.remove(\"collapsed\"), t.setAttribute(\"aria-expanded\", !0);\n          }), this.setTransitioning(!0);\n          var a = \"scroll\" + (s[0].toUpperCase() + s.slice(1)),\n              l = u(this._element);\n          H.one(this._element, \"transitionend\", function () {\n            t._element.classList.remove(\"collapsing\"), t._element.classList.add(\"collapse\", \"show\"), t._element.style[s] = \"\", t.setTransitioning(!1), H.trigger(t._element, \"shown.bs.collapse\");\n          }), h(this._element, l), this._element.style[s] = this._element[a] + \"px\";\n        }\n      }\n    }, r.hide = function () {\n      var t = this;\n\n      if (!this._isTransitioning && this._element.classList.contains(\"show\") && !H.trigger(this._element, \"hide.bs.collapse\").defaultPrevented) {\n        var e = this._getDimension();\n\n        this._element.style[e] = this._element.getBoundingClientRect()[e] + \"px\", v(this._element), this._element.classList.add(\"collapsing\"), this._element.classList.remove(\"collapse\", \"show\");\n        var n = this._triggerArray.length;\n        if (n > 0) for (var i = 0; i < n; i++) {\n          var o = this._triggerArray[i],\n              r = c(o);\n          r && !r.classList.contains(\"show\") && (o.classList.add(\"collapsed\"), o.setAttribute(\"aria-expanded\", !1));\n        }\n        this.setTransitioning(!0);\n        this._element.style[e] = \"\";\n        var s = u(this._element);\n        H.one(this._element, \"transitionend\", function () {\n          t.setTransitioning(!1), t._element.classList.remove(\"collapsing\"), t._element.classList.add(\"collapse\"), H.trigger(t._element, \"hidden.bs.collapse\");\n        }), h(this._element, s);\n      }\n    }, r.setTransitioning = function (t) {\n      this._isTransitioning = t;\n    }, r.dispose = function () {\n      t.prototype.dispose.call(this), this._config = null, this._parent = null, this._triggerArray = null, this._isTransitioning = null;\n    }, r._getConfig = function (t) {\n      return (t = n({}, tt, t)).toggle = Boolean(t.toggle), p(J, t, et), t;\n    }, r._getDimension = function () {\n      return this._element.classList.contains(\"width\") ? \"width\" : \"height\";\n    }, r._getParent = function () {\n      var t = this,\n          e = this._config.parent;\n      d(e) ? void 0 === e.jquery && void 0 === e[0] || (e = e[0]) : e = q.findOne(e);\n      var n = '[data-bs-toggle=\"collapse\"][data-bs-parent=\"' + e + '\"]';\n      return q.find(n, e).forEach(function (e) {\n        var n = c(e);\n\n        t._addAriaAndCollapsedClass(n, [e]);\n      }), e;\n    }, r._addAriaAndCollapsedClass = function (t, e) {\n      if (t && e.length) {\n        var n = t.classList.contains(\"show\");\n        e.forEach(function (t) {\n          n ? t.classList.remove(\"collapsed\") : t.classList.add(\"collapsed\"), t.setAttribute(\"aria-expanded\", n);\n        });\n      }\n    }, o.collapseInterface = function (t, e) {\n      var i = T(t, \"bs.collapse\"),\n          r = n({}, tt, Y.getDataAttributes(t), \"object\" == _typeof(e) && e ? e : {});\n\n      if (!i && r.toggle && \"string\" == typeof e && /show|hide/.test(e) && (r.toggle = !1), i || (i = new o(t, r)), \"string\" == typeof e) {\n        if (void 0 === i[e]) throw new TypeError('No method named \"' + e + '\"');\n        i[e]();\n      }\n    }, o.jQueryInterface = function (t) {\n      return this.each(function () {\n        o.collapseInterface(this, t);\n      });\n    }, e(o, null, [{\n      key: \"Default\",\n      get: function get() {\n        return tt;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.collapse\";\n      }\n    }]), o;\n  }(R);\n\n  H.on(document, \"click.bs.collapse.data-api\", '[data-bs-toggle=\"collapse\"]', function (t) {\n    \"A\" === t.target.tagName && t.preventDefault();\n    var e = Y.getDataAttributes(this),\n        n = l(this);\n    q.find(n).forEach(function (t) {\n      var n,\n          i = T(t, \"bs.collapse\");\n      i ? (null === i._parent && \"string\" == typeof e.parent && (i._config.parent = e.parent, i._parent = i._getParent()), n = \"toggle\") : n = e, nt.collapseInterface(t, n);\n    });\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[J];\n      t.fn[J] = nt.jQueryInterface, t.fn[J].Constructor = nt, t.fn[J].noConflict = function () {\n        return t.fn[J] = e, nt.jQueryInterface;\n      };\n    }\n  });\n  var it = \"top\",\n      ot = \"bottom\",\n      rt = \"right\",\n      st = \"left\",\n      at = [it, ot, rt, st],\n      lt = at.reduce(function (t, e) {\n    return t.concat([e + \"-start\", e + \"-end\"]);\n  }, []),\n      ct = [].concat(at, [\"auto\"]).reduce(function (t, e) {\n    return t.concat([e, e + \"-start\", e + \"-end\"]);\n  }, []),\n      ut = [\"beforeRead\", \"read\", \"afterRead\", \"beforeMain\", \"main\", \"afterMain\", \"beforeWrite\", \"write\", \"afterWrite\"];\n\n  function ft(t) {\n    return t ? (t.nodeName || \"\").toLowerCase() : null;\n  }\n\n  function dt(t) {\n    if (\"[object Window]\" !== t.toString()) {\n      var e = t.ownerDocument;\n      return e && e.defaultView || window;\n    }\n\n    return t;\n  }\n\n  function ht(t) {\n    return t instanceof dt(t).Element || t instanceof Element;\n  }\n\n  function pt(t) {\n    return t instanceof dt(t).HTMLElement || t instanceof HTMLElement;\n  }\n\n  var gt = {\n    name: \"applyStyles\",\n    enabled: !0,\n    phase: \"write\",\n    fn: function fn(t) {\n      var e = t.state;\n      Object.keys(e.elements).forEach(function (t) {\n        var n = e.styles[t] || {},\n            i = e.attributes[t] || {},\n            o = e.elements[t];\n        pt(o) && ft(o) && (Object.assign(o.style, n), Object.keys(i).forEach(function (t) {\n          var e = i[t];\n          !1 === e ? o.removeAttribute(t) : o.setAttribute(t, !0 === e ? \"\" : e);\n        }));\n      });\n    },\n    effect: function effect(t) {\n      var e = t.state,\n          n = {\n        popper: {\n          position: e.options.strategy,\n          left: \"0\",\n          top: \"0\",\n          margin: \"0\"\n        },\n        arrow: {\n          position: \"absolute\"\n        },\n        reference: {}\n      };\n      return Object.assign(e.elements.popper.style, n.popper), e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () {\n        Object.keys(e.elements).forEach(function (t) {\n          var i = e.elements[t],\n              o = e.attributes[t] || {},\n              r = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce(function (t, e) {\n            return t[e] = \"\", t;\n          }, {});\n          pt(i) && ft(i) && (Object.assign(i.style, r), Object.keys(o).forEach(function (t) {\n            i.removeAttribute(t);\n          }));\n        });\n      };\n    },\n    requires: [\"computeStyles\"]\n  };\n\n  function mt(t) {\n    return t.split(\"-\")[0];\n  }\n\n  function vt(t) {\n    return {\n      x: t.offsetLeft,\n      y: t.offsetTop,\n      width: t.offsetWidth,\n      height: t.offsetHeight\n    };\n  }\n\n  function _t(t, e) {\n    var n,\n        i = e.getRootNode && e.getRootNode();\n    if (t.contains(e)) return !0;\n\n    if (i && ((n = i) instanceof dt(n).ShadowRoot || n instanceof ShadowRoot)) {\n      var o = e;\n\n      do {\n        if (o && t.isSameNode(o)) return !0;\n        o = o.parentNode || o.host;\n      } while (o);\n    }\n\n    return !1;\n  }\n\n  function bt(t) {\n    return dt(t).getComputedStyle(t);\n  }\n\n  function yt(t) {\n    return [\"table\", \"td\", \"th\"].indexOf(ft(t)) >= 0;\n  }\n\n  function wt(t) {\n    return ((ht(t) ? t.ownerDocument : t.document) || window.document).documentElement;\n  }\n\n  function Et(t) {\n    return \"html\" === ft(t) ? t : t.assignedSlot || t.parentNode || t.host || wt(t);\n  }\n\n  function Tt(t) {\n    if (!pt(t) || \"fixed\" === bt(t).position) return null;\n    var e = t.offsetParent;\n\n    if (e) {\n      var n = wt(e);\n      if (\"body\" === ft(e) && \"static\" === bt(e).position && \"static\" !== bt(n).position) return n;\n    }\n\n    return e;\n  }\n\n  function kt(t) {\n    for (var e = dt(t), n = Tt(t); n && yt(n) && \"static\" === bt(n).position;) {\n      n = Tt(n);\n    }\n\n    return n && \"body\" === ft(n) && \"static\" === bt(n).position ? e : n || function (t) {\n      for (var e = Et(t); pt(e) && [\"html\", \"body\"].indexOf(ft(e)) < 0;) {\n        var n = bt(e);\n        if (\"none\" !== n.transform || \"none\" !== n.perspective || n.willChange && \"auto\" !== n.willChange) return e;\n        e = e.parentNode;\n      }\n\n      return null;\n    }(t) || e;\n  }\n\n  function Ot(t) {\n    return [\"top\", \"bottom\"].indexOf(t) >= 0 ? \"x\" : \"y\";\n  }\n\n  function Lt(t, e, n) {\n    return Math.max(t, Math.min(e, n));\n  }\n\n  function At(t) {\n    return Object.assign(Object.assign({}, {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }), t);\n  }\n\n  function Ct(t, e) {\n    return e.reduce(function (e, n) {\n      return e[n] = t, e;\n    }, {});\n  }\n\n  var Dt = {\n    name: \"arrow\",\n    enabled: !0,\n    phase: \"main\",\n    fn: function fn(t) {\n      var e,\n          n = t.state,\n          i = t.name,\n          o = n.elements.arrow,\n          r = n.modifiersData.popperOffsets,\n          s = mt(n.placement),\n          a = Ot(s),\n          l = [st, rt].indexOf(s) >= 0 ? \"height\" : \"width\";\n\n      if (o && r) {\n        var c = n.modifiersData[i + \"#persistent\"].padding,\n            u = vt(o),\n            f = \"y\" === a ? it : st,\n            d = \"y\" === a ? ot : rt,\n            h = n.rects.reference[l] + n.rects.reference[a] - r[a] - n.rects.popper[l],\n            p = r[a] - n.rects.reference[a],\n            g = kt(o),\n            m = g ? \"y\" === a ? g.clientHeight || 0 : g.clientWidth || 0 : 0,\n            v = h / 2 - p / 2,\n            _ = c[f],\n            b = m - u[l] - c[d],\n            y = m / 2 - u[l] / 2 + v,\n            w = Lt(_, y, b),\n            E = a;\n        n.modifiersData[i] = ((e = {})[E] = w, e.centerOffset = w - y, e);\n      }\n    },\n    effect: function effect(t) {\n      var e = t.state,\n          n = t.options,\n          i = t.name,\n          o = n.element,\n          r = void 0 === o ? \"[data-popper-arrow]\" : o,\n          s = n.padding,\n          a = void 0 === s ? 0 : s;\n      null != r && (\"string\" != typeof r || (r = e.elements.popper.querySelector(r))) && _t(e.elements.popper, r) && (e.elements.arrow = r, e.modifiersData[i + \"#persistent\"] = {\n        padding: At(\"number\" != typeof a ? a : Ct(a, at))\n      });\n    },\n    requires: [\"popperOffsets\"],\n    requiresIfExists: [\"preventOverflow\"]\n  },\n      xt = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n  };\n\n  function St(t) {\n    var e,\n        n = t.popper,\n        i = t.popperRect,\n        o = t.placement,\n        r = t.offsets,\n        s = t.position,\n        a = t.gpuAcceleration,\n        l = t.adaptive,\n        c = function (t) {\n      var e = t.x,\n          n = t.y,\n          i = window.devicePixelRatio || 1;\n      return {\n        x: Math.round(e * i) / i || 0,\n        y: Math.round(n * i) / i || 0\n      };\n    }(r),\n        u = c.x,\n        f = c.y,\n        d = r.hasOwnProperty(\"x\"),\n        h = r.hasOwnProperty(\"y\"),\n        p = st,\n        g = it,\n        m = window;\n\n    if (l) {\n      var v = kt(n);\n      v === dt(n) && (v = wt(n)), o === it && (g = ot, f -= v.clientHeight - i.height, f *= a ? 1 : -1), o === st && (p = rt, u -= v.clientWidth - i.width, u *= a ? 1 : -1);\n    }\n\n    var _,\n        b = Object.assign({\n      position: s\n    }, l && xt);\n\n    return a ? Object.assign(Object.assign({}, b), {}, ((_ = {})[g] = h ? \"0\" : \"\", _[p] = d ? \"0\" : \"\", _.transform = (m.devicePixelRatio || 1) < 2 ? \"translate(\" + u + \"px, \" + f + \"px)\" : \"translate3d(\" + u + \"px, \" + f + \"px, 0)\", _)) : Object.assign(Object.assign({}, b), {}, ((e = {})[g] = h ? f + \"px\" : \"\", e[p] = d ? u + \"px\" : \"\", e.transform = \"\", e));\n  }\n\n  var jt = {\n    name: \"computeStyles\",\n    enabled: !0,\n    phase: \"beforeWrite\",\n    fn: function fn(t) {\n      var e = t.state,\n          n = t.options,\n          i = n.gpuAcceleration,\n          o = void 0 === i || i,\n          r = n.adaptive,\n          s = void 0 === r || r,\n          a = {\n        placement: mt(e.placement),\n        popper: e.elements.popper,\n        popperRect: e.rects.popper,\n        gpuAcceleration: o\n      };\n      null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign(Object.assign({}, e.styles.popper), St(Object.assign(Object.assign({}, a), {}, {\n        offsets: e.modifiersData.popperOffsets,\n        position: e.options.strategy,\n        adaptive: s\n      })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign(Object.assign({}, e.styles.arrow), St(Object.assign(Object.assign({}, a), {}, {\n        offsets: e.modifiersData.arrow,\n        position: \"absolute\",\n        adaptive: !1\n      })))), e.attributes.popper = Object.assign(Object.assign({}, e.attributes.popper), {}, {\n        \"data-popper-placement\": e.placement\n      });\n    },\n    data: {}\n  },\n      Nt = {\n    passive: !0\n  };\n  var It = {\n    name: \"eventListeners\",\n    enabled: !0,\n    phase: \"write\",\n    fn: function fn() {},\n    effect: function effect(t) {\n      var e = t.state,\n          n = t.instance,\n          i = t.options,\n          o = i.scroll,\n          r = void 0 === o || o,\n          s = i.resize,\n          a = void 0 === s || s,\n          l = dt(e.elements.popper),\n          c = [].concat(e.scrollParents.reference, e.scrollParents.popper);\n      return r && c.forEach(function (t) {\n        t.addEventListener(\"scroll\", n.update, Nt);\n      }), a && l.addEventListener(\"resize\", n.update, Nt), function () {\n        r && c.forEach(function (t) {\n          t.removeEventListener(\"scroll\", n.update, Nt);\n        }), a && l.removeEventListener(\"resize\", n.update, Nt);\n      };\n    },\n    data: {}\n  },\n      Pt = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  };\n\n  function Mt(t) {\n    return t.replace(/left|right|bottom|top/g, function (t) {\n      return Pt[t];\n    });\n  }\n\n  var Bt = {\n    start: \"end\",\n    end: \"start\"\n  };\n\n  function Ht(t) {\n    return t.replace(/start|end/g, function (t) {\n      return Bt[t];\n    });\n  }\n\n  function Rt(t) {\n    var e = t.getBoundingClientRect();\n    return {\n      width: e.width,\n      height: e.height,\n      top: e.top,\n      right: e.right,\n      bottom: e.bottom,\n      left: e.left,\n      x: e.left,\n      y: e.top\n    };\n  }\n\n  function Wt(t) {\n    var e = dt(t);\n    return {\n      scrollLeft: e.pageXOffset,\n      scrollTop: e.pageYOffset\n    };\n  }\n\n  function Kt(t) {\n    return Rt(wt(t)).left + Wt(t).scrollLeft;\n  }\n\n  function Qt(t) {\n    var e = bt(t),\n        n = e.overflow,\n        i = e.overflowX,\n        o = e.overflowY;\n    return /auto|scroll|overlay|hidden/.test(n + o + i);\n  }\n\n  function Ut(t, e) {\n    void 0 === e && (e = []);\n\n    var n = function t(e) {\n      return [\"html\", \"body\", \"#document\"].indexOf(ft(e)) >= 0 ? e.ownerDocument.body : pt(e) && Qt(e) ? e : t(Et(e));\n    }(t),\n        i = \"body\" === ft(n),\n        o = dt(n),\n        r = i ? [o].concat(o.visualViewport || [], Qt(n) ? n : []) : n,\n        s = e.concat(r);\n\n    return i ? s : s.concat(Ut(Et(r)));\n  }\n\n  function Ft(t) {\n    return Object.assign(Object.assign({}, t), {}, {\n      left: t.x,\n      top: t.y,\n      right: t.x + t.width,\n      bottom: t.y + t.height\n    });\n  }\n\n  function Yt(t, e) {\n    return \"viewport\" === e ? Ft(function (t) {\n      var e = dt(t),\n          n = wt(t),\n          i = e.visualViewport,\n          o = n.clientWidth,\n          r = n.clientHeight,\n          s = 0,\n          a = 0;\n      return i && (o = i.width, r = i.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (s = i.offsetLeft, a = i.offsetTop)), {\n        width: o,\n        height: r,\n        x: s + Kt(t),\n        y: a\n      };\n    }(t)) : pt(e) ? function (t) {\n      var e = Rt(t);\n      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;\n    }(e) : Ft(function (t) {\n      var e = wt(t),\n          n = Wt(t),\n          i = t.ownerDocument.body,\n          o = Math.max(e.scrollWidth, e.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),\n          r = Math.max(e.scrollHeight, e.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),\n          s = -n.scrollLeft + Kt(t),\n          a = -n.scrollTop;\n      return \"rtl\" === bt(i || e).direction && (s += Math.max(e.clientWidth, i ? i.clientWidth : 0) - o), {\n        width: o,\n        height: r,\n        x: s,\n        y: a\n      };\n    }(wt(t)));\n  }\n\n  function qt(t, e, n) {\n    var i = \"clippingParents\" === e ? function (t) {\n      var e = Ut(Et(t)),\n          n = [\"absolute\", \"fixed\"].indexOf(bt(t).position) >= 0 && pt(t) ? kt(t) : t;\n      return ht(n) ? e.filter(function (t) {\n        return ht(t) && _t(t, n) && \"body\" !== ft(t);\n      }) : [];\n    }(t) : [].concat(e),\n        o = [].concat(i, [n]),\n        r = o[0],\n        s = o.reduce(function (e, n) {\n      var i = Yt(t, n);\n      return e.top = Math.max(i.top, e.top), e.right = Math.min(i.right, e.right), e.bottom = Math.min(i.bottom, e.bottom), e.left = Math.max(i.left, e.left), e;\n    }, Yt(t, r));\n    return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;\n  }\n\n  function zt(t) {\n    return t.split(\"-\")[1];\n  }\n\n  function Vt(t) {\n    var e,\n        n = t.reference,\n        i = t.element,\n        o = t.placement,\n        r = o ? mt(o) : null,\n        s = o ? zt(o) : null,\n        a = n.x + n.width / 2 - i.width / 2,\n        l = n.y + n.height / 2 - i.height / 2;\n\n    switch (r) {\n      case it:\n        e = {\n          x: a,\n          y: n.y - i.height\n        };\n        break;\n\n      case ot:\n        e = {\n          x: a,\n          y: n.y + n.height\n        };\n        break;\n\n      case rt:\n        e = {\n          x: n.x + n.width,\n          y: l\n        };\n        break;\n\n      case st:\n        e = {\n          x: n.x - i.width,\n          y: l\n        };\n        break;\n\n      default:\n        e = {\n          x: n.x,\n          y: n.y\n        };\n    }\n\n    var c = r ? Ot(r) : null;\n\n    if (null != c) {\n      var u = \"y\" === c ? \"height\" : \"width\";\n\n      switch (s) {\n        case \"start\":\n          e[c] = Math.floor(e[c]) - Math.floor(n[u] / 2 - i[u] / 2);\n          break;\n\n        case \"end\":\n          e[c] = Math.floor(e[c]) + Math.ceil(n[u] / 2 - i[u] / 2);\n      }\n    }\n\n    return e;\n  }\n\n  function Xt(t, e) {\n    void 0 === e && (e = {});\n    var n = e,\n        i = n.placement,\n        o = void 0 === i ? t.placement : i,\n        r = n.boundary,\n        s = void 0 === r ? \"clippingParents\" : r,\n        a = n.rootBoundary,\n        l = void 0 === a ? \"viewport\" : a,\n        c = n.elementContext,\n        u = void 0 === c ? \"popper\" : c,\n        f = n.altBoundary,\n        d = void 0 !== f && f,\n        h = n.padding,\n        p = void 0 === h ? 0 : h,\n        g = At(\"number\" != typeof p ? p : Ct(p, at)),\n        m = \"popper\" === u ? \"reference\" : \"popper\",\n        v = t.elements.reference,\n        _ = t.rects.popper,\n        b = t.elements[d ? m : u],\n        y = qt(ht(b) ? b : b.contextElement || wt(t.elements.popper), s, l),\n        w = Rt(v),\n        E = Vt({\n      reference: w,\n      element: _,\n      strategy: \"absolute\",\n      placement: o\n    }),\n        T = Ft(Object.assign(Object.assign({}, _), E)),\n        k = \"popper\" === u ? T : w,\n        O = {\n      top: y.top - k.top + g.top,\n      bottom: k.bottom - y.bottom + g.bottom,\n      left: y.left - k.left + g.left,\n      right: k.right - y.right + g.right\n    },\n        L = t.modifiersData.offset;\n\n    if (\"popper\" === u && L) {\n      var A = L[o];\n      Object.keys(O).forEach(function (t) {\n        var e = [rt, ot].indexOf(t) >= 0 ? 1 : -1,\n            n = [it, ot].indexOf(t) >= 0 ? \"y\" : \"x\";\n        O[t] += A[n] * e;\n      });\n    }\n\n    return O;\n  }\n\n  function $t(t, e) {\n    void 0 === e && (e = {});\n    var n = e,\n        i = n.placement,\n        o = n.boundary,\n        r = n.rootBoundary,\n        s = n.padding,\n        a = n.flipVariations,\n        l = n.allowedAutoPlacements,\n        c = void 0 === l ? ct : l,\n        u = zt(i),\n        f = u ? a ? lt : lt.filter(function (t) {\n      return zt(t) === u;\n    }) : at,\n        d = f.filter(function (t) {\n      return c.indexOf(t) >= 0;\n    });\n    0 === d.length && (d = f);\n    var h = d.reduce(function (e, n) {\n      return e[n] = Xt(t, {\n        placement: n,\n        boundary: o,\n        rootBoundary: r,\n        padding: s\n      })[mt(n)], e;\n    }, {});\n    return Object.keys(h).sort(function (t, e) {\n      return h[t] - h[e];\n    });\n  }\n\n  var Gt = {\n    name: \"flip\",\n    enabled: !0,\n    phase: \"main\",\n    fn: function fn(t) {\n      var e = t.state,\n          n = t.options,\n          i = t.name;\n\n      if (!e.modifiersData[i]._skip) {\n        for (var o = n.mainAxis, r = void 0 === o || o, s = n.altAxis, a = void 0 === s || s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, f = n.rootBoundary, d = n.altBoundary, h = n.flipVariations, p = void 0 === h || h, g = n.allowedAutoPlacements, m = e.options.placement, v = mt(m), _ = l || (v === m || !p ? [Mt(m)] : function (t) {\n          if (\"auto\" === mt(t)) return [];\n          var e = Mt(t);\n          return [Ht(t), e, Ht(e)];\n        }(m)), b = [m].concat(_).reduce(function (t, n) {\n          return t.concat(\"auto\" === mt(n) ? $t(e, {\n            placement: n,\n            boundary: u,\n            rootBoundary: f,\n            padding: c,\n            flipVariations: p,\n            allowedAutoPlacements: g\n          }) : n);\n        }, []), y = e.rects.reference, w = e.rects.popper, E = new Map(), T = !0, k = b[0], O = 0; O < b.length; O++) {\n          var L = b[O],\n              A = mt(L),\n              C = \"start\" === zt(L),\n              D = [it, ot].indexOf(A) >= 0,\n              x = D ? \"width\" : \"height\",\n              S = Xt(e, {\n            placement: L,\n            boundary: u,\n            rootBoundary: f,\n            altBoundary: d,\n            padding: c\n          }),\n              j = D ? C ? rt : st : C ? ot : it;\n          y[x] > w[x] && (j = Mt(j));\n          var N = Mt(j),\n              I = [];\n\n          if (r && I.push(S[A] <= 0), a && I.push(S[j] <= 0, S[N] <= 0), I.every(function (t) {\n            return t;\n          })) {\n            k = L, T = !1;\n            break;\n          }\n\n          E.set(L, I);\n        }\n\n        if (T) for (var P = function P(t) {\n          var e = b.find(function (e) {\n            var n = E.get(e);\n            if (n) return n.slice(0, t).every(function (t) {\n              return t;\n            });\n          });\n          if (e) return k = e, \"break\";\n        }, M = p ? 3 : 1; M > 0; M--) {\n          if (\"break\" === P(M)) break;\n        }\n        e.placement !== k && (e.modifiersData[i]._skip = !0, e.placement = k, e.reset = !0);\n      }\n    },\n    requiresIfExists: [\"offset\"],\n    data: {\n      _skip: !1\n    }\n  };\n\n  function Zt(t, e, n) {\n    return void 0 === n && (n = {\n      x: 0,\n      y: 0\n    }), {\n      top: t.top - e.height - n.y,\n      right: t.right - e.width + n.x,\n      bottom: t.bottom - e.height + n.y,\n      left: t.left - e.width - n.x\n    };\n  }\n\n  function Jt(t) {\n    return [it, rt, ot, st].some(function (e) {\n      return t[e] >= 0;\n    });\n  }\n\n  var te = {\n    name: \"hide\",\n    enabled: !0,\n    phase: \"main\",\n    requiresIfExists: [\"preventOverflow\"],\n    fn: function fn(t) {\n      var e = t.state,\n          n = t.name,\n          i = e.rects.reference,\n          o = e.rects.popper,\n          r = e.modifiersData.preventOverflow,\n          s = Xt(e, {\n        elementContext: \"reference\"\n      }),\n          a = Xt(e, {\n        altBoundary: !0\n      }),\n          l = Zt(s, i),\n          c = Zt(a, o, r),\n          u = Jt(l),\n          f = Jt(c);\n      e.modifiersData[n] = {\n        referenceClippingOffsets: l,\n        popperEscapeOffsets: c,\n        isReferenceHidden: u,\n        hasPopperEscaped: f\n      }, e.attributes.popper = Object.assign(Object.assign({}, e.attributes.popper), {}, {\n        \"data-popper-reference-hidden\": u,\n        \"data-popper-escaped\": f\n      });\n    }\n  };\n  var ee = {\n    name: \"offset\",\n    enabled: !0,\n    phase: \"main\",\n    requires: [\"popperOffsets\"],\n    fn: function fn(t) {\n      var e = t.state,\n          n = t.options,\n          i = t.name,\n          o = n.offset,\n          r = void 0 === o ? [0, 0] : o,\n          s = ct.reduce(function (t, n) {\n        return t[n] = function (t, e, n) {\n          var i = mt(t),\n              o = [st, it].indexOf(i) >= 0 ? -1 : 1,\n              r = \"function\" == typeof n ? n(Object.assign(Object.assign({}, e), {}, {\n            placement: t\n          })) : n,\n              s = r[0],\n              a = r[1];\n          return s = s || 0, a = (a || 0) * o, [st, rt].indexOf(i) >= 0 ? {\n            x: a,\n            y: s\n          } : {\n            x: s,\n            y: a\n          };\n        }(n, e.rects, r), t;\n      }, {}),\n          a = s[e.placement],\n          l = a.x,\n          c = a.y;\n      null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[i] = s;\n    }\n  };\n  var ne = {\n    name: \"popperOffsets\",\n    enabled: !0,\n    phase: \"read\",\n    fn: function fn(t) {\n      var e = t.state,\n          n = t.name;\n      e.modifiersData[n] = Vt({\n        reference: e.rects.reference,\n        element: e.rects.popper,\n        strategy: \"absolute\",\n        placement: e.placement\n      });\n    },\n    data: {}\n  };\n  var ie = {\n    name: \"preventOverflow\",\n    enabled: !0,\n    phase: \"main\",\n    fn: function fn(t) {\n      var e = t.state,\n          n = t.options,\n          i = t.name,\n          o = n.mainAxis,\n          r = void 0 === o || o,\n          s = n.altAxis,\n          a = void 0 !== s && s,\n          l = n.boundary,\n          c = n.rootBoundary,\n          u = n.altBoundary,\n          f = n.padding,\n          d = n.tether,\n          h = void 0 === d || d,\n          p = n.tetherOffset,\n          g = void 0 === p ? 0 : p,\n          m = Xt(e, {\n        boundary: l,\n        rootBoundary: c,\n        padding: f,\n        altBoundary: u\n      }),\n          v = mt(e.placement),\n          _ = zt(e.placement),\n          b = !_,\n          y = Ot(v),\n          w = \"x\" === y ? \"y\" : \"x\",\n          E = e.modifiersData.popperOffsets,\n          T = e.rects.reference,\n          k = e.rects.popper,\n          O = \"function\" == typeof g ? g(Object.assign(Object.assign({}, e.rects), {}, {\n        placement: e.placement\n      })) : g,\n          L = {\n        x: 0,\n        y: 0\n      };\n\n      if (E) {\n        if (r) {\n          var A = \"y\" === y ? it : st,\n              C = \"y\" === y ? ot : rt,\n              D = \"y\" === y ? \"height\" : \"width\",\n              x = E[y],\n              S = E[y] + m[A],\n              j = E[y] - m[C],\n              N = h ? -k[D] / 2 : 0,\n              I = \"start\" === _ ? T[D] : k[D],\n              P = \"start\" === _ ? -k[D] : -T[D],\n              M = e.elements.arrow,\n              B = h && M ? vt(M) : {\n            width: 0,\n            height: 0\n          },\n              H = e.modifiersData[\"arrow#persistent\"] ? e.modifiersData[\"arrow#persistent\"].padding : {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n          },\n              R = H[A],\n              W = H[C],\n              K = Lt(0, T[D], B[D]),\n              Q = b ? T[D] / 2 - N - K - R - O : I - K - R - O,\n              U = b ? -T[D] / 2 + N + K + W + O : P + K + W + O,\n              F = e.elements.arrow && kt(e.elements.arrow),\n              Y = F ? \"y\" === y ? F.clientTop || 0 : F.clientLeft || 0 : 0,\n              q = e.modifiersData.offset ? e.modifiersData.offset[e.placement][y] : 0,\n              z = E[y] + Q - q - Y,\n              V = E[y] + U - q,\n              X = Lt(h ? Math.min(S, z) : S, x, h ? Math.max(j, V) : j);\n          E[y] = X, L[y] = X - x;\n        }\n\n        if (a) {\n          var $ = \"x\" === y ? it : st,\n              G = \"x\" === y ? ot : rt,\n              Z = E[w],\n              J = Lt(Z + m[$], Z, Z - m[G]);\n          E[w] = J, L[w] = J - Z;\n        }\n\n        e.modifiersData[i] = L;\n      }\n    },\n    requiresIfExists: [\"offset\"]\n  };\n\n  function oe(t, e, n) {\n    void 0 === n && (n = !1);\n    var i,\n        o,\n        r = wt(e),\n        s = Rt(t),\n        a = pt(e),\n        l = {\n      scrollLeft: 0,\n      scrollTop: 0\n    },\n        c = {\n      x: 0,\n      y: 0\n    };\n    return (a || !a && !n) && ((\"body\" !== ft(e) || Qt(r)) && (l = (i = e) !== dt(i) && pt(i) ? {\n      scrollLeft: (o = i).scrollLeft,\n      scrollTop: o.scrollTop\n    } : Wt(i)), pt(e) ? ((c = Rt(e)).x += e.clientLeft, c.y += e.clientTop) : r && (c.x = Kt(r))), {\n      x: s.left + l.scrollLeft - c.x,\n      y: s.top + l.scrollTop - c.y,\n      width: s.width,\n      height: s.height\n    };\n  }\n\n  function re(t) {\n    var e = new Map(),\n        n = new Set(),\n        i = [];\n    return t.forEach(function (t) {\n      e.set(t.name, t);\n    }), t.forEach(function (t) {\n      n.has(t.name) || function t(o) {\n        n.add(o.name), [].concat(o.requires || [], o.requiresIfExists || []).forEach(function (i) {\n          if (!n.has(i)) {\n            var o = e.get(i);\n            o && t(o);\n          }\n        }), i.push(o);\n      }(t);\n    }), i;\n  }\n\n  var se = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n  };\n\n  function ae() {\n    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {\n      e[n] = arguments[n];\n    }\n\n    return !e.some(function (t) {\n      return !(t && \"function\" == typeof t.getBoundingClientRect);\n    });\n  }\n\n  function le(t) {\n    void 0 === t && (t = {});\n    var e = t,\n        n = e.defaultModifiers,\n        i = void 0 === n ? [] : n,\n        o = e.defaultOptions,\n        r = void 0 === o ? se : o;\n    return function (t, e, n) {\n      void 0 === n && (n = r);\n      var o,\n          s,\n          a = {\n        placement: \"bottom\",\n        orderedModifiers: [],\n        options: Object.assign(Object.assign({}, se), r),\n        modifiersData: {},\n        elements: {\n          reference: t,\n          popper: e\n        },\n        attributes: {},\n        styles: {}\n      },\n          l = [],\n          c = !1,\n          u = {\n        state: a,\n        setOptions: function setOptions(n) {\n          f(), a.options = Object.assign(Object.assign(Object.assign({}, r), a.options), n), a.scrollParents = {\n            reference: ht(t) ? Ut(t) : t.contextElement ? Ut(t.contextElement) : [],\n            popper: Ut(e)\n          };\n\n          var o,\n              s,\n              c = function (t) {\n            var e = re(t);\n            return ut.reduce(function (t, n) {\n              return t.concat(e.filter(function (t) {\n                return t.phase === n;\n              }));\n            }, []);\n          }((o = [].concat(i, a.options.modifiers), s = o.reduce(function (t, e) {\n            var n = t[e.name];\n            return t[e.name] = n ? Object.assign(Object.assign(Object.assign({}, n), e), {}, {\n              options: Object.assign(Object.assign({}, n.options), e.options),\n              data: Object.assign(Object.assign({}, n.data), e.data)\n            }) : e, t;\n          }, {}), Object.keys(s).map(function (t) {\n            return s[t];\n          })));\n\n          return a.orderedModifiers = c.filter(function (t) {\n            return t.enabled;\n          }), a.orderedModifiers.forEach(function (t) {\n            var e = t.name,\n                n = t.options,\n                i = void 0 === n ? {} : n,\n                o = t.effect;\n\n            if (\"function\" == typeof o) {\n              var r = o({\n                state: a,\n                name: e,\n                instance: u,\n                options: i\n              }),\n                  s = function s() {};\n\n              l.push(r || s);\n            }\n          }), u.update();\n        },\n        forceUpdate: function forceUpdate() {\n          if (!c) {\n            var t = a.elements,\n                e = t.reference,\n                n = t.popper;\n\n            if (ae(e, n)) {\n              a.rects = {\n                reference: oe(e, kt(n), \"fixed\" === a.options.strategy),\n                popper: vt(n)\n              }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (t) {\n                return a.modifiersData[t.name] = Object.assign({}, t.data);\n              });\n\n              for (var i = 0; i < a.orderedModifiers.length; i++) {\n                if (!0 !== a.reset) {\n                  var o = a.orderedModifiers[i],\n                      r = o.fn,\n                      s = o.options,\n                      l = void 0 === s ? {} : s,\n                      f = o.name;\n                  \"function\" == typeof r && (a = r({\n                    state: a,\n                    options: l,\n                    name: f,\n                    instance: u\n                  }) || a);\n                } else a.reset = !1, i = -1;\n              }\n            }\n          }\n        },\n        update: (o = function o() {\n          return new Promise(function (t) {\n            u.forceUpdate(), t(a);\n          });\n        }, function () {\n          return s || (s = new Promise(function (t) {\n            Promise.resolve().then(function () {\n              s = void 0, t(o());\n            });\n          })), s;\n        }),\n        destroy: function destroy() {\n          f(), c = !0;\n        }\n      };\n      if (!ae(t, e)) return u;\n\n      function f() {\n        l.forEach(function (t) {\n          return t();\n        }), l = [];\n      }\n\n      return u.setOptions(n).then(function (t) {\n        !c && n.onFirstUpdate && n.onFirstUpdate(t);\n      }), u;\n    };\n  }\n\n  var ce = le(),\n      ue = le({\n    defaultModifiers: [It, ne, jt, gt]\n  }),\n      fe = le({\n    defaultModifiers: [It, ne, jt, gt, ee, Gt, ie, Dt, te]\n  }),\n      de = Object.freeze({\n    __proto__: null,\n    popperGenerator: le,\n    detectOverflow: Xt,\n    createPopperBase: ce,\n    createPopper: fe,\n    createPopperLite: ue,\n    top: it,\n    bottom: ot,\n    right: rt,\n    left: st,\n    auto: \"auto\",\n    basePlacements: at,\n    start: \"start\",\n    end: \"end\",\n    clippingParents: \"clippingParents\",\n    viewport: \"viewport\",\n    popper: \"popper\",\n    reference: \"reference\",\n    variationPlacements: lt,\n    placements: ct,\n    beforeRead: \"beforeRead\",\n    read: \"read\",\n    afterRead: \"afterRead\",\n    beforeMain: \"beforeMain\",\n    main: \"main\",\n    afterMain: \"afterMain\",\n    beforeWrite: \"beforeWrite\",\n    write: \"write\",\n    afterWrite: \"afterWrite\",\n    modifierPhases: ut,\n    applyStyles: gt,\n    arrow: Dt,\n    computeStyles: jt,\n    eventListeners: It,\n    flip: Gt,\n    hide: te,\n    offset: ee,\n    popperOffsets: ne,\n    preventOverflow: ie\n  }),\n      he = \"dropdown\",\n      pe = new RegExp(\"ArrowUp|ArrowDown|Escape\"),\n      ge = y ? \"top-end\" : \"top-start\",\n      me = y ? \"top-start\" : \"top-end\",\n      ve = y ? \"bottom-end\" : \"bottom-start\",\n      _e = y ? \"bottom-start\" : \"bottom-end\",\n      be = y ? \"left-start\" : \"right-start\",\n      ye = y ? \"right-start\" : \"left-start\",\n      we = {\n    offset: 0,\n    flip: !0,\n    boundary: \"clippingParents\",\n    reference: \"toggle\",\n    display: \"dynamic\",\n    popperConfig: null\n  },\n      Ee = {\n    offset: \"(number|string|function)\",\n    flip: \"boolean\",\n    boundary: \"(string|element)\",\n    reference: \"(string|element)\",\n    display: \"string\",\n    popperConfig: \"(null|object)\"\n  },\n      Te = function (t) {\n    function o(e, n) {\n      var i;\n      return (i = t.call(this, e) || this)._popper = null, i._config = i._getConfig(n), i._menu = i._getMenuElement(), i._inNavbar = i._detectNavbar(), i._addEventListeners(), i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.toggle = function () {\n      if (!this._element.disabled && !this._element.classList.contains(\"disabled\")) {\n        var t = this._element.classList.contains(\"show\");\n\n        o.clearMenus(), t || this.show();\n      }\n    }, r.show = function () {\n      if (!(this._element.disabled || this._element.classList.contains(\"disabled\") || this._menu.classList.contains(\"show\"))) {\n        var t = o.getParentFromElement(this._element),\n            e = {\n          relatedTarget: this._element\n        };\n\n        if (!H.trigger(this._element, \"show.bs.dropdown\", e).defaultPrevented) {\n          if (!this._inNavbar) {\n            if (void 0 === de) throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n            var n = this._element;\n            \"parent\" === this._config.reference ? n = t : d(this._config.reference) && (n = this._config.reference, void 0 !== this._config.reference.jquery && (n = this._config.reference[0])), this._popper = fe(n, this._menu, this._getPopperConfig());\n          }\n\n          var i;\n          if (\"ontouchstart\" in document.documentElement && !t.closest(\".navbar-nav\")) (i = []).concat.apply(i, document.body.children).forEach(function (t) {\n            return H.on(t, \"mouseover\", null, function () {});\n          });\n          this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.classList.toggle(\"show\"), this._element.classList.toggle(\"show\"), H.trigger(t, \"shown.bs.dropdown\", e);\n        }\n      }\n    }, r.hide = function () {\n      if (!this._element.disabled && !this._element.classList.contains(\"disabled\") && this._menu.classList.contains(\"show\")) {\n        var t = o.getParentFromElement(this._element),\n            e = {\n          relatedTarget: this._element\n        };\n        H.trigger(t, \"hide.bs.dropdown\", e).defaultPrevented || (this._popper && this._popper.destroy(), this._menu.classList.toggle(\"show\"), this._element.classList.toggle(\"show\"), H.trigger(t, \"hidden.bs.dropdown\", e));\n      }\n    }, r.dispose = function () {\n      t.prototype.dispose.call(this), H.off(this._element, \".bs.dropdown\"), this._menu = null, this._popper && (this._popper.destroy(), this._popper = null);\n    }, r.update = function () {\n      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n    }, r._addEventListeners = function () {\n      var t = this;\n      H.on(this._element, \"click.bs.dropdown\", function (e) {\n        e.preventDefault(), e.stopPropagation(), t.toggle();\n      });\n    }, r._getConfig = function (t) {\n      return t = n({}, this.constructor.Default, Y.getDataAttributes(this._element), t), p(he, t, this.constructor.DefaultType), t;\n    }, r._getMenuElement = function () {\n      return q.next(this._element, \".dropdown-menu\")[0];\n    }, r._getPlacement = function () {\n      var t = this._element.parentNode;\n      if (t.classList.contains(\"dropend\")) return be;\n      if (t.classList.contains(\"dropstart\")) return ye;\n      var e = \"end\" === getComputedStyle(this._menu).getPropertyValue(\"--bs-position\").trim();\n      return t.classList.contains(\"dropup\") ? e ? me : ge : e ? _e : ve;\n    }, r._detectNavbar = function () {\n      return null !== this._element.closest(\".navbar\");\n    }, r._getPopperConfig = function () {\n      var t = {\n        placement: this._getPlacement(),\n        modifiers: [{\n          name: \"preventOverflow\",\n          options: {\n            altBoundary: this._config.flip,\n            rootBoundary: this._config.boundary\n          }\n        }]\n      };\n      return \"static\" === this._config.display && (t.modifiers = [{\n        name: \"applyStyles\",\n        enabled: !1\n      }]), n({}, t, this._config.popperConfig);\n    }, o.dropdownInterface = function (t, e) {\n      var n = T(t, \"bs.dropdown\");\n\n      if (n || (n = new o(t, \"object\" == _typeof(e) ? e : null)), \"string\" == typeof e) {\n        if (void 0 === n[e]) throw new TypeError('No method named \"' + e + '\"');\n        n[e]();\n      }\n    }, o.jQueryInterface = function (t) {\n      return this.each(function () {\n        o.dropdownInterface(this, t);\n      });\n    }, o.clearMenus = function (t) {\n      if (!t || 2 !== t.button && (\"keyup\" !== t.type || \"Tab\" === t.key)) for (var e = q.find('[data-bs-toggle=\"dropdown\"]'), n = 0, i = e.length; n < i; n++) {\n        var r = o.getParentFromElement(e[n]),\n            s = T(e[n], \"bs.dropdown\"),\n            a = {\n          relatedTarget: e[n]\n        };\n\n        if (t && \"click\" === t.type && (a.clickEvent = t), s) {\n          var l = s._menu;\n          if (e[n].classList.contains(\"show\")) if (!(t && (\"click\" === t.type && /input|textarea/i.test(t.target.tagName) || \"keyup\" === t.type && \"Tab\" === t.key) && l.contains(t.target))) if (!H.trigger(r, \"hide.bs.dropdown\", a).defaultPrevented) {\n            var c;\n            if (\"ontouchstart\" in document.documentElement) (c = []).concat.apply(c, document.body.children).forEach(function (t) {\n              return H.off(t, \"mouseover\", null, function () {});\n            });\n            e[n].setAttribute(\"aria-expanded\", \"false\"), s._popper && s._popper.destroy(), l.classList.remove(\"show\"), e[n].classList.remove(\"show\"), H.trigger(r, \"hidden.bs.dropdown\", a);\n          }\n        }\n      }\n    }, o.getParentFromElement = function (t) {\n      return c(t) || t.parentNode;\n    }, o.dataApiKeydownHandler = function (t) {\n      if (!(/input|textarea/i.test(t.target.tagName) ? \"Space\" === t.key || \"Escape\" !== t.key && (\"ArrowDown\" !== t.key && \"ArrowUp\" !== t.key || t.target.closest(\".dropdown-menu\")) : !pe.test(t.key)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !this.classList.contains(\"disabled\"))) {\n        var e = o.getParentFromElement(this),\n            n = this.classList.contains(\"show\");\n        if (\"Escape\" === t.key) return (this.matches('[data-bs-toggle=\"dropdown\"]') ? this : q.prev(this, '[data-bs-toggle=\"dropdown\"]')[0]).focus(), void o.clearMenus();\n\n        if (n && \"Space\" !== t.key) {\n          var i = q.find(\".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\", e).filter(g);\n\n          if (i.length) {\n            var r = i.indexOf(t.target);\n            \"ArrowUp\" === t.key && r > 0 && r--, \"ArrowDown\" === t.key && r < i.length - 1 && r++, i[r = -1 === r ? 0 : r].focus();\n          }\n        } else o.clearMenus();\n      }\n    }, e(o, null, [{\n      key: \"Default\",\n      get: function get() {\n        return we;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return Ee;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.dropdown\";\n      }\n    }]), o;\n  }(R);\n\n  H.on(document, \"keydown.bs.dropdown.data-api\", '[data-bs-toggle=\"dropdown\"]', Te.dataApiKeydownHandler), H.on(document, \"keydown.bs.dropdown.data-api\", \".dropdown-menu\", Te.dataApiKeydownHandler), H.on(document, \"click.bs.dropdown.data-api\", Te.clearMenus), H.on(document, \"keyup.bs.dropdown.data-api\", Te.clearMenus), H.on(document, \"click.bs.dropdown.data-api\", '[data-bs-toggle=\"dropdown\"]', function (t) {\n    t.preventDefault(), t.stopPropagation(), Te.dropdownInterface(this, \"toggle\");\n  }), H.on(document, \"click.bs.dropdown.data-api\", \".dropdown form\", function (t) {\n    return t.stopPropagation();\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[he];\n      t.fn[he] = Te.jQueryInterface, t.fn[he].Constructor = Te, t.fn[he].noConflict = function () {\n        return t.fn[he] = e, Te.jQueryInterface;\n      };\n    }\n  });\n\n  var ke = {\n    backdrop: !0,\n    keyboard: !0,\n    focus: !0\n  },\n      Oe = {\n    backdrop: \"(boolean|string)\",\n    keyboard: \"boolean\",\n    focus: \"boolean\"\n  },\n      Le = function (t) {\n    function o(e, n) {\n      var i;\n      return (i = t.call(this, e) || this)._config = i._getConfig(n), i._dialog = q.findOne(\".modal-dialog\", e), i._backdrop = null, i._isShown = !1, i._isBodyOverflowing = !1, i._ignoreBackdropClick = !1, i._isTransitioning = !1, i._scrollbarWidth = 0, i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.toggle = function (t) {\n      return this._isShown ? this.hide() : this.show(t);\n    }, r.show = function (t) {\n      var e = this;\n\n      if (!this._isShown && !this._isTransitioning) {\n        this._element.classList.contains(\"fade\") && (this._isTransitioning = !0);\n        var n = H.trigger(this._element, \"show.bs.modal\", {\n          relatedTarget: t\n        });\n        this._isShown || n.defaultPrevented || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), H.on(this._element, \"click.dismiss.bs.modal\", '[data-bs-dismiss=\"modal\"]', function (t) {\n          return e.hide(t);\n        }), H.on(this._dialog, \"mousedown.dismiss.bs.modal\", function () {\n          H.one(e._element, \"mouseup.dismiss.bs.modal\", function (t) {\n            t.target === e._element && (e._ignoreBackdropClick = !0);\n          });\n        }), this._showBackdrop(function () {\n          return e._showElement(t);\n        }));\n      }\n    }, r.hide = function (t) {\n      var e = this;\n\n      if ((t && t.preventDefault(), this._isShown && !this._isTransitioning) && !H.trigger(this._element, \"hide.bs.modal\").defaultPrevented) {\n        this._isShown = !1;\n\n        var n = this._element.classList.contains(\"fade\");\n\n        if (n && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), H.off(document, \"focusin.bs.modal\"), this._element.classList.remove(\"show\"), H.off(this._element, \"click.dismiss.bs.modal\"), H.off(this._dialog, \"mousedown.dismiss.bs.modal\"), n) {\n          var i = u(this._element);\n          H.one(this._element, \"transitionend\", function (t) {\n            return e._hideModal(t);\n          }), h(this._element, i);\n        } else this._hideModal();\n      }\n    }, r.dispose = function () {\n      [window, this._element, this._dialog].forEach(function (t) {\n        return H.off(t, \".bs.modal\");\n      }), t.prototype.dispose.call(this), H.off(document, \"focusin.bs.modal\"), this._config = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null;\n    }, r.handleUpdate = function () {\n      this._adjustDialog();\n    }, r._getConfig = function (t) {\n      return t = n({}, ke, t), p(\"modal\", t, Oe), t;\n    }, r._showElement = function (t) {\n      var e = this,\n          n = this._element.classList.contains(\"fade\"),\n          i = q.findOne(\".modal-body\", this._dialog);\n\n      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = \"block\", this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.scrollTop = 0, i && (i.scrollTop = 0), n && v(this._element), this._element.classList.add(\"show\"), this._config.focus && this._enforceFocus();\n\n      var o = function o() {\n        e._config.focus && e._element.focus(), e._isTransitioning = !1, H.trigger(e._element, \"shown.bs.modal\", {\n          relatedTarget: t\n        });\n      };\n\n      if (n) {\n        var r = u(this._dialog);\n        H.one(this._dialog, \"transitionend\", o), h(this._dialog, r);\n      } else o();\n    }, r._enforceFocus = function () {\n      var t = this;\n      H.off(document, \"focusin.bs.modal\"), H.on(document, \"focusin.bs.modal\", function (e) {\n        document === e.target || t._element === e.target || t._element.contains(e.target) || t._element.focus();\n      });\n    }, r._setEscapeEvent = function () {\n      var t = this;\n      this._isShown ? H.on(this._element, \"keydown.dismiss.bs.modal\", function (e) {\n        t._config.keyboard && \"Escape\" === e.key ? (e.preventDefault(), t.hide()) : t._config.keyboard || \"Escape\" !== e.key || t._triggerBackdropTransition();\n      }) : H.off(this._element, \"keydown.dismiss.bs.modal\");\n    }, r._setResizeEvent = function () {\n      var t = this;\n      this._isShown ? H.on(window, \"resize.bs.modal\", function () {\n        return t._adjustDialog();\n      }) : H.off(window, \"resize.bs.modal\");\n    }, r._hideModal = function () {\n      var t = this;\n      this._element.style.display = \"none\", this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._showBackdrop(function () {\n        document.body.classList.remove(\"modal-open\"), t._resetAdjustments(), t._resetScrollbar(), H.trigger(t._element, \"hidden.bs.modal\");\n      });\n    }, r._removeBackdrop = function () {\n      this._backdrop.parentNode.removeChild(this._backdrop), this._backdrop = null;\n    }, r._showBackdrop = function (t) {\n      var e = this,\n          n = this._element.classList.contains(\"fade\") ? \"fade\" : \"\";\n\n      if (this._isShown && this._config.backdrop) {\n        if (this._backdrop = document.createElement(\"div\"), this._backdrop.className = \"modal-backdrop\", n && this._backdrop.classList.add(n), document.body.appendChild(this._backdrop), H.on(this._element, \"click.dismiss.bs.modal\", function (t) {\n          e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && (\"static\" === e._config.backdrop ? e._triggerBackdropTransition() : e.hide());\n        }), n && v(this._backdrop), this._backdrop.classList.add(\"show\"), !n) return void t();\n        var i = u(this._backdrop);\n        H.one(this._backdrop, \"transitionend\", t), h(this._backdrop, i);\n      } else if (!this._isShown && this._backdrop) {\n        this._backdrop.classList.remove(\"show\");\n\n        var o = function o() {\n          e._removeBackdrop(), t();\n        };\n\n        if (this._element.classList.contains(\"fade\")) {\n          var r = u(this._backdrop);\n          H.one(this._backdrop, \"transitionend\", o), h(this._backdrop, r);\n        } else o();\n      } else t();\n    }, r._triggerBackdropTransition = function () {\n      var t = this;\n\n      if (!H.trigger(this._element, \"hidePrevented.bs.modal\").defaultPrevented) {\n        var e = this._element.scrollHeight > document.documentElement.clientHeight;\n        e || (this._element.style.overflowY = \"hidden\"), this._element.classList.add(\"modal-static\");\n        var n = u(this._dialog);\n        H.off(this._element, \"transitionend\"), H.one(this._element, \"transitionend\", function () {\n          t._element.classList.remove(\"modal-static\"), e || (H.one(t._element, \"transitionend\", function () {\n            t._element.style.overflowY = \"\";\n          }), h(t._element, n));\n        }), h(this._element, n), this._element.focus();\n      }\n    }, r._adjustDialog = function () {\n      var t = this._element.scrollHeight > document.documentElement.clientHeight;\n      (!this._isBodyOverflowing && t && !y || this._isBodyOverflowing && !t && y) && (this._element.style.paddingLeft = this._scrollbarWidth + \"px\"), (this._isBodyOverflowing && !t && !y || !this._isBodyOverflowing && t && y) && (this._element.style.paddingRight = this._scrollbarWidth + \"px\");\n    }, r._resetAdjustments = function () {\n      this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n    }, r._checkScrollbar = function () {\n      var t = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = Math.round(t.left + t.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth();\n    }, r._setScrollbar = function () {\n      var t = this;\n\n      if (this._isBodyOverflowing) {\n        q.find(\".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\").forEach(function (e) {\n          var n = e.style.paddingRight,\n              i = window.getComputedStyle(e)[\"padding-right\"];\n          Y.setDataAttribute(e, \"padding-right\", n), e.style.paddingRight = Number.parseFloat(i) + t._scrollbarWidth + \"px\";\n        }), q.find(\".sticky-top\").forEach(function (e) {\n          var n = e.style.marginRight,\n              i = window.getComputedStyle(e)[\"margin-right\"];\n          Y.setDataAttribute(e, \"margin-right\", n), e.style.marginRight = Number.parseFloat(i) - t._scrollbarWidth + \"px\";\n        });\n        var e = document.body.style.paddingRight,\n            n = window.getComputedStyle(document.body)[\"padding-right\"];\n        Y.setDataAttribute(document.body, \"padding-right\", e), document.body.style.paddingRight = Number.parseFloat(n) + this._scrollbarWidth + \"px\";\n      }\n\n      document.body.classList.add(\"modal-open\");\n    }, r._resetScrollbar = function () {\n      q.find(\".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\").forEach(function (t) {\n        var e = Y.getDataAttribute(t, \"padding-right\");\n        void 0 !== e && (Y.removeDataAttribute(t, \"padding-right\"), t.style.paddingRight = e);\n      }), q.find(\".sticky-top\").forEach(function (t) {\n        var e = Y.getDataAttribute(t, \"margin-right\");\n        void 0 !== e && (Y.removeDataAttribute(t, \"margin-right\"), t.style.marginRight = e);\n      });\n      var t = Y.getDataAttribute(document.body, \"padding-right\");\n      void 0 === t ? document.body.style.paddingRight = \"\" : (Y.removeDataAttribute(document.body, \"padding-right\"), document.body.style.paddingRight = t);\n    }, r._getScrollbarWidth = function () {\n      var t = document.createElement(\"div\");\n      t.className = \"modal-scrollbar-measure\", document.body.appendChild(t);\n      var e = t.getBoundingClientRect().width - t.clientWidth;\n      return document.body.removeChild(t), e;\n    }, o.jQueryInterface = function (t, e) {\n      return this.each(function () {\n        var i = T(this, \"bs.modal\"),\n            r = n({}, ke, Y.getDataAttributes(this), \"object\" == _typeof(t) && t ? t : {});\n\n        if (i || (i = new o(this, r)), \"string\" == typeof t) {\n          if (void 0 === i[t]) throw new TypeError('No method named \"' + t + '\"');\n          i[t](e);\n        }\n      });\n    }, e(o, null, [{\n      key: \"Default\",\n      get: function get() {\n        return ke;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.modal\";\n      }\n    }]), o;\n  }(R);\n\n  H.on(document, \"click.bs.modal.data-api\", '[data-bs-toggle=\"modal\"]', function (t) {\n    var e = this,\n        i = c(this);\n    \"A\" !== this.tagName && \"AREA\" !== this.tagName || t.preventDefault(), H.one(i, \"show.bs.modal\", function (t) {\n      t.defaultPrevented || H.one(i, \"hidden.bs.modal\", function () {\n        g(e) && e.focus();\n      });\n    });\n    var o = T(i, \"bs.modal\");\n\n    if (!o) {\n      var r = n({}, Y.getDataAttributes(i), Y.getDataAttributes(this));\n      o = new Le(i, r);\n    }\n\n    o.show(this);\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn.modal;\n      t.fn.modal = Le.jQueryInterface, t.fn.modal.Constructor = Le, t.fn.modal.noConflict = function () {\n        return t.fn.modal = e, Le.jQueryInterface;\n      };\n    }\n  });\n  var Ae = new Set([\"background\", \"cite\", \"href\", \"itemtype\", \"longdesc\", \"poster\", \"src\", \"xlink:href\"]),\n      Ce = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,\n      De = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,\n      xe = {\n    \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", /^aria-[\\w-]*$/i],\n    a: [\"target\", \"href\", \"title\", \"rel\"],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n\n  function Se(t, e, n) {\n    var i;\n    if (!t.length) return t;\n    if (n && \"function\" == typeof n) return n(t);\n\n    for (var o = new window.DOMParser().parseFromString(t, \"text/html\"), r = Object.keys(e), s = (i = []).concat.apply(i, o.body.querySelectorAll(\"*\")), a = function a(t, n) {\n      var i,\n          o = s[t],\n          a = o.nodeName.toLowerCase();\n      if (!r.includes(a)) return o.parentNode.removeChild(o), \"continue\";\n      var l = (i = []).concat.apply(i, o.attributes),\n          c = [].concat(e[\"*\"] || [], e[a] || []);\n      l.forEach(function (t) {\n        (function (t, e) {\n          var n = t.nodeName.toLowerCase();\n          if (e.includes(n)) return !Ae.has(n) || Boolean(t.nodeValue.match(Ce) || t.nodeValue.match(De));\n\n          for (var i = e.filter(function (t) {\n            return t instanceof RegExp;\n          }), o = 0, r = i.length; o < r; o++) {\n            if (n.match(i[o])) return !0;\n          }\n\n          return !1;\n        })(t, c) || o.removeAttribute(t.nodeName);\n      });\n    }, l = 0, c = s.length; l < c; l++) {\n      a(l);\n    }\n\n    return o.body.innerHTML;\n  }\n\n  var je = \"tooltip\",\n      Ne = new RegExp(\"(^|\\\\s)bs-tooltip\\\\S+\", \"g\"),\n      Ie = new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]),\n      Pe = {\n    animation: \"boolean\",\n    template: \"string\",\n    title: \"(string|element|function)\",\n    trigger: \"string\",\n    delay: \"(number|object)\",\n    html: \"boolean\",\n    selector: \"(string|boolean)\",\n    placement: \"(string|function)\",\n    container: \"(string|element|boolean)\",\n    fallbackPlacements: \"(null|array)\",\n    boundary: \"(string|element)\",\n    customClass: \"(string|function)\",\n    sanitize: \"boolean\",\n    sanitizeFn: \"(null|function)\",\n    allowList: \"object\",\n    popperConfig: \"(null|object)\"\n  },\n      Me = {\n    AUTO: \"auto\",\n    TOP: \"top\",\n    RIGHT: y ? \"left\" : \"right\",\n    BOTTOM: \"bottom\",\n    LEFT: y ? \"right\" : \"left\"\n  },\n      Be = {\n    animation: !0,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: \"hover focus\",\n    title: \"\",\n    delay: 0,\n    html: !1,\n    selector: !1,\n    placement: \"top\",\n    container: !1,\n    fallbackPlacements: null,\n    boundary: \"clippingParents\",\n    customClass: \"\",\n    sanitize: !0,\n    sanitizeFn: null,\n    allowList: xe,\n    popperConfig: null\n  },\n      He = {\n    HIDE: \"hide.bs.tooltip\",\n    HIDDEN: \"hidden.bs.tooltip\",\n    SHOW: \"show.bs.tooltip\",\n    SHOWN: \"shown.bs.tooltip\",\n    INSERTED: \"inserted.bs.tooltip\",\n    CLICK: \"click.bs.tooltip\",\n    FOCUSIN: \"focusin.bs.tooltip\",\n    FOCUSOUT: \"focusout.bs.tooltip\",\n    MOUSEENTER: \"mouseenter.bs.tooltip\",\n    MOUSELEAVE: \"mouseleave.bs.tooltip\"\n  },\n      Re = function (t) {\n    function o(e, n) {\n      var i;\n      if (void 0 === de) throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n      return (i = t.call(this, e) || this)._isEnabled = !0, i._timeout = 0, i._hoverState = \"\", i._activeTrigger = {}, i._popper = null, i.config = i._getConfig(n), i.tip = null, i._setListeners(), i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.enable = function () {\n      this._isEnabled = !0;\n    }, r.disable = function () {\n      this._isEnabled = !1;\n    }, r.toggleEnabled = function () {\n      this._isEnabled = !this._isEnabled;\n    }, r.toggle = function (t) {\n      if (this._isEnabled) if (t) {\n        var e = this.constructor.DATA_KEY,\n            n = T(t.delegateTarget, e);\n        n || (n = new this.constructor(t.delegateTarget, this._getDelegateConfig()), E(t.delegateTarget, e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n);\n      } else {\n        if (this.getTipElement().classList.contains(\"show\")) return void this._leave(null, this);\n\n        this._enter(null, this);\n      }\n    }, r.dispose = function () {\n      clearTimeout(this._timeout), H.off(this._element, this.constructor.EVENT_KEY), H.off(this._element.closest(\".modal\"), \"hide.bs.modal\", this._hideModalHandler), this.tip && this.tip.parentNode.removeChild(this.tip), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.config = null, this.tip = null, t.prototype.dispose.call(this);\n    }, r.show = function () {\n      var t = this;\n      if (\"none\" === this._element.style.display) throw new Error(\"Please use show on visible elements\");\n\n      if (this.isWithContent() && this._isEnabled) {\n        var e = H.trigger(this._element, this.constructor.Event.SHOW),\n            n = function t(e) {\n          if (!document.documentElement.attachShadow) return null;\n\n          if (\"function\" == typeof e.getRootNode) {\n            var n = e.getRootNode();\n            return n instanceof ShadowRoot ? n : null;\n          }\n\n          return e instanceof ShadowRoot ? e : e.parentNode ? t(e.parentNode) : null;\n        }(this._element),\n            i = null === n ? this._element.ownerDocument.documentElement.contains(this._element) : n.contains(this._element);\n\n        if (e.defaultPrevented || !i) return;\n        var o = this.getTipElement(),\n            r = s(this.constructor.NAME);\n        o.setAttribute(\"id\", r), this._element.setAttribute(\"aria-describedby\", r), this.setContent(), this.config.animation && o.classList.add(\"fade\");\n\n        var a = \"function\" == typeof this.config.placement ? this.config.placement.call(this, o, this._element) : this.config.placement,\n            l = this._getAttachment(a);\n\n        this._addAttachmentClass(l);\n\n        var c = this._getContainer();\n\n        E(o, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || c.appendChild(o), H.trigger(this._element, this.constructor.Event.INSERTED), this._popper = fe(this._element, o, this._getPopperConfig(l)), o.classList.add(\"show\");\n        var f,\n            d,\n            p = \"function\" == typeof this.config.customClass ? this.config.customClass() : this.config.customClass;\n        if (p) (f = o.classList).add.apply(f, p.split(\" \"));\n        if (\"ontouchstart\" in document.documentElement) (d = []).concat.apply(d, document.body.children).forEach(function (t) {\n          H.on(t, \"mouseover\", function () {});\n        });\n\n        var g = function g() {\n          var e = t._hoverState;\n          t._hoverState = null, H.trigger(t._element, t.constructor.Event.SHOWN), \"out\" === e && t._leave(null, t);\n        };\n\n        if (this.tip.classList.contains(\"fade\")) {\n          var m = u(this.tip);\n          H.one(this.tip, \"transitionend\", g), h(this.tip, m);\n        } else g();\n      }\n    }, r.hide = function () {\n      var t = this;\n\n      if (this._popper) {\n        var e = this.getTipElement(),\n            n = function n() {\n          \"show\" !== t._hoverState && e.parentNode && e.parentNode.removeChild(e), t._cleanTipClass(), t._element.removeAttribute(\"aria-describedby\"), H.trigger(t._element, t.constructor.Event.HIDDEN), t._popper && (t._popper.destroy(), t._popper = null);\n        };\n\n        if (!H.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) {\n          var i;\n          if (e.classList.remove(\"show\"), \"ontouchstart\" in document.documentElement) (i = []).concat.apply(i, document.body.children).forEach(function (t) {\n            return H.off(t, \"mouseover\", m);\n          });\n\n          if (this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this.tip.classList.contains(\"fade\")) {\n            var o = u(e);\n            H.one(e, \"transitionend\", n), h(e, o);\n          } else n();\n\n          this._hoverState = \"\";\n        }\n      }\n    }, r.update = function () {\n      null !== this._popper && this._popper.update();\n    }, r.isWithContent = function () {\n      return Boolean(this.getTitle());\n    }, r.getTipElement = function () {\n      if (this.tip) return this.tip;\n      var t = document.createElement(\"div\");\n      return t.innerHTML = this.config.template, this.tip = t.children[0], this.tip;\n    }, r.setContent = function () {\n      var t = this.getTipElement();\n      this.setElementContent(q.findOne(\".tooltip-inner\", t), this.getTitle()), t.classList.remove(\"fade\", \"show\");\n    }, r.setElementContent = function (t, e) {\n      if (null !== t) return \"object\" == _typeof(e) && d(e) ? (e.jquery && (e = e[0]), void (this.config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.appendChild(e)) : t.textContent = e.textContent)) : void (this.config.html ? (this.config.sanitize && (e = Se(e, this.config.allowList, this.config.sanitizeFn)), t.innerHTML = e) : t.textContent = e);\n    }, r.getTitle = function () {\n      var t = this._element.getAttribute(\"data-bs-original-title\");\n\n      return t || (t = \"function\" == typeof this.config.title ? this.config.title.call(this._element) : this.config.title), t;\n    }, r.updateAttachment = function (t) {\n      return \"right\" === t ? \"end\" : \"left\" === t ? \"start\" : t;\n    }, r._getPopperConfig = function (t) {\n      var e = this,\n          i = {\n        name: \"flip\",\n        options: {\n          altBoundary: !0\n        }\n      };\n      return this.config.fallbackPlacements && (i.options.fallbackPlacements = this.config.fallbackPlacements), n({}, {\n        placement: t,\n        modifiers: [i, {\n          name: \"preventOverflow\",\n          options: {\n            rootBoundary: this.config.boundary\n          }\n        }, {\n          name: \"arrow\",\n          options: {\n            element: \".\" + this.constructor.NAME + \"-arrow\"\n          }\n        }, {\n          name: \"onChange\",\n          enabled: !0,\n          phase: \"afterWrite\",\n          fn: function fn(t) {\n            return e._handlePopperPlacementChange(t);\n          }\n        }],\n        onFirstUpdate: function onFirstUpdate(t) {\n          t.options.placement !== t.placement && e._handlePopperPlacementChange(t);\n        }\n      }, this.config.popperConfig);\n    }, r._addAttachmentClass = function (t) {\n      this.getTipElement().classList.add(\"bs-tooltip-\" + this.updateAttachment(t));\n    }, r._getContainer = function () {\n      return !1 === this.config.container ? document.body : d(this.config.container) ? this.config.container : q.findOne(this.config.container);\n    }, r._getAttachment = function (t) {\n      return Me[t.toUpperCase()];\n    }, r._setListeners = function () {\n      var t = this;\n      this.config.trigger.split(\" \").forEach(function (e) {\n        if (\"click\" === e) H.on(t._element, t.constructor.Event.CLICK, t.config.selector, function (e) {\n          return t.toggle(e);\n        });else if (\"manual\" !== e) {\n          var n = \"hover\" === e ? t.constructor.Event.MOUSEENTER : t.constructor.Event.FOCUSIN,\n              i = \"hover\" === e ? t.constructor.Event.MOUSELEAVE : t.constructor.Event.FOCUSOUT;\n          H.on(t._element, n, t.config.selector, function (e) {\n            return t._enter(e);\n          }), H.on(t._element, i, t.config.selector, function (e) {\n            return t._leave(e);\n          });\n        }\n      }), this._hideModalHandler = function () {\n        t._element && t.hide();\n      }, H.on(this._element.closest(\".modal\"), \"hide.bs.modal\", this._hideModalHandler), this.config.selector ? this.config = n({}, this.config, {\n        trigger: \"manual\",\n        selector: \"\"\n      }) : this._fixTitle();\n    }, r._fixTitle = function () {\n      var t = this._element.getAttribute(\"title\"),\n          e = _typeof(this._element.getAttribute(\"data-bs-original-title\"));\n\n      (t || \"string\" !== e) && (this._element.setAttribute(\"data-bs-original-title\", t || \"\"), !t || this._element.getAttribute(\"aria-label\") || this._element.textContent || this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\n    }, r._enter = function (t, e) {\n      var n = this.constructor.DATA_KEY;\n      (e = e || T(t.delegateTarget, n)) || (e = new this.constructor(t.delegateTarget, this._getDelegateConfig()), E(t.delegateTarget, n, e)), t && (e._activeTrigger[\"focusin\" === t.type ? \"focus\" : \"hover\"] = !0), e.getTipElement().classList.contains(\"show\") || \"show\" === e._hoverState ? e._hoverState = \"show\" : (clearTimeout(e._timeout), e._hoverState = \"show\", e.config.delay && e.config.delay.show ? e._timeout = setTimeout(function () {\n        \"show\" === e._hoverState && e.show();\n      }, e.config.delay.show) : e.show());\n    }, r._leave = function (t, e) {\n      var n = this.constructor.DATA_KEY;\n      (e = e || T(t.delegateTarget, n)) || (e = new this.constructor(t.delegateTarget, this._getDelegateConfig()), E(t.delegateTarget, n, e)), t && (e._activeTrigger[\"focusout\" === t.type ? \"focus\" : \"hover\"] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = \"out\", e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(function () {\n        \"out\" === e._hoverState && e.hide();\n      }, e.config.delay.hide) : e.hide());\n    }, r._isWithActiveTrigger = function () {\n      for (var t in this._activeTrigger) {\n        if (this._activeTrigger[t]) return !0;\n      }\n\n      return !1;\n    }, r._getConfig = function (t) {\n      var e = Y.getDataAttributes(this._element);\n      return Object.keys(e).forEach(function (t) {\n        Ie.has(t) && delete e[t];\n      }), t && \"object\" == _typeof(t.container) && t.container.jquery && (t.container = t.container[0]), \"number\" == typeof (t = n({}, this.constructor.Default, e, \"object\" == _typeof(t) && t ? t : {})).delay && (t.delay = {\n        show: t.delay,\n        hide: t.delay\n      }), \"number\" == typeof t.title && (t.title = t.title.toString()), \"number\" == typeof t.content && (t.content = t.content.toString()), p(je, t, this.constructor.DefaultType), t.sanitize && (t.template = Se(t.template, t.allowList, t.sanitizeFn)), t;\n    }, r._getDelegateConfig = function () {\n      var t = {};\n      if (this.config) for (var e in this.config) {\n        this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);\n      }\n      return t;\n    }, r._cleanTipClass = function () {\n      var t = this.getTipElement(),\n          e = t.getAttribute(\"class\").match(Ne);\n      null !== e && e.length > 0 && e.map(function (t) {\n        return t.trim();\n      }).forEach(function (e) {\n        return t.classList.remove(e);\n      });\n    }, r._handlePopperPlacementChange = function (t) {\n      var e = t.state;\n      e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n    }, o.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.tooltip\"),\n            n = \"object\" == _typeof(t) && t;\n\n        if ((e || !/dispose|hide/.test(t)) && (e || (e = new o(this, n)), \"string\" == typeof t)) {\n          if (void 0 === e[t]) throw new TypeError('No method named \"' + t + '\"');\n          e[t]();\n        }\n      });\n    }, e(o, null, [{\n      key: \"Default\",\n      get: function get() {\n        return Be;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return je;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.tooltip\";\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return He;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return \".bs.tooltip\";\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return Pe;\n      }\n    }]), o;\n  }(R);\n\n  b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[je];\n      t.fn[je] = Re.jQueryInterface, t.fn[je].Constructor = Re, t.fn[je].noConflict = function () {\n        return t.fn[je] = e, Re.jQueryInterface;\n      };\n    }\n  });\n\n  var We = \"popover\",\n      Ke = new RegExp(\"(^|\\\\s)bs-popover\\\\S+\", \"g\"),\n      Qe = n({}, Re.Default, {\n    placement: \"right\",\n    trigger: \"click\",\n    content: \"\",\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"popover-arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>'\n  }),\n      Ue = n({}, Re.DefaultType, {\n    content: \"(string|element|function)\"\n  }),\n      Fe = {\n    HIDE: \"hide.bs.popover\",\n    HIDDEN: \"hidden.bs.popover\",\n    SHOW: \"show.bs.popover\",\n    SHOWN: \"shown.bs.popover\",\n    INSERTED: \"inserted.bs.popover\",\n    CLICK: \"click.bs.popover\",\n    FOCUSIN: \"focusin.bs.popover\",\n    FOCUSOUT: \"focusout.bs.popover\",\n    MOUSEENTER: \"mouseenter.bs.popover\",\n    MOUSELEAVE: \"mouseleave.bs.popover\"\n  },\n      Ye = function (t) {\n    function n() {\n      return t.apply(this, arguments) || this;\n    }\n\n    i(n, t);\n    var o = n.prototype;\n    return o.isWithContent = function () {\n      return this.getTitle() || this._getContent();\n    }, o.setContent = function () {\n      var t = this.getTipElement();\n      this.setElementContent(q.findOne(\".popover-header\", t), this.getTitle());\n\n      var e = this._getContent();\n\n      \"function\" == typeof e && (e = e.call(this._element)), this.setElementContent(q.findOne(\".popover-body\", t), e), t.classList.remove(\"fade\", \"show\");\n    }, o._addAttachmentClass = function (t) {\n      this.getTipElement().classList.add(\"bs-popover-\" + this.updateAttachment(t));\n    }, o._getContent = function () {\n      return this._element.getAttribute(\"data-bs-content\") || this.config.content;\n    }, o._cleanTipClass = function () {\n      var t = this.getTipElement(),\n          e = t.getAttribute(\"class\").match(Ke);\n      null !== e && e.length > 0 && e.map(function (t) {\n        return t.trim();\n      }).forEach(function (e) {\n        return t.classList.remove(e);\n      });\n    }, n.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.popover\"),\n            i = \"object\" == _typeof(t) ? t : null;\n\n        if ((e || !/dispose|hide/.test(t)) && (e || (e = new n(this, i), E(this, \"bs.popover\", e)), \"string\" == typeof t)) {\n          if (void 0 === e[t]) throw new TypeError('No method named \"' + t + '\"');\n          e[t]();\n        }\n      });\n    }, e(n, null, [{\n      key: \"Default\",\n      get: function get() {\n        return Qe;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return We;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.popover\";\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Fe;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return \".bs.popover\";\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return Ue;\n      }\n    }]), n;\n  }(Re);\n\n  b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[We];\n      t.fn[We] = Ye.jQueryInterface, t.fn[We].Constructor = Ye, t.fn[We].noConflict = function () {\n        return t.fn[We] = e, Ye.jQueryInterface;\n      };\n    }\n  });\n\n  var qe = \"scrollspy\",\n      ze = {\n    offset: 10,\n    method: \"auto\",\n    target: \"\"\n  },\n      Ve = {\n    offset: \"number\",\n    method: \"string\",\n    target: \"(string|element)\"\n  },\n      Xe = function (t) {\n    function o(e, n) {\n      var i;\n      return (i = t.call(this, e) || this)._scrollElement = \"BODY\" === e.tagName ? window : e, i._config = i._getConfig(n), i._selector = i._config.target + \" .nav-link, \" + i._config.target + \" .list-group-item, \" + i._config.target + \" .dropdown-item\", i._offsets = [], i._targets = [], i._activeTarget = null, i._scrollHeight = 0, H.on(i._scrollElement, \"scroll.bs.scrollspy\", function (t) {\n        return i._process(t);\n      }), i.refresh(), i._process(), i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.refresh = function () {\n      var t = this,\n          e = this._scrollElement === this._scrollElement.window ? \"offset\" : \"position\",\n          n = \"auto\" === this._config.method ? e : this._config.method,\n          i = \"position\" === n ? this._getScrollTop() : 0;\n      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), q.find(this._selector).map(function (t) {\n        var e = l(t),\n            o = e ? q.findOne(e) : null;\n\n        if (o) {\n          var r = o.getBoundingClientRect();\n          if (r.width || r.height) return [Y[n](o).top + i, e];\n        }\n\n        return null;\n      }).filter(function (t) {\n        return t;\n      }).sort(function (t, e) {\n        return t[0] - e[0];\n      }).forEach(function (e) {\n        t._offsets.push(e[0]), t._targets.push(e[1]);\n      });\n    }, r.dispose = function () {\n      t.prototype.dispose.call(this), H.off(this._scrollElement, \".bs.scrollspy\"), this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;\n    }, r._getConfig = function (t) {\n      if (\"string\" != typeof (t = n({}, ze, \"object\" == _typeof(t) && t ? t : {})).target && d(t.target)) {\n        var e = t.target.id;\n        e || (e = s(qe), t.target.id = e), t.target = \"#\" + e;\n      }\n\n      return p(qe, t, Ve), t;\n    }, r._getScrollTop = function () {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    }, r._getScrollHeight = function () {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    }, r._getOffsetHeight = function () {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    }, r._process = function () {\n      var t = this._getScrollTop() + this._config.offset,\n          e = this._getScrollHeight(),\n          n = this._config.offset + e - this._getOffsetHeight();\n\n      if (this._scrollHeight !== e && this.refresh(), t >= n) {\n        var i = this._targets[this._targets.length - 1];\n        this._activeTarget !== i && this._activate(i);\n      } else {\n        if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();\n\n        for (var o = this._offsets.length; o--;) {\n          this._activeTarget !== this._targets[o] && t >= this._offsets[o] && (void 0 === this._offsets[o + 1] || t < this._offsets[o + 1]) && this._activate(this._targets[o]);\n        }\n      }\n    }, r._activate = function (t) {\n      this._activeTarget = t, this._clear();\n\n      var e = this._selector.split(\",\").map(function (e) {\n        return e + '[data-bs-target=\"' + t + '\"],' + e + '[href=\"' + t + '\"]';\n      }),\n          n = q.findOne(e.join(\",\"));\n\n      n.classList.contains(\"dropdown-item\") ? (q.findOne(\".dropdown-toggle\", n.closest(\".dropdown\")).classList.add(\"active\"), n.classList.add(\"active\")) : (n.classList.add(\"active\"), q.parents(n, \".nav, .list-group\").forEach(function (t) {\n        q.prev(t, \".nav-link, .list-group-item\").forEach(function (t) {\n          return t.classList.add(\"active\");\n        }), q.prev(t, \".nav-item\").forEach(function (t) {\n          q.children(t, \".nav-link\").forEach(function (t) {\n            return t.classList.add(\"active\");\n          });\n        });\n      })), H.trigger(this._scrollElement, \"activate.bs.scrollspy\", {\n        relatedTarget: t\n      });\n    }, r._clear = function () {\n      q.find(this._selector).filter(function (t) {\n        return t.classList.contains(\"active\");\n      }).forEach(function (t) {\n        return t.classList.remove(\"active\");\n      });\n    }, o.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.scrollspy\");\n\n        if (e || (e = new o(this, \"object\" == _typeof(t) && t)), \"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError('No method named \"' + t + '\"');\n          e[t]();\n        }\n      });\n    }, e(o, null, [{\n      key: \"Default\",\n      get: function get() {\n        return ze;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.scrollspy\";\n      }\n    }]), o;\n  }(R);\n\n  H.on(window, \"load.bs.scrollspy.data-api\", function () {\n    q.find('[data-bs-spy=\"scroll\"]').forEach(function (t) {\n      return new Xe(t, Y.getDataAttributes(t));\n    });\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn[qe];\n      t.fn[qe] = Xe.jQueryInterface, t.fn[qe].Constructor = Xe, t.fn[qe].noConflict = function () {\n        return t.fn[qe] = e, Xe.jQueryInterface;\n      };\n    }\n  });\n\n  var $e = function (t) {\n    function n() {\n      return t.apply(this, arguments) || this;\n    }\n\n    i(n, t);\n    var o = n.prototype;\n    return o.show = function () {\n      var t = this;\n\n      if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(\"active\") || this._element.classList.contains(\"disabled\"))) {\n        var e,\n            n = c(this._element),\n            i = this._element.closest(\".nav, .list-group\");\n\n        if (i) {\n          var o = \"UL\" === i.nodeName || \"OL\" === i.nodeName ? \":scope > li > .active\" : \".active\";\n          e = (e = q.find(o, i))[e.length - 1];\n        }\n\n        var r = null;\n\n        if (e && (r = H.trigger(e, \"hide.bs.tab\", {\n          relatedTarget: this._element\n        })), !(H.trigger(this._element, \"show.bs.tab\", {\n          relatedTarget: e\n        }).defaultPrevented || null !== r && r.defaultPrevented)) {\n          this._activate(this._element, i);\n\n          var s = function s() {\n            H.trigger(e, \"hidden.bs.tab\", {\n              relatedTarget: t._element\n            }), H.trigger(t._element, \"shown.bs.tab\", {\n              relatedTarget: e\n            });\n          };\n\n          n ? this._activate(n, n.parentNode, s) : s();\n        }\n      }\n    }, o._activate = function (t, e, n) {\n      var i = this,\n          o = (!e || \"UL\" !== e.nodeName && \"OL\" !== e.nodeName ? q.children(e, \".active\") : q.find(\":scope > li > .active\", e))[0],\n          r = n && o && o.classList.contains(\"fade\"),\n          s = function s() {\n        return i._transitionComplete(t, o, n);\n      };\n\n      if (o && r) {\n        var a = u(o);\n        o.classList.remove(\"show\"), H.one(o, \"transitionend\", s), h(o, a);\n      } else s();\n    }, o._transitionComplete = function (t, e, n) {\n      if (e) {\n        e.classList.remove(\"active\");\n        var i = q.findOne(\":scope > .dropdown-menu .active\", e.parentNode);\n        i && i.classList.remove(\"active\"), \"tab\" === e.getAttribute(\"role\") && e.setAttribute(\"aria-selected\", !1);\n      }\n\n      (t.classList.add(\"active\"), \"tab\" === t.getAttribute(\"role\") && t.setAttribute(\"aria-selected\", !0), v(t), t.classList.contains(\"fade\") && t.classList.add(\"show\"), t.parentNode && t.parentNode.classList.contains(\"dropdown-menu\")) && (t.closest(\".dropdown\") && q.find(\".dropdown-toggle\").forEach(function (t) {\n        return t.classList.add(\"active\");\n      }), t.setAttribute(\"aria-expanded\", !0));\n      n && n();\n    }, n.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.tab\") || new n(this);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError('No method named \"' + t + '\"');\n          e[t]();\n        }\n      });\n    }, e(n, null, [{\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.tab\";\n      }\n    }]), n;\n  }(R);\n\n  H.on(document, \"click.bs.tab.data-api\", '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]', function (t) {\n    t.preventDefault(), (T(this, \"bs.tab\") || new $e(this)).show();\n  }), b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn.tab;\n      t.fn.tab = $e.jQueryInterface, t.fn.tab.Constructor = $e, t.fn.tab.noConflict = function () {\n        return t.fn.tab = e, $e.jQueryInterface;\n      };\n    }\n  });\n\n  var Ge = {\n    animation: \"boolean\",\n    autohide: \"boolean\",\n    delay: \"number\"\n  },\n      Ze = {\n    animation: !0,\n    autohide: !0,\n    delay: 5e3\n  },\n      Je = function (t) {\n    function o(e, n) {\n      var i;\n      return (i = t.call(this, e) || this)._config = i._getConfig(n), i._timeout = null, i._setListeners(), i;\n    }\n\n    i(o, t);\n    var r = o.prototype;\n    return r.show = function () {\n      var t = this;\n\n      if (!H.trigger(this._element, \"show.bs.toast\").defaultPrevented) {\n        this._clearTimeout(), this._config.animation && this._element.classList.add(\"fade\");\n\n        var e = function e() {\n          t._element.classList.remove(\"showing\"), t._element.classList.add(\"show\"), H.trigger(t._element, \"shown.bs.toast\"), t._config.autohide && (t._timeout = setTimeout(function () {\n            t.hide();\n          }, t._config.delay));\n        };\n\n        if (this._element.classList.remove(\"hide\"), v(this._element), this._element.classList.add(\"showing\"), this._config.animation) {\n          var n = u(this._element);\n          H.one(this._element, \"transitionend\", e), h(this._element, n);\n        } else e();\n      }\n    }, r.hide = function () {\n      var t = this;\n\n      if (this._element.classList.contains(\"show\") && !H.trigger(this._element, \"hide.bs.toast\").defaultPrevented) {\n        var e = function e() {\n          t._element.classList.add(\"hide\"), H.trigger(t._element, \"hidden.bs.toast\");\n        };\n\n        if (this._element.classList.remove(\"show\"), this._config.animation) {\n          var n = u(this._element);\n          H.one(this._element, \"transitionend\", e), h(this._element, n);\n        } else e();\n      }\n    }, r.dispose = function () {\n      this._clearTimeout(), this._element.classList.contains(\"show\") && this._element.classList.remove(\"show\"), H.off(this._element, \"click.dismiss.bs.toast\"), t.prototype.dispose.call(this), this._config = null;\n    }, r._getConfig = function (t) {\n      return t = n({}, Ze, Y.getDataAttributes(this._element), \"object\" == _typeof(t) && t ? t : {}), p(\"toast\", t, this.constructor.DefaultType), t;\n    }, r._setListeners = function () {\n      var t = this;\n      H.on(this._element, \"click.dismiss.bs.toast\", '[data-bs-dismiss=\"toast\"]', function () {\n        return t.hide();\n      });\n    }, r._clearTimeout = function () {\n      clearTimeout(this._timeout), this._timeout = null;\n    }, o.jQueryInterface = function (t) {\n      return this.each(function () {\n        var e = T(this, \"bs.toast\");\n\n        if (e || (e = new o(this, \"object\" == _typeof(t) && t)), \"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError('No method named \"' + t + '\"');\n          e[t](this);\n        }\n      });\n    }, e(o, null, [{\n      key: \"DefaultType\",\n      get: function get() {\n        return Ge;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Ze;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.toast\";\n      }\n    }]), o;\n  }(R);\n\n  return b(function () {\n    var t = _();\n\n    if (t) {\n      var e = t.fn.toast;\n      t.fn.toast = Je.jQueryInterface, t.fn.toast.Constructor = Je, t.fn.toast.noConflict = function () {\n        return t.fn.toast = e, Je.jQueryInterface;\n      };\n    }\n  }), {\n    Alert: K,\n    Button: Q,\n    Carousel: Z,\n    Collapse: nt,\n    Dropdown: Te,\n    Modal: Le,\n    Popover: Ye,\n    ScrollSpy: Xe,\n    Tab: $e,\n    Toast: Je,\n    Tooltip: Re\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmJ1bmRsZS5taW4uanM/NWEzMiJdLCJuYW1lcyI6WyJ0IiwiZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJuIiwibGVuZ3RoIiwiaSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwicHJvdG90eXBlIiwiYXNzaWduIiwiYXJndW1lbnRzIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl9fcHJvdG9fXyIsIm8iLCJyIiwicyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJhIiwiZ2V0QXR0cmlidXRlIiwidHJpbSIsImwiLCJxdWVyeVNlbGVjdG9yIiwiYyIsInUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkRlbGF5IiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInNwbGl0IiwiZiIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsImQiLCJub2RlVHlwZSIsImgiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJwIiwia2V5cyIsImZvckVhY2giLCJ0b1N0cmluZyIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJSZWdFeHAiLCJ0ZXN0IiwiRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsImciLCJzdHlsZSIsInBhcmVudE5vZGUiLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsIm0iLCJ2Iiwib2Zmc2V0SGVpZ2h0IiwiXyIsImpRdWVyeSIsImJvZHkiLCJoYXNBdHRyaWJ1dGUiLCJiIiwicmVhZHlTdGF0ZSIsInkiLCJkb2N1bWVudEVsZW1lbnQiLCJkaXIiLCJ3Iiwic2V0IiwiYnNLZXkiLCJpZCIsImdldCIsIkUiLCJUIiwiayIsIk8iLCJMIiwiQSIsIkMiLCJEIiwieCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwiUyIsIlNldCIsImoiLCJ1aWRFdmVudCIsIk4iLCJJIiwib3JpZ2luYWxIYW5kbGVyIiwiZGVsZWdhdGlvblNlbGVjdG9yIiwiUCIsInJlcGxhY2UiLCJoYXMiLCJNIiwib25lT2ZmIiwicXVlcnlTZWxlY3RvckFsbCIsInRhcmdldCIsImRlbGVnYXRlVGFyZ2V0IiwiSCIsIm9mZiIsInR5cGUiLCJCIiwiQm9vbGVhbiIsIm9uIiwib25lIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwic2xpY2UiLCJ0cmlnZ2VyIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0IiwiZGVmYXVsdFByZXZlbnRlZCIsIlIiLCJfZWxlbWVudCIsIkRBVEFfS0VZIiwiZGlzcG9zZSIsImdldEluc3RhbmNlIiwiVyIsIksiLCJjbG9zZSIsIl9nZXRSb290RWxlbWVudCIsIl90cmlnZ2VyQ2xvc2VFdmVudCIsIl9yZW1vdmVFbGVtZW50IiwiY2xvc2VzdCIsImNsYXNzTGlzdCIsInJlbW92ZSIsImNvbnRhaW5zIiwiX2Rlc3Ryb3lFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJqUXVlcnlJbnRlcmZhY2UiLCJlYWNoIiwiaGFuZGxlRGlzbWlzcyIsImZuIiwiQ29uc3RydWN0b3IiLCJub0NvbmZsaWN0IiwiUSIsInRvZ2dsZSIsInNldEF0dHJpYnV0ZSIsIlUiLCJGIiwiYnV0dG9uIiwiWSIsInNldERhdGFBdHRyaWJ1dGUiLCJyZW1vdmVEYXRhQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0RGF0YUF0dHJpYnV0ZXMiLCJkYXRhc2V0IiwiZmlsdGVyIiwiY2hhckF0IiwiZ2V0RGF0YUF0dHJpYnV0ZSIsIm9mZnNldCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsInNjcm9sbFRvcCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwicG9zaXRpb24iLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwicSIsIm1hdGNoZXMiLCJmaW5kIiwiY29uY2F0IiwiRWxlbWVudCIsImZpbmRPbmUiLCJjaGlsZHJlbiIsInBhcmVudHMiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwicHVzaCIsInByZXYiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dCIsIm5leHRFbGVtZW50U2libGluZyIsInoiLCJWIiwiWCIsImludGVydmFsIiwia2V5Ym9hcmQiLCJzbGlkZSIsInBhdXNlIiwid3JhcCIsInRvdWNoIiwiJCIsIkciLCJUT1VDSCIsIlBFTiIsIloiLCJfaXRlbXMiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1BhdXNlZCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRGVsdGFYIiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfdG91Y2hTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIl9wb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJfc2xpZGUiLCJuZXh0V2hlblZpc2libGUiLCJoaWRkZW4iLCJjeWNsZSIsImNsZWFySW50ZXJ2YWwiLCJfdXBkYXRlSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInZpc2liaWxpdHlTdGF0ZSIsImJpbmQiLCJ0byIsIl9nZXRJdGVtSW5kZXgiLCJfaGFuZGxlU3dpcGUiLCJhYnMiLCJfa2V5ZG93biIsIl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzIiwicG9pbnRlclR5cGUiLCJjbGllbnRYIiwidG91Y2hlcyIsImNsZWFyVGltZW91dCIsImFkZCIsInRhZ05hbWUiLCJpbmRleE9mIiwiX2dldEl0ZW1CeURpcmVjdGlvbiIsIl90cmlnZ2VyU2xpZGVFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJkaXJlY3Rpb24iLCJmcm9tIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJwYXJzZUludCIsImRlZmF1bHRJbnRlcnZhbCIsImNhcm91c2VsSW50ZXJmYWNlIiwiVHlwZUVycm9yIiwicmlkZSIsImRhdGFBcGlDbGlja0hhbmRsZXIiLCJKIiwidHQiLCJwYXJlbnQiLCJldCIsIm50IiwiX2lzVHJhbnNpdGlvbmluZyIsIl90cmlnZ2VyQXJyYXkiLCJfc2VsZWN0b3IiLCJfcGFyZW50IiwiX2dldFBhcmVudCIsIl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MiLCJoaWRlIiwic2hvdyIsImNvbGxhcHNlSW50ZXJmYWNlIiwiX2dldERpbWVuc2lvbiIsInNldFRyYW5zaXRpb25pbmciLCJqcXVlcnkiLCJpdCIsIm90IiwicnQiLCJzdCIsImF0IiwibHQiLCJyZWR1Y2UiLCJjdCIsInV0IiwiZnQiLCJub2RlTmFtZSIsImR0Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaHQiLCJwdCIsIkhUTUxFbGVtZW50IiwiZ3QiLCJuYW1lIiwiZW5hYmxlZCIsInBoYXNlIiwic3RhdGUiLCJlbGVtZW50cyIsInN0eWxlcyIsImF0dHJpYnV0ZXMiLCJlZmZlY3QiLCJwb3BwZXIiLCJvcHRpb25zIiwic3RyYXRlZ3kiLCJtYXJnaW4iLCJhcnJvdyIsInJlZmVyZW5jZSIsInJlcXVpcmVzIiwibXQiLCJ2dCIsIndpZHRoIiwib2Zmc2V0V2lkdGgiLCJoZWlnaHQiLCJfdCIsImdldFJvb3ROb2RlIiwiU2hhZG93Um9vdCIsImlzU2FtZU5vZGUiLCJob3N0IiwiYnQiLCJ5dCIsInd0IiwiRXQiLCJhc3NpZ25lZFNsb3QiLCJUdCIsIm9mZnNldFBhcmVudCIsImt0IiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJ3aWxsQ2hhbmdlIiwiT3QiLCJMdCIsIm1heCIsIm1pbiIsIkF0IiwicmlnaHQiLCJib3R0b20iLCJDdCIsIkR0IiwibW9kaWZpZXJzRGF0YSIsInBvcHBlck9mZnNldHMiLCJwbGFjZW1lbnQiLCJwYWRkaW5nIiwicmVjdHMiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlck9mZnNldCIsImVsZW1lbnQiLCJyZXF1aXJlc0lmRXhpc3RzIiwieHQiLCJTdCIsInBvcHBlclJlY3QiLCJvZmZzZXRzIiwiZ3B1QWNjZWxlcmF0aW9uIiwiYWRhcHRpdmUiLCJkZXZpY2VQaXhlbFJhdGlvIiwicm91bmQiLCJqdCIsImRhdGEiLCJOdCIsInBhc3NpdmUiLCJJdCIsImluc3RhbmNlIiwic2Nyb2xsIiwicmVzaXplIiwic2Nyb2xsUGFyZW50cyIsInVwZGF0ZSIsIlB0IiwiTXQiLCJCdCIsInN0YXJ0IiwiZW5kIiwiSHQiLCJSdCIsIld0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIkt0IiwiUXQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsIlV0IiwidmlzdWFsVmlld3BvcnQiLCJGdCIsIll0IiwidXNlckFnZW50IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwicXQiLCJ6dCIsIlZ0IiwiY2VpbCIsIlh0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwiY29udGV4dEVsZW1lbnQiLCIkdCIsImZsaXBWYXJpYXRpb25zIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwic29ydCIsIkd0IiwiX3NraXAiLCJtYWluQXhpcyIsImFsdEF4aXMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJNYXAiLCJldmVyeSIsInJlc2V0IiwiWnQiLCJKdCIsInNvbWUiLCJ0ZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyIsInBvcHBlckVzY2FwZU9mZnNldHMiLCJpc1JlZmVyZW5jZUhpZGRlbiIsImhhc1BvcHBlckVzY2FwZWQiLCJlZSIsIm5lIiwiaWUiLCJ0ZXRoZXIiLCJ0ZXRoZXJPZmZzZXQiLCJvZSIsInJlIiwic2UiLCJtb2RpZmllcnMiLCJhZSIsIkFycmF5IiwibGUiLCJkZWZhdWx0TW9kaWZpZXJzIiwiZGVmYXVsdE9wdGlvbnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwic2V0T3B0aW9ucyIsIm1hcCIsImZvcmNlVXBkYXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJjZSIsInVlIiwiZmUiLCJkZSIsImZyZWV6ZSIsInBvcHBlckdlbmVyYXRvciIsImRldGVjdE92ZXJmbG93IiwiY3JlYXRlUG9wcGVyQmFzZSIsImNyZWF0ZVBvcHBlciIsImNyZWF0ZVBvcHBlckxpdGUiLCJhdXRvIiwiYmFzZVBsYWNlbWVudHMiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJhcHBseVN0eWxlcyIsImNvbXB1dGVTdHlsZXMiLCJldmVudExpc3RlbmVycyIsImZsaXAiLCJoZSIsInBlIiwiZ2UiLCJtZSIsInZlIiwiX2UiLCJiZSIsInllIiwid2UiLCJwb3BwZXJDb25maWciLCJFZSIsIlRlIiwiX3BvcHBlciIsIl9tZW51IiwiX2dldE1lbnVFbGVtZW50IiwiX2luTmF2YmFyIiwiX2RldGVjdE5hdmJhciIsImRpc2FibGVkIiwiY2xlYXJNZW51cyIsImdldFBhcmVudEZyb21FbGVtZW50IiwiX2dldFBvcHBlckNvbmZpZyIsImZvY3VzIiwic3RvcFByb3BhZ2F0aW9uIiwiRGVmYXVsdCIsIkRlZmF1bHRUeXBlIiwiX2dldFBsYWNlbWVudCIsImdldFByb3BlcnR5VmFsdWUiLCJkcm9wZG93bkludGVyZmFjZSIsImNsaWNrRXZlbnQiLCJkYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJrZSIsImJhY2tkcm9wIiwiT2UiLCJMZSIsIl9kaWFsb2ciLCJfYmFja2Ryb3AiLCJfaXNTaG93biIsIl9pc0JvZHlPdmVyZmxvd2luZyIsIl9pZ25vcmVCYWNrZHJvcENsaWNrIiwiX3Njcm9sbGJhcldpZHRoIiwiX2NoZWNrU2Nyb2xsYmFyIiwiX3NldFNjcm9sbGJhciIsIl9hZGp1c3REaWFsb2ciLCJfc2V0RXNjYXBlRXZlbnQiLCJfc2V0UmVzaXplRXZlbnQiLCJfc2hvd0JhY2tkcm9wIiwiX3Nob3dFbGVtZW50IiwiX2hpZGVNb2RhbCIsImhhbmRsZVVwZGF0ZSIsImFwcGVuZENoaWxkIiwiX2VuZm9yY2VGb2N1cyIsIl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJfcmVzZXRTY3JvbGxiYXIiLCJfcmVtb3ZlQmFja2Ryb3AiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiY3VycmVudFRhcmdldCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiaW5uZXJXaWR0aCIsIl9nZXRTY3JvbGxiYXJXaWR0aCIsIm1hcmdpblJpZ2h0IiwibW9kYWwiLCJBZSIsIkNlIiwiRGUiLCJ4ZSIsImFyZWEiLCJiciIsImNvbCIsImNvZGUiLCJkaXYiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaW1nIiwibGkiLCJvbCIsInByZSIsInNtYWxsIiwic3BhbiIsInN1YiIsInN1cCIsInN0cm9uZyIsInVsIiwiU2UiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJub2RlVmFsdWUiLCJpbm5lckhUTUwiLCJqZSIsIk5lIiwiSWUiLCJQZSIsImFuaW1hdGlvbiIsInRlbXBsYXRlIiwidGl0bGUiLCJkZWxheSIsImh0bWwiLCJzZWxlY3RvciIsImNvbnRhaW5lciIsImN1c3RvbUNsYXNzIiwic2FuaXRpemUiLCJzYW5pdGl6ZUZuIiwiYWxsb3dMaXN0IiwiTWUiLCJBVVRPIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJMRUZUIiwiQmUiLCJIZSIsIkhJREUiLCJISURERU4iLCJTSE9XIiwiU0hPV04iLCJJTlNFUlRFRCIsIkNMSUNLIiwiRk9DVVNJTiIsIkZPQ1VTT1VUIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJSZSIsIl9pc0VuYWJsZWQiLCJfdGltZW91dCIsIl9ob3ZlclN0YXRlIiwiX2FjdGl2ZVRyaWdnZXIiLCJjb25maWciLCJ0aXAiLCJfc2V0TGlzdGVuZXJzIiwiZW5hYmxlIiwiZGlzYWJsZSIsInRvZ2dsZUVuYWJsZWQiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJjbGljayIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2VudGVyIiwiX2xlYXZlIiwiZ2V0VGlwRWxlbWVudCIsIkVWRU5UX0tFWSIsIl9oaWRlTW9kYWxIYW5kbGVyIiwiaXNXaXRoQ29udGVudCIsImF0dGFjaFNoYWRvdyIsIk5BTUUiLCJzZXRDb250ZW50IiwiX2dldEF0dGFjaG1lbnQiLCJfYWRkQXR0YWNobWVudENsYXNzIiwiX2dldENvbnRhaW5lciIsIl9jbGVhblRpcENsYXNzIiwiaG92ZXIiLCJnZXRUaXRsZSIsInNldEVsZW1lbnRDb250ZW50IiwidGV4dENvbnRlbnQiLCJ1cGRhdGVBdHRhY2htZW50IiwiX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSIsIl9maXhUaXRsZSIsImNvbnRlbnQiLCJXZSIsIktlIiwiUWUiLCJVZSIsIkZlIiwiWWUiLCJfZ2V0Q29udGVudCIsInFlIiwiemUiLCJtZXRob2QiLCJWZSIsIlhlIiwiX3Njcm9sbEVsZW1lbnQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsIl9nZXRPZmZzZXRIZWlnaHQiLCJpbm5lckhlaWdodCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsImpvaW4iLCIkZSIsIl90cmFuc2l0aW9uQ29tcGxldGUiLCJ0YWIiLCJHZSIsImF1dG9oaWRlIiwiWmUiLCJKZSIsIl9jbGVhclRpbWVvdXQiLCJ0b2FzdCIsIkFsZXJ0IiwiQnV0dG9uIiwiQ2Fyb3VzZWwiLCJDb2xsYXBzZSIsIkRyb3Bkb3duIiwiTW9kYWwiLCJQb3BvdmVyIiwiU2Nyb2xsU3B5IiwiVGFiIiwiVG9hc3QiLCJUb29sdGlwIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVNBLENBQVQsRUFBV0MsQ0FBWCxFQUFhO0FBQUMsb0NBQWlCQyxPQUFqQixNQUEwQixlQUFhLFFBQXZDLEdBQXFEQyxNQUFNLENBQUNELE9BQVAsR0FBZUQsQ0FBQyxFQUFyRSxHQUF3RSxRQUFzQ0csb0NBQU9ILENBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBNUMsR0FBZ0QsQ0FBeEg7QUFBNEwsQ0FBMU0sQ0FBMk0sSUFBM00sRUFBaU4sWUFBVTtBQUFDOztBQUFhLFdBQVNELENBQVQsQ0FBV0EsQ0FBWCxFQUFhQyxDQUFiLEVBQWU7QUFBQyxTQUFJLElBQUlJLENBQUMsR0FBQyxDQUFWLEVBQVlBLENBQUMsR0FBQ0osQ0FBQyxDQUFDSyxNQUFoQixFQUF1QkQsQ0FBQyxFQUF4QixFQUEyQjtBQUFDLFVBQUlFLENBQUMsR0FBQ04sQ0FBQyxDQUFDSSxDQUFELENBQVA7QUFBV0UsT0FBQyxDQUFDQyxVQUFGLEdBQWFELENBQUMsQ0FBQ0MsVUFBRixJQUFjLENBQUMsQ0FBNUIsRUFBOEJELENBQUMsQ0FBQ0UsWUFBRixHQUFlLENBQUMsQ0FBOUMsRUFBZ0QsV0FBVUYsQ0FBVixLQUFjQSxDQUFDLENBQUNHLFFBQUYsR0FBVyxDQUFDLENBQTFCLENBQWhELEVBQTZFQyxNQUFNLENBQUNDLGNBQVAsQ0FBc0JaLENBQXRCLEVBQXdCTyxDQUFDLENBQUNNLEdBQTFCLEVBQThCTixDQUE5QixDQUE3RTtBQUE4RztBQUFDOztBQUFBLFdBQVNOLENBQVQsQ0FBV0Es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LEtBQUwsR0FBV2xxQixDQUFYLEVBQWFncUIsRUFBRSxDQUFDMWdCLGVBQXZCO0FBQXVDLE9BQWhJO0FBQWlJO0FBQUMsR0FBaEwsQ0FBRCxFQUFvTDtBQUFDNmdCLFNBQUssRUFBQ3hoQixDQUFQO0FBQVN5aEIsVUFBTSxFQUFDeGdCLENBQWhCO0FBQWtCeWdCLFlBQVEsRUFBQ3JkLENBQTNCO0FBQTZCc2QsWUFBUSxFQUFDOVosRUFBdEM7QUFBeUMrWixZQUFRLEVBQUNoTSxFQUFsRDtBQUFxRGlNLFNBQUssRUFBQzNLLEVBQTNEO0FBQThENEssV0FBTyxFQUFDcEMsRUFBdEU7QUFBeUVxQyxhQUFTLEVBQUMvQixFQUFuRjtBQUFzRmdDLE9BQUcsRUFBQ2pCLEVBQTFGO0FBQTZGa0IsU0FBSyxFQUFDWixFQUFuRztBQUFzR2EsV0FBTyxFQUFDaEY7QUFBOUcsR0FBM0w7QUFBNlMsQ0FBN285RSxDQUFEIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2Jvb3RzdHJhcC5idW5kbGUubWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAgKiBCb290c3RyYXAgdjUuMC4wLWJldGExIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxyXG4gICogQ29weXJpZ2h0IDIwMTEtMjAyMCBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxyXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgKi9cclxuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5ib290c3RyYXA9ZSgpfSh0aGlzLChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZVtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fWZ1bmN0aW9uIGUoZSxuLGkpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLGkmJnQoZSxpKSxlfWZ1bmN0aW9uIG4oKXtyZXR1cm4obj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1hcmd1bWVudHNbZV07Zm9yKHZhciBpIGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4saSkmJih0W2ldPW5baV0pfXJldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGkodCxlKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LHQuX19wcm90b19fPWV9dmFyIG8scixzPWZ1bmN0aW9uKHQpe2Rve3QrPU1hdGguZmxvb3IoMWU2Kk1hdGgucmFuZG9tKCkpfXdoaWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQpKTtyZXR1cm4gdH0sYT1mdW5jdGlvbih0KXt2YXIgZT10LmdldEF0dHJpYnV0ZShcImRhdGEtYnMtdGFyZ2V0XCIpO2lmKCFlfHxcIiNcIj09PWUpe3ZhciBuPXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtlPW4mJlwiI1wiIT09bj9uLnRyaW0oKTpudWxsfXJldHVybiBlfSxsPWZ1bmN0aW9uKHQpe3ZhciBlPWEodCk7cmV0dXJuIGUmJmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSk/ZTpudWxsfSxjPWZ1bmN0aW9uKHQpe3ZhciBlPWEodCk7cmV0dXJuIGU/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTpudWxsfSx1PWZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiAwO3ZhciBlPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpLG49ZS50cmFuc2l0aW9uRHVyYXRpb24saT1lLnRyYW5zaXRpb25EZWxheSxvPU51bWJlci5wYXJzZUZsb2F0KG4pLHI9TnVtYmVyLnBhcnNlRmxvYXQoaSk7cmV0dXJuIG98fHI/KG49bi5zcGxpdChcIixcIilbMF0saT1pLnNwbGl0KFwiLFwiKVswXSwxZTMqKE51bWJlci5wYXJzZUZsb2F0KG4pK051bWJlci5wYXJzZUZsb2F0KGkpKSk6MH0sZj1mdW5jdGlvbih0KXt0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwidHJhbnNpdGlvbmVuZFwiKSl9LGQ9ZnVuY3Rpb24odCl7cmV0dXJuKHRbMF18fHQpLm5vZGVUeXBlfSxoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ITEsaT1lKzU7dC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLChmdW5jdGlvbiBlKCl7bj0hMCx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsZSl9KSksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtufHxmKHQpfSksaSl9LHA9ZnVuY3Rpb24odCxlLG4pe09iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKGkpe3ZhciBvLHI9bltpXSxzPWVbaV0sYT1zJiZkKHMpP1wiZWxlbWVudFwiOm51bGw9PShvPXMpP1wiXCIrbzp7fS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXHMoW2Etel0rKS9pKVsxXS50b0xvd2VyQ2FzZSgpO2lmKCFuZXcgUmVnRXhwKHIpLnRlc3QoYSkpdGhyb3cgbmV3IEVycm9yKHQudG9VcHBlckNhc2UoKSsnOiBPcHRpb24gXCInK2krJ1wiIHByb3ZpZGVkIHR5cGUgXCInK2ErJ1wiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJytyKydcIi4nKX0pKX0sZz1mdW5jdGlvbih0KXtpZighdClyZXR1cm4hMTtpZih0LnN0eWxlJiZ0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zdHlsZSl7dmFyIGU9Z2V0Q29tcHV0ZWRTdHlsZSh0KSxuPWdldENvbXB1dGVkU3R5bGUodC5wYXJlbnROb2RlKTtyZXR1cm5cIm5vbmVcIiE9PWUuZGlzcGxheSYmXCJub25lXCIhPT1uLmRpc3BsYXkmJlwiaGlkZGVuXCIhPT1lLnZpc2liaWxpdHl9cmV0dXJuITF9LG09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXt9fSx2PWZ1bmN0aW9uKHQpe3JldHVybiB0Lm9mZnNldEhlaWdodH0sXz1mdW5jdGlvbigpe3ZhciB0PXdpbmRvdy5qUXVlcnk7cmV0dXJuIHQmJiFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImRhdGEtYnMtbm8tanF1ZXJ5XCIpP3Q6bnVsbH0sYj1mdW5jdGlvbih0KXtcImxvYWRpbmdcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIix0KTp0KCl9LHk9XCJydGxcIj09PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIsdz0obz17fSxyPTEse3NldDpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09dC5ic0tleSYmKHQuYnNLZXk9e2tleTplLGlkOnJ9LHIrKyksb1t0LmJzS2V5LmlkXT1ufSxnZXQ6ZnVuY3Rpb24odCxlKXtpZighdHx8dm9pZCAwPT09dC5ic0tleSlyZXR1cm4gbnVsbDt2YXIgbj10LmJzS2V5O3JldHVybiBuLmtleT09PWU/b1tuLmlkXTpudWxsfSxkZWxldGU6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT10LmJzS2V5KXt2YXIgbj10LmJzS2V5O24ua2V5PT09ZSYmKGRlbGV0ZSBvW24uaWRdLGRlbGV0ZSB0LmJzS2V5KX19fSksRT1mdW5jdGlvbih0LGUsbil7dy5zZXQodCxlLG4pfSxUPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcuZ2V0KHQsZSl9LGs9ZnVuY3Rpb24odCxlKXt3LmRlbGV0ZSh0LGUpfSxPPS9bXi5dKig/PVxcLi4qKVxcLnwuKi8sTD0vXFwuLiovLEE9Lzo6XFxkKyQvLEM9e30sRD0xLHg9e21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIn0sUz1uZXcgU2V0KFtcImNsaWNrXCIsXCJkYmxjbGlja1wiLFwibW91c2V1cFwiLFwibW91c2Vkb3duXCIsXCJjb250ZXh0bWVudVwiLFwibW91c2V3aGVlbFwiLFwiRE9NTW91c2VTY3JvbGxcIixcIm1vdXNlb3ZlclwiLFwibW91c2VvdXRcIixcIm1vdXNlbW92ZVwiLFwic2VsZWN0c3RhcnRcIixcInNlbGVjdGVuZFwiLFwia2V5ZG93blwiLFwia2V5cHJlc3NcIixcImtleXVwXCIsXCJvcmllbnRhdGlvbmNoYW5nZVwiLFwidG91Y2hzdGFydFwiLFwidG91Y2htb3ZlXCIsXCJ0b3VjaGVuZFwiLFwidG91Y2hjYW5jZWxcIixcInBvaW50ZXJkb3duXCIsXCJwb2ludGVybW92ZVwiLFwicG9pbnRlcnVwXCIsXCJwb2ludGVybGVhdmVcIixcInBvaW50ZXJjYW5jZWxcIixcImdlc3R1cmVzdGFydFwiLFwiZ2VzdHVyZWNoYW5nZVwiLFwiZ2VzdHVyZWVuZFwiLFwiZm9jdXNcIixcImJsdXJcIixcImNoYW5nZVwiLFwicmVzZXRcIixcInNlbGVjdFwiLFwic3VibWl0XCIsXCJmb2N1c2luXCIsXCJmb2N1c291dFwiLFwibG9hZFwiLFwidW5sb2FkXCIsXCJiZWZvcmV1bmxvYWRcIixcInJlc2l6ZVwiLFwibW92ZVwiLFwiRE9NQ29udGVudExvYWRlZFwiLFwicmVhZHlzdGF0ZWNoYW5nZVwiLFwiZXJyb3JcIixcImFib3J0XCIsXCJzY3JvbGxcIl0pO2Z1bmN0aW9uIGoodCxlKXtyZXR1cm4gZSYmZStcIjo6XCIrRCsrfHx0LnVpZEV2ZW50fHxEKyt9ZnVuY3Rpb24gTih0KXt2YXIgZT1qKHQpO3JldHVybiB0LnVpZEV2ZW50PWUsQ1tlXT1DW2VdfHx7fSxDW2VdfWZ1bmN0aW9uIEkodCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO2Zvcih2YXIgaT1PYmplY3Qua2V5cyh0KSxvPTAscj1pLmxlbmd0aDtvPHI7bysrKXt2YXIgcz10W2lbb11dO2lmKHMub3JpZ2luYWxIYW5kbGVyPT09ZSYmcy5kZWxlZ2F0aW9uU2VsZWN0b3I9PT1uKXJldHVybiBzfXJldHVybiBudWxsfWZ1bmN0aW9uIFAodCxlLG4pe3ZhciBpPVwic3RyaW5nXCI9PXR5cGVvZiBlLG89aT9uOmUscj10LnJlcGxhY2UoTCxcIlwiKSxzPXhbcl07cmV0dXJuIHMmJihyPXMpLFMuaGFzKHIpfHwocj10KSxbaSxvLHJdfWZ1bmN0aW9uIE0odCxlLG4saSxvKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmdCl7bnx8KG49aSxpPW51bGwpO3ZhciByPVAoZSxuLGkpLHM9clswXSxhPXJbMV0sbD1yWzJdLGM9Tih0KSx1PWNbbF18fChjW2xdPXt9KSxmPUkodSxhLHM/bjpudWxsKTtpZihmKWYub25lT2ZmPWYub25lT2ZmJiZvO2Vsc2V7dmFyIGQ9aihhLGUucmVwbGFjZShPLFwiXCIpKSxoPXM/ZnVuY3Rpb24odCxlLG4pe3JldHVybiBmdW5jdGlvbiBpKG8pe2Zvcih2YXIgcj10LnF1ZXJ5U2VsZWN0b3JBbGwoZSkscz1vLnRhcmdldDtzJiZzIT09dGhpcztzPXMucGFyZW50Tm9kZSlmb3IodmFyIGE9ci5sZW5ndGg7YS0tOylpZihyW2FdPT09cylyZXR1cm4gby5kZWxlZ2F0ZVRhcmdldD1zLGkub25lT2ZmJiZILm9mZih0LG8udHlwZSxuKSxuLmFwcGx5KHMsW29dKTtyZXR1cm4gbnVsbH19KHQsbixpKTpmdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbiBuKGkpe3JldHVybiBpLmRlbGVnYXRlVGFyZ2V0PXQsbi5vbmVPZmYmJkgub2ZmKHQsaS50eXBlLGUpLGUuYXBwbHkodCxbaV0pfX0odCxuKTtoLmRlbGVnYXRpb25TZWxlY3Rvcj1zP246bnVsbCxoLm9yaWdpbmFsSGFuZGxlcj1hLGgub25lT2ZmPW8saC51aWRFdmVudD1kLHVbZF09aCx0LmFkZEV2ZW50TGlzdGVuZXIobCxoLHMpfX19ZnVuY3Rpb24gQih0LGUsbixpLG8pe3ZhciByPUkoZVtuXSxpLG8pO3ImJih0LnJlbW92ZUV2ZW50TGlzdGVuZXIobixyLEJvb2xlYW4obykpLGRlbGV0ZSBlW25dW3IudWlkRXZlbnRdKX12YXIgSD17b246ZnVuY3Rpb24odCxlLG4saSl7TSh0LGUsbixpLCExKX0sb25lOmZ1bmN0aW9uKHQsZSxuLGkpe00odCxlLG4saSwhMCl9LG9mZjpmdW5jdGlvbih0LGUsbixpKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmdCl7dmFyIG89UChlLG4saSkscj1vWzBdLHM9b1sxXSxhPW9bMl0sbD1hIT09ZSxjPU4odCksdT1lLnN0YXJ0c1dpdGgoXCIuXCIpO2lmKHZvaWQgMD09PXMpe3UmJk9iamVjdC5rZXlzKGMpLmZvckVhY2goKGZ1bmN0aW9uKG4peyFmdW5jdGlvbih0LGUsbixpKXt2YXIgbz1lW25dfHx7fTtPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChmdW5jdGlvbihyKXtpZihyLmluY2x1ZGVzKGkpKXt2YXIgcz1vW3JdO0IodCxlLG4scy5vcmlnaW5hbEhhbmRsZXIscy5kZWxlZ2F0aW9uU2VsZWN0b3IpfX0pKX0odCxjLG4sZS5zbGljZSgxKSl9KSk7dmFyIGY9Y1thXXx8e307T2JqZWN0LmtleXMoZikuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIGk9bi5yZXBsYWNlKEEsXCJcIik7aWYoIWx8fGUuaW5jbHVkZXMoaSkpe3ZhciBvPWZbbl07Qih0LGMsYSxvLm9yaWdpbmFsSGFuZGxlcixvLmRlbGVnYXRpb25TZWxlY3Rvcil9fSkpfWVsc2V7aWYoIWN8fCFjW2FdKXJldHVybjtCKHQsYyxhLHMscj9uOm51bGwpfX19LHRyaWdnZXI6ZnVuY3Rpb24odCxlLG4pe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlfHwhdClyZXR1cm4gbnVsbDt2YXIgaSxvPV8oKSxyPWUucmVwbGFjZShMLFwiXCIpLHM9ZSE9PXIsYT1TLmhhcyhyKSxsPSEwLGM9ITAsdT0hMSxmPW51bGw7cmV0dXJuIHMmJm8mJihpPW8uRXZlbnQoZSxuKSxvKHQpLnRyaWdnZXIoaSksbD0haS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpLGM9IWkuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSx1PWkuaXNEZWZhdWx0UHJldmVudGVkKCkpLGE/KGY9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpKS5pbml0RXZlbnQocixsLCEwKTpmPW5ldyBDdXN0b21FdmVudChlLHtidWJibGVzOmwsY2FuY2VsYWJsZTohMH0pLHZvaWQgMCE9PW4mJk9iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShmLHQse2dldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX0pfSkpLHUmJmYucHJldmVudERlZmF1bHQoKSxjJiZ0LmRpc3BhdGNoRXZlbnQoZiksZi5kZWZhdWx0UHJldmVudGVkJiZ2b2lkIDAhPT1pJiZpLnByZXZlbnREZWZhdWx0KCksZn19LFI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3QmJih0aGlzLl9lbGVtZW50PXQsRSh0LHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksdGhpcykpfXJldHVybiB0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7ayh0aGlzLl9lbGVtZW50LHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpLHRoaXMuX2VsZW1lbnQ9bnVsbH0sdC5nZXRJbnN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gVCh0LHRoaXMuREFUQV9LRVkpfSxlKHQsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjUuMC4wLWJldGExXCJ9fV0pLHR9KCksVz1cImFsZXJ0XCIsSz1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfWkobix0KTt2YXIgbz1uLnByb3RvdHlwZTtyZXR1cm4gby5jbG9zZT1mdW5jdGlvbih0KXt2YXIgZT10P3RoaXMuX2dldFJvb3RFbGVtZW50KHQpOnRoaXMuX2VsZW1lbnQsbj10aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChlKTtudWxsPT09bnx8bi5kZWZhdWx0UHJldmVudGVkfHx0aGlzLl9yZW1vdmVFbGVtZW50KGUpfSxvLl9nZXRSb290RWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gYyh0KXx8dC5jbG9zZXN0KFwiLmFsZXJ0XCIpfSxvLl90cmlnZ2VyQ2xvc2VFdmVudD1mdW5jdGlvbih0KXtyZXR1cm4gSC50cmlnZ2VyKHQsXCJjbG9zZS5icy5hbGVydFwiKX0sby5fcmVtb3ZlRWxlbWVudD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHQuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIiksdC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpKXt2YXIgbj11KHQpO0gub25lKHQsXCJ0cmFuc2l0aW9uZW5kXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuX2Rlc3Ryb3lFbGVtZW50KHQpfSkpLGgodCxuKX1lbHNlIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KHQpfSxvLl9kZXN0cm95RWxlbWVudD1mdW5jdGlvbih0KXt0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSxILnRyaWdnZXIodCxcImNsb3NlZC5icy5hbGVydFwiKX0sbi5qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWFjaCgoZnVuY3Rpb24oKXt2YXIgZT1UKHRoaXMsXCJicy5hbGVydFwiKTtlfHwoZT1uZXcgbih0aGlzKSksXCJjbG9zZVwiPT09dCYmZVt0XSh0aGlzKX0pKX0sbi5oYW5kbGVEaXNtaXNzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtlJiZlLnByZXZlbnREZWZhdWx0KCksdC5jbG9zZSh0aGlzKX19LGUobixudWxsLFt7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLmFsZXJ0XCJ9fV0pLG59KFIpO0gub24oZG9jdW1lbnQsXCJjbGljay5icy5hbGVydC5kYXRhLWFwaVwiLCdbZGF0YS1icy1kaXNtaXNzPVwiYWxlcnRcIl0nLEsuaGFuZGxlRGlzbWlzcyhuZXcgSykpLGIoKGZ1bmN0aW9uKCl7dmFyIHQ9XygpO2lmKHQpe3ZhciBlPXQuZm5bV107dC5mbltXXT1LLmpRdWVyeUludGVyZmFjZSx0LmZuW1ddLkNvbnN0cnVjdG9yPUssdC5mbltXXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm5bV109ZSxLLmpRdWVyeUludGVyZmFjZX19fSkpO3ZhciBRPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGkobix0KSxuLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oKXt0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImFjdGl2ZVwiKSl9LG4ualF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVhY2goKGZ1bmN0aW9uKCl7dmFyIGU9VCh0aGlzLFwiYnMuYnV0dG9uXCIpO2V8fChlPW5ldyBuKHRoaXMpKSxcInRvZ2dsZVwiPT09dCYmZVt0XSgpfSkpfSxlKG4sbnVsbCxbe2tleTpcIkRBVEFfS0VZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJicy5idXR0b25cIn19XSksbn0oUik7ZnVuY3Rpb24gVSh0KXtyZXR1cm5cInRydWVcIj09PXR8fFwiZmFsc2VcIiE9PXQmJih0PT09TnVtYmVyKHQpLnRvU3RyaW5nKCk/TnVtYmVyKHQpOlwiXCI9PT10fHxcIm51bGxcIj09PXQ/bnVsbDp0KX1mdW5jdGlvbiBGKHQpe3JldHVybiB0LnJlcGxhY2UoL1tBLVpdL2csKGZ1bmN0aW9uKHQpe3JldHVyblwiLVwiK3QudG9Mb3dlckNhc2UoKX0pKX1ILm9uKGRvY3VtZW50LFwiY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpXCIsJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXScsKGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgZT10LnRhcmdldC5jbG9zZXN0KCdbZGF0YS1icy10b2dnbGU9XCJidXR0b25cIl0nKSxuPVQoZSxcImJzLmJ1dHRvblwiKTtufHwobj1uZXcgUShlKSksbi50b2dnbGUoKX0pKSxiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuLmJ1dHRvbjt0LmZuLmJ1dHRvbj1RLmpRdWVyeUludGVyZmFjZSx0LmZuLmJ1dHRvbi5Db25zdHJ1Y3Rvcj1RLHQuZm4uYnV0dG9uLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5mbi5idXR0b249ZSxRLmpRdWVyeUludGVyZmFjZX19fSkpO3ZhciBZPXtzZXREYXRhQXR0cmlidXRlOmZ1bmN0aW9uKHQsZSxuKXt0LnNldEF0dHJpYnV0ZShcImRhdGEtYnMtXCIrRihlKSxuKX0scmVtb3ZlRGF0YUF0dHJpYnV0ZTpmdW5jdGlvbih0LGUpe3QucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1icy1cIitGKGUpKX0sZ2V0RGF0YUF0dHJpYnV0ZXM6ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJue307dmFyIGU9e307cmV0dXJuIE9iamVjdC5rZXlzKHQuZGF0YXNldCkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGFydHNXaXRoKFwiYnNcIil9KSkuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIGk9bi5yZXBsYWNlKC9eYnMvLFwiXCIpO2k9aS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKStpLnNsaWNlKDEsaS5sZW5ndGgpLGVbaV09VSh0LmRhdGFzZXRbbl0pfSkpLGV9LGdldERhdGFBdHRyaWJ1dGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gVSh0LmdldEF0dHJpYnV0ZShcImRhdGEtYnMtXCIrRihlKSkpfSxvZmZzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57dG9wOmUudG9wK2RvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLGxlZnQ6ZS5sZWZ0K2RvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdH19LHBvc2l0aW9uOmZ1bmN0aW9uKHQpe3JldHVybnt0b3A6dC5vZmZzZXRUb3AsbGVmdDp0Lm9mZnNldExlZnR9fX0scT17bWF0Y2hlczpmdW5jdGlvbih0LGUpe3JldHVybiB0Lm1hdGNoZXMoZSl9LGZpbmQ6ZnVuY3Rpb24odCxlKXt2YXIgbjtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSwobj1bXSkuY29uY2F0LmFwcGx5KG4sRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKGUsdCkpfSxmaW5kT25lOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCksRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKGUsdCl9LGNoaWxkcmVuOmZ1bmN0aW9uKHQsZSl7dmFyIG4saT0obj1bXSkuY29uY2F0LmFwcGx5KG4sdC5jaGlsZHJlbik7cmV0dXJuIGkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXRjaGVzKGUpfSkpfSxwYXJlbnRzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLGk9dC5wYXJlbnROb2RlO2kmJmkubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmMyE9PWkubm9kZVR5cGU7KXRoaXMubWF0Y2hlcyhpLGUpJiZuLnB1c2goaSksaT1pLnBhcmVudE5vZGU7cmV0dXJuIG59LHByZXY6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO247KXtpZihuLm1hdGNoZXMoZSkpcmV0dXJuW25dO249bi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nfXJldHVybltdfSxuZXh0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQubmV4dEVsZW1lbnRTaWJsaW5nO247KXtpZih0aGlzLm1hdGNoZXMobixlKSlyZXR1cm5bbl07bj1uLm5leHRFbGVtZW50U2libGluZ31yZXR1cm5bXX19LHo9XCJjYXJvdXNlbFwiLFY9XCIuYnMuY2Fyb3VzZWxcIixYPXtpbnRlcnZhbDo1ZTMsa2V5Ym9hcmQ6ITAsc2xpZGU6ITEscGF1c2U6XCJob3ZlclwiLHdyYXA6ITAsdG91Y2g6ITB9LCQ9e2ludGVydmFsOlwiKG51bWJlcnxib29sZWFuKVwiLGtleWJvYXJkOlwiYm9vbGVhblwiLHNsaWRlOlwiKGJvb2xlYW58c3RyaW5nKVwiLHBhdXNlOlwiKHN0cmluZ3xib29sZWFuKVwiLHdyYXA6XCJib29sZWFuXCIsdG91Y2g6XCJib29sZWFuXCJ9LEc9e1RPVUNIOlwidG91Y2hcIixQRU46XCJwZW5cIn0sWj1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLl9pdGVtcz1udWxsLGkuX2ludGVydmFsPW51bGwsaS5fYWN0aXZlRWxlbWVudD1udWxsLGkuX2lzUGF1c2VkPSExLGkuX2lzU2xpZGluZz0hMSxpLnRvdWNoVGltZW91dD1udWxsLGkudG91Y2hTdGFydFg9MCxpLnRvdWNoRGVsdGFYPTAsaS5fY29uZmlnPWkuX2dldENvbmZpZyhuKSxpLl9pbmRpY2F0b3JzRWxlbWVudD1xLmZpbmRPbmUoXCIuY2Fyb3VzZWwtaW5kaWNhdG9yc1wiLGkuX2VsZW1lbnQpLGkuX3RvdWNoU3VwcG9ydGVkPVwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cz4wLGkuX3BvaW50ZXJFdmVudD1Cb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpLGkuX2FkZEV2ZW50TGlzdGVuZXJzKCksaX1pKG8sdCk7dmFyIHI9by5wcm90b3R5cGU7cmV0dXJuIHIubmV4dD1mdW5jdGlvbigpe3RoaXMuX2lzU2xpZGluZ3x8dGhpcy5fc2xpZGUoXCJuZXh0XCIpfSxyLm5leHRXaGVuVmlzaWJsZT1mdW5jdGlvbigpeyFkb2N1bWVudC5oaWRkZW4mJmcodGhpcy5fZWxlbWVudCkmJnRoaXMubmV4dCgpfSxyLnByZXY9ZnVuY3Rpb24oKXt0aGlzLl9pc1NsaWRpbmd8fHRoaXMuX3NsaWRlKFwicHJldlwiKX0sci5wYXVzZT1mdW5jdGlvbih0KXt0fHwodGhpcy5faXNQYXVzZWQ9ITApLHEuZmluZE9uZShcIi5jYXJvdXNlbC1pdGVtLW5leHQsIC5jYXJvdXNlbC1pdGVtLXByZXZcIix0aGlzLl9lbGVtZW50KSYmKGYodGhpcy5fZWxlbWVudCksdGhpcy5jeWNsZSghMCkpLGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLHRoaXMuX2ludGVydmFsPW51bGx9LHIuY3ljbGU9ZnVuY3Rpb24odCl7dHx8KHRoaXMuX2lzUGF1c2VkPSExKSx0aGlzLl9pbnRlcnZhbCYmKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLHRoaXMuX2ludGVydmFsPW51bGwpLHRoaXMuX2NvbmZpZyYmdGhpcy5fY29uZmlnLmludGVydmFsJiYhdGhpcy5faXNQYXVzZWQmJih0aGlzLl91cGRhdGVJbnRlcnZhbCgpLHRoaXMuX2ludGVydmFsPXNldEludGVydmFsKChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU/dGhpcy5uZXh0V2hlblZpc2libGU6dGhpcy5uZXh0KS5iaW5kKHRoaXMpLHRoaXMuX2NvbmZpZy5pbnRlcnZhbCkpfSxyLnRvPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5fYWN0aXZlRWxlbWVudD1xLmZpbmRPbmUoXCIuYWN0aXZlLmNhcm91c2VsLWl0ZW1cIix0aGlzLl9lbGVtZW50KTt2YXIgbj10aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7aWYoISh0PnRoaXMuX2l0ZW1zLmxlbmd0aC0xfHx0PDApKWlmKHRoaXMuX2lzU2xpZGluZylILm9uZSh0aGlzLl9lbGVtZW50LFwic2xpZC5icy5jYXJvdXNlbFwiLChmdW5jdGlvbigpe3JldHVybiBlLnRvKHQpfSkpO2Vsc2V7aWYobj09PXQpcmV0dXJuIHRoaXMucGF1c2UoKSx2b2lkIHRoaXMuY3ljbGUoKTt2YXIgaT10Pm4/XCJuZXh0XCI6XCJwcmV2XCI7dGhpcy5fc2xpZGUoaSx0aGlzLl9pdGVtc1t0XSl9fSxyLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksSC5vZmYodGhpcy5fZWxlbWVudCxWKSx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX2NvbmZpZz1udWxsLHRoaXMuX2ludGVydmFsPW51bGwsdGhpcy5faXNQYXVzZWQ9bnVsbCx0aGlzLl9pc1NsaWRpbmc9bnVsbCx0aGlzLl9hY3RpdmVFbGVtZW50PW51bGwsdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQ9bnVsbH0sci5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe3JldHVybiB0PW4oe30sWCx0KSxwKHosdCwkKSx0fSxyLl9oYW5kbGVTd2lwZT1mdW5jdGlvbigpe3ZhciB0PU1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpO2lmKCEodDw9NDApKXt2YXIgZT10L3RoaXMudG91Y2hEZWx0YVg7dGhpcy50b3VjaERlbHRhWD0wLGU+MCYmdGhpcy5wcmV2KCksZTwwJiZ0aGlzLm5leHQoKX19LHIuX2FkZEV2ZW50TGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9jb25maWcua2V5Ym9hcmQmJkgub24odGhpcy5fZWxlbWVudCxcImtleWRvd24uYnMuY2Fyb3VzZWxcIiwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuX2tleWRvd24oZSl9KSksXCJob3ZlclwiPT09dGhpcy5fY29uZmlnLnBhdXNlJiYoSC5vbih0aGlzLl9lbGVtZW50LFwibW91c2VlbnRlci5icy5jYXJvdXNlbFwiLChmdW5jdGlvbihlKXtyZXR1cm4gdC5wYXVzZShlKX0pKSxILm9uKHRoaXMuX2VsZW1lbnQsXCJtb3VzZWxlYXZlLmJzLmNhcm91c2VsXCIsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmN5Y2xlKGUpfSkpKSx0aGlzLl9jb25maWcudG91Y2gmJnRoaXMuX3RvdWNoU3VwcG9ydGVkJiZ0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCl9LHIuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oZSl7dC5fcG9pbnRlckV2ZW50JiZHW2UucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0/dC50b3VjaFN0YXJ0WD1lLmNsaWVudFg6dC5fcG9pbnRlckV2ZW50fHwodC50b3VjaFN0YXJ0WD1lLnRvdWNoZXNbMF0uY2xpZW50WCl9LG49ZnVuY3Rpb24oZSl7dC5fcG9pbnRlckV2ZW50JiZHW2UucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0mJih0LnRvdWNoRGVsdGFYPWUuY2xpZW50WC10LnRvdWNoU3RhcnRYKSx0Ll9oYW5kbGVTd2lwZSgpLFwiaG92ZXJcIj09PXQuX2NvbmZpZy5wYXVzZSYmKHQucGF1c2UoKSx0LnRvdWNoVGltZW91dCYmY2xlYXJUaW1lb3V0KHQudG91Y2hUaW1lb3V0KSx0LnRvdWNoVGltZW91dD1zZXRUaW1lb3V0KChmdW5jdGlvbihlKXtyZXR1cm4gdC5jeWNsZShlKX0pLDUwMCt0Ll9jb25maWcuaW50ZXJ2YWwpKX07cS5maW5kKFwiLmNhcm91c2VsLWl0ZW0gaW1nXCIsdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7SC5vbih0LFwiZHJhZ3N0YXJ0LmJzLmNhcm91c2VsXCIsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnByZXZlbnREZWZhdWx0KCl9KSl9KSksdGhpcy5fcG9pbnRlckV2ZW50PyhILm9uKHRoaXMuX2VsZW1lbnQsXCJwb2ludGVyZG93bi5icy5jYXJvdXNlbFwiLChmdW5jdGlvbih0KXtyZXR1cm4gZSh0KX0pKSxILm9uKHRoaXMuX2VsZW1lbnQsXCJwb2ludGVydXAuYnMuY2Fyb3VzZWxcIiwoZnVuY3Rpb24odCl7cmV0dXJuIG4odCl9KSksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9pbnRlci1ldmVudFwiKSk6KEgub24odGhpcy5fZWxlbWVudCxcInRvdWNoc3RhcnQuYnMuY2Fyb3VzZWxcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGUodCl9KSksSC5vbih0aGlzLl9lbGVtZW50LFwidG91Y2htb3ZlLmJzLmNhcm91c2VsXCIsKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXtlLnRvdWNoZXMmJmUudG91Y2hlcy5sZW5ndGg+MT90LnRvdWNoRGVsdGFYPTA6dC50b3VjaERlbHRhWD1lLnRvdWNoZXNbMF0uY2xpZW50WC10LnRvdWNoU3RhcnRYfShlKX0pKSxILm9uKHRoaXMuX2VsZW1lbnQsXCJ0b3VjaGVuZC5icy5jYXJvdXNlbFwiLChmdW5jdGlvbih0KXtyZXR1cm4gbih0KX0pKSl9LHIuX2tleWRvd249ZnVuY3Rpb24odCl7aWYoIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpc3dpdGNoKHQua2V5KXtjYXNlXCJBcnJvd0xlZnRcIjp0LnByZXZlbnREZWZhdWx0KCksdGhpcy5wcmV2KCk7YnJlYWs7Y2FzZVwiQXJyb3dSaWdodFwiOnQucHJldmVudERlZmF1bHQoKSx0aGlzLm5leHQoKX19LHIuX2dldEl0ZW1JbmRleD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faXRlbXM9dCYmdC5wYXJlbnROb2RlP3EuZmluZChcIi5jYXJvdXNlbC1pdGVtXCIsdC5wYXJlbnROb2RlKTpbXSx0aGlzLl9pdGVtcy5pbmRleE9mKHQpfSxyLl9nZXRJdGVtQnlEaXJlY3Rpb249ZnVuY3Rpb24odCxlKXt2YXIgbj1cIm5leHRcIj09PXQsaT1cInByZXZcIj09PXQsbz10aGlzLl9nZXRJdGVtSW5kZXgoZSkscj10aGlzLl9pdGVtcy5sZW5ndGgtMTtpZigoaSYmMD09PW98fG4mJm89PT1yKSYmIXRoaXMuX2NvbmZpZy53cmFwKXJldHVybiBlO3ZhciBzPShvKyhcInByZXZcIj09PXQ/LTE6MSkpJXRoaXMuX2l0ZW1zLmxlbmd0aDtyZXR1cm4tMT09PXM/dGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoLTFdOnRoaXMuX2l0ZW1zW3NdfSxyLl90cmlnZ2VyU2xpZGVFdmVudD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2dldEl0ZW1JbmRleCh0KSxpPXRoaXMuX2dldEl0ZW1JbmRleChxLmZpbmRPbmUoXCIuYWN0aXZlLmNhcm91c2VsLWl0ZW1cIix0aGlzLl9lbGVtZW50KSk7cmV0dXJuIEgudHJpZ2dlcih0aGlzLl9lbGVtZW50LFwic2xpZGUuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDp0LGRpcmVjdGlvbjplLGZyb206aSx0bzpufSl9LHIuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpe2Zvcih2YXIgZT1xLmZpbmQoXCIuYWN0aXZlXCIsdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpLG49MDtuPGUubGVuZ3RoO24rKyllW25dLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7dmFyIGk9dGhpcy5faW5kaWNhdG9yc0VsZW1lbnQuY2hpbGRyZW5bdGhpcy5fZ2V0SXRlbUluZGV4KHQpXTtpJiZpLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIil9fSxyLl91cGRhdGVJbnRlcnZhbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2FjdGl2ZUVsZW1lbnR8fHEuZmluZE9uZShcIi5hY3RpdmUuY2Fyb3VzZWwtaXRlbVwiLHRoaXMuX2VsZW1lbnQpO2lmKHQpe3ZhciBlPU51bWJlci5wYXJzZUludCh0LmdldEF0dHJpYnV0ZShcImRhdGEtYnMtaW50ZXJ2YWxcIiksMTApO2U/KHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw9dGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbHx8dGhpcy5fY29uZmlnLmludGVydmFsLHRoaXMuX2NvbmZpZy5pbnRlcnZhbD1lKTp0aGlzLl9jb25maWcuaW50ZXJ2YWw9dGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbHx8dGhpcy5fY29uZmlnLmludGVydmFsfX0sci5fc2xpZGU9ZnVuY3Rpb24odCxlKXt2YXIgbixpLG8scj10aGlzLHM9cS5maW5kT25lKFwiLmFjdGl2ZS5jYXJvdXNlbC1pdGVtXCIsdGhpcy5fZWxlbWVudCksYT10aGlzLl9nZXRJdGVtSW5kZXgocyksbD1lfHxzJiZ0aGlzLl9nZXRJdGVtQnlEaXJlY3Rpb24odCxzKSxjPXRoaXMuX2dldEl0ZW1JbmRleChsKSxmPUJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO2lmKFwibmV4dFwiPT09dD8obj1cImNhcm91c2VsLWl0ZW0tc3RhcnRcIixpPVwiY2Fyb3VzZWwtaXRlbS1uZXh0XCIsbz1cImxlZnRcIik6KG49XCJjYXJvdXNlbC1pdGVtLWVuZFwiLGk9XCJjYXJvdXNlbC1pdGVtLXByZXZcIixvPVwicmlnaHRcIiksbCYmbC5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpdGhpcy5faXNTbGlkaW5nPSExO2Vsc2UgaWYoIXRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KGwsbykuZGVmYXVsdFByZXZlbnRlZCYmcyYmbCl7aWYodGhpcy5faXNTbGlkaW5nPSEwLGYmJnRoaXMucGF1c2UoKSx0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGwpLHRoaXMuX2FjdGl2ZUVsZW1lbnQ9bCx0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInNsaWRlXCIpKXtsLmNsYXNzTGlzdC5hZGQoaSksdihsKSxzLmNsYXNzTGlzdC5hZGQobiksbC5jbGFzc0xpc3QuYWRkKG4pO3ZhciBkPXUocyk7SC5vbmUocyxcInRyYW5zaXRpb25lbmRcIiwoZnVuY3Rpb24oKXtsLmNsYXNzTGlzdC5yZW1vdmUobixpKSxsLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIikscy5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIsaSxuKSxyLl9pc1NsaWRpbmc9ITEsc2V0VGltZW91dCgoZnVuY3Rpb24oKXtILnRyaWdnZXIoci5fZWxlbWVudCxcInNsaWQuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDpsLGRpcmVjdGlvbjpvLGZyb206YSx0bzpjfSl9KSwwKX0pKSxoKHMsZCl9ZWxzZSBzLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIiksbC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpLHRoaXMuX2lzU2xpZGluZz0hMSxILnRyaWdnZXIodGhpcy5fZWxlbWVudCxcInNsaWQuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDpsLGRpcmVjdGlvbjpvLGZyb206YSx0bzpjfSk7ZiYmdGhpcy5jeWNsZSgpfX0sby5jYXJvdXNlbEludGVyZmFjZT1mdW5jdGlvbih0LGUpe3ZhciBpPVQodCxcImJzLmNhcm91c2VsXCIpLHI9bih7fSxYLFkuZ2V0RGF0YUF0dHJpYnV0ZXModCkpO1wib2JqZWN0XCI9PXR5cGVvZiBlJiYocj1uKHt9LHIsZSkpO3ZhciBzPVwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ci5zbGlkZTtpZihpfHwoaT1uZXcgbyh0LHIpKSxcIm51bWJlclwiPT10eXBlb2YgZSlpLnRvKGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHMpe2lmKHZvaWQgMD09PWlbc10pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytzKydcIicpO2lbc10oKX1lbHNlIHIuaW50ZXJ2YWwmJnIucmlkZSYmKGkucGF1c2UoKSxpLmN5Y2xlKCkpfSxvLmpRdWVyeUludGVyZmFjZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoKChmdW5jdGlvbigpe28uY2Fyb3VzZWxJbnRlcmZhY2UodGhpcyx0KX0pKX0sby5kYXRhQXBpQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPWModGhpcyk7aWYoZSYmZS5jbGFzc0xpc3QuY29udGFpbnMoXCJjYXJvdXNlbFwiKSl7dmFyIGk9bih7fSxZLmdldERhdGFBdHRyaWJ1dGVzKGUpLFkuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcykpLHI9dGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJzLXNsaWRlLXRvXCIpO3ImJihpLmludGVydmFsPSExKSxvLmNhcm91c2VsSW50ZXJmYWNlKGUsaSksciYmVChlLFwiYnMuY2Fyb3VzZWxcIikudG8ociksdC5wcmV2ZW50RGVmYXVsdCgpfX0sZShvLG51bGwsW3trZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFh9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLmNhcm91c2VsXCJ9fV0pLG99KFIpO0gub24oZG9jdW1lbnQsXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b11cIixaLmRhdGFBcGlDbGlja0hhbmRsZXIpLEgub24od2luZG93LFwibG9hZC5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLChmdW5jdGlvbigpe2Zvcih2YXIgdD1xLmZpbmQoJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXScpLGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspWi5jYXJvdXNlbEludGVyZmFjZSh0W2VdLFQodFtlXSxcImJzLmNhcm91c2VsXCIpKX0pKSxiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuW3pdO3QuZm5bel09Wi5qUXVlcnlJbnRlcmZhY2UsdC5mblt6XS5Db25zdHJ1Y3Rvcj1aLHQuZm5bel0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB0LmZuW3pdPWUsWi5qUXVlcnlJbnRlcmZhY2V9fX0pKTt2YXIgSj1cImNvbGxhcHNlXCIsdHQ9e3RvZ2dsZTohMCxwYXJlbnQ6XCJcIn0sZXQ9e3RvZ2dsZTpcImJvb2xlYW5cIixwYXJlbnQ6XCIoc3RyaW5nfGVsZW1lbnQpXCJ9LG50PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuKXt2YXIgaTsoaT10LmNhbGwodGhpcyxlKXx8dGhpcykuX2lzVHJhbnNpdGlvbmluZz0hMSxpLl9jb25maWc9aS5fZ2V0Q29uZmlnKG4pLGkuX3RyaWdnZXJBcnJheT1xLmZpbmQoJ1tkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJytlLmlkKydcIl0sW2RhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1icy10YXJnZXQ9XCIjJytlLmlkKydcIl0nKTtmb3IodmFyIG89cS5maW5kKCdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXScpLHI9MCxzPW8ubGVuZ3RoO3I8cztyKyspe3ZhciBhPW9bcl0sYz1sKGEpLHU9cS5maW5kKGMpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lfSkpO251bGwhPT1jJiZ1Lmxlbmd0aCYmKGkuX3NlbGVjdG9yPWMsaS5fdHJpZ2dlckFycmF5LnB1c2goYSkpfXJldHVybiBpLl9wYXJlbnQ9aS5fY29uZmlnLnBhcmVudD9pLl9nZXRQYXJlbnQoKTpudWxsLGkuX2NvbmZpZy5wYXJlbnR8fGkuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhpLl9lbGVtZW50LGkuX3RyaWdnZXJBcnJheSksaS5fY29uZmlnLnRvZ2dsZSYmaS50b2dnbGUoKSxpfWkobyx0KTt2YXIgcj1vLnByb3RvdHlwZTtyZXR1cm4gci50b2dnbGU9ZnVuY3Rpb24oKXt0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIik/dGhpcy5oaWRlKCk6dGhpcy5zaG93KCl9LHIuc2hvdz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuX2lzVHJhbnNpdGlvbmluZyYmIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSl7dmFyIGUsbjt0aGlzLl9wYXJlbnQmJjA9PT0oZT1xLmZpbmQoXCIuc2hvdywgLmNvbGxhcHNpbmdcIix0aGlzLl9wYXJlbnQpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQuX2NvbmZpZy5wYXJlbnQ/ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJzLXBhcmVudFwiKT09PXQuX2NvbmZpZy5wYXJlbnQ6ZS5jbGFzc0xpc3QuY29udGFpbnMoXCJjb2xsYXBzZVwiKX0pKSkubGVuZ3RoJiYoZT1udWxsKTt2YXIgaT1xLmZpbmRPbmUodGhpcy5fc2VsZWN0b3IpO2lmKGUpe3ZhciByPWUuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIGkhPT10fSkpO2lmKChuPXI/VChyLFwiYnMuY29sbGFwc2VcIik6bnVsbCkmJm4uX2lzVHJhbnNpdGlvbmluZylyZXR1cm59aWYoIUgudHJpZ2dlcih0aGlzLl9lbGVtZW50LFwic2hvdy5icy5jb2xsYXBzZVwiKS5kZWZhdWx0UHJldmVudGVkKXtlJiZlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2khPT10JiZvLmNvbGxhcHNlSW50ZXJmYWNlKHQsXCJoaWRlXCIpLG58fEUodCxcImJzLmNvbGxhcHNlXCIsbnVsbCl9KSk7dmFyIHM9dGhpcy5fZ2V0RGltZW5zaW9uKCk7dGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiY29sbGFwc2VcIiksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29sbGFwc2luZ1wiKSx0aGlzLl9lbGVtZW50LnN0eWxlW3NdPTAsdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCYmdGhpcy5fdHJpZ2dlckFycmF5LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QuY2xhc3NMaXN0LnJlbW92ZShcImNvbGxhcHNlZFwiKSx0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwhMCl9KSksdGhpcy5zZXRUcmFuc2l0aW9uaW5nKCEwKTt2YXIgYT1cInNjcm9sbFwiKyhzWzBdLnRvVXBwZXJDYXNlKCkrcy5zbGljZSgxKSksbD11KHRoaXMuX2VsZW1lbnQpO0gub25lKHRoaXMuX2VsZW1lbnQsXCJ0cmFuc2l0aW9uZW5kXCIsKGZ1bmN0aW9uKCl7dC5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiY29sbGFwc2luZ1wiKSx0Ll9lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb2xsYXBzZVwiLFwic2hvd1wiKSx0Ll9lbGVtZW50LnN0eWxlW3NdPVwiXCIsdC5zZXRUcmFuc2l0aW9uaW5nKCExKSxILnRyaWdnZXIodC5fZWxlbWVudCxcInNob3duLmJzLmNvbGxhcHNlXCIpfSkpLGgodGhpcy5fZWxlbWVudCxsKSx0aGlzLl9lbGVtZW50LnN0eWxlW3NdPXRoaXMuX2VsZW1lbnRbYV0rXCJweFwifX19LHIuaGlkZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuX2lzVHJhbnNpdGlvbmluZyYmdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpJiYhSC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsXCJoaWRlLmJzLmNvbGxhcHNlXCIpLmRlZmF1bHRQcmV2ZW50ZWQpe3ZhciBlPXRoaXMuX2dldERpbWVuc2lvbigpO3RoaXMuX2VsZW1lbnQuc3R5bGVbZV09dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtlXStcInB4XCIsdih0aGlzLl9lbGVtZW50KSx0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb2xsYXBzaW5nXCIpLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImNvbGxhcHNlXCIsXCJzaG93XCIpO3ZhciBuPXRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7aWYobj4wKWZvcih2YXIgaT0wO2k8bjtpKyspe3ZhciBvPXRoaXMuX3RyaWdnZXJBcnJheVtpXSxyPWMobyk7ciYmIXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSYmKG8uY2xhc3NMaXN0LmFkZChcImNvbGxhcHNlZFwiKSxvLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwhMSkpfXRoaXMuc2V0VHJhbnNpdGlvbmluZyghMCk7dGhpcy5fZWxlbWVudC5zdHlsZVtlXT1cIlwiO3ZhciBzPXUodGhpcy5fZWxlbWVudCk7SC5vbmUodGhpcy5fZWxlbWVudCxcInRyYW5zaXRpb25lbmRcIiwoZnVuY3Rpb24oKXt0LnNldFRyYW5zaXRpb25pbmcoITEpLHQuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImNvbGxhcHNpbmdcIiksdC5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29sbGFwc2VcIiksSC50cmlnZ2VyKHQuX2VsZW1lbnQsXCJoaWRkZW4uYnMuY29sbGFwc2VcIil9KSksaCh0aGlzLl9lbGVtZW50LHMpfX0sci5zZXRUcmFuc2l0aW9uaW5nPWZ1bmN0aW9uKHQpe3RoaXMuX2lzVHJhbnNpdGlvbmluZz10fSxyLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fY29uZmlnPW51bGwsdGhpcy5fcGFyZW50PW51bGwsdGhpcy5fdHJpZ2dlckFycmF5PW51bGwsdGhpcy5faXNUcmFuc2l0aW9uaW5nPW51bGx9LHIuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4odD1uKHt9LHR0LHQpKS50b2dnbGU9Qm9vbGVhbih0LnRvZ2dsZSkscChKLHQsZXQpLHR9LHIuX2dldERpbWVuc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcIndpZHRoXCIpP1wid2lkdGhcIjpcImhlaWdodFwifSxyLl9nZXRQYXJlbnQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5fY29uZmlnLnBhcmVudDtkKGUpP3ZvaWQgMD09PWUuanF1ZXJ5JiZ2b2lkIDA9PT1lWzBdfHwoZT1lWzBdKTplPXEuZmluZE9uZShlKTt2YXIgbj0nW2RhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1icy1wYXJlbnQ9XCInK2UrJ1wiXSc7cmV0dXJuIHEuZmluZChuLGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWMoZSk7dC5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKG4sW2VdKX0pKSxlfSxyLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3M9ZnVuY3Rpb24odCxlKXtpZih0JiZlLmxlbmd0aCl7dmFyIG49dC5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpO2UuZm9yRWFjaCgoZnVuY3Rpb24odCl7bj90LmNsYXNzTGlzdC5yZW1vdmUoXCJjb2xsYXBzZWRcIik6dC5jbGFzc0xpc3QuYWRkKFwiY29sbGFwc2VkXCIpLHQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLG4pfSkpfX0sby5jb2xsYXBzZUludGVyZmFjZT1mdW5jdGlvbih0LGUpe3ZhciBpPVQodCxcImJzLmNvbGxhcHNlXCIpLHI9bih7fSx0dCxZLmdldERhdGFBdHRyaWJ1dGVzKHQpLFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlP2U6e30pO2lmKCFpJiZyLnRvZ2dsZSYmXCJzdHJpbmdcIj09dHlwZW9mIGUmJi9zaG93fGhpZGUvLnRlc3QoZSkmJihyLnRvZ2dsZT0hMSksaXx8KGk9bmV3IG8odCxyKSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKHZvaWQgMD09PWlbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytlKydcIicpO2lbZV0oKX19LG8ualF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVhY2goKGZ1bmN0aW9uKCl7by5jb2xsYXBzZUludGVyZmFjZSh0aGlzLHQpfSkpfSxlKG8sbnVsbCxbe2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdHR9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLmNvbGxhcHNlXCJ9fV0pLG99KFIpO0gub24oZG9jdW1lbnQsXCJjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaVwiLCdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXScsKGZ1bmN0aW9uKHQpe1wiQVwiPT09dC50YXJnZXQudGFnTmFtZSYmdC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBlPVkuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcyksbj1sKHRoaXMpO3EuZmluZChuKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbixpPVQodCxcImJzLmNvbGxhcHNlXCIpO2k/KG51bGw9PT1pLl9wYXJlbnQmJlwic3RyaW5nXCI9PXR5cGVvZiBlLnBhcmVudCYmKGkuX2NvbmZpZy5wYXJlbnQ9ZS5wYXJlbnQsaS5fcGFyZW50PWkuX2dldFBhcmVudCgpKSxuPVwidG9nZ2xlXCIpOm49ZSxudC5jb2xsYXBzZUludGVyZmFjZSh0LG4pfSkpfSkpLGIoKGZ1bmN0aW9uKCl7dmFyIHQ9XygpO2lmKHQpe3ZhciBlPXQuZm5bSl07dC5mbltKXT1udC5qUXVlcnlJbnRlcmZhY2UsdC5mbltKXS5Db25zdHJ1Y3Rvcj1udCx0LmZuW0pdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5mbltKXT1lLG50LmpRdWVyeUludGVyZmFjZX19fSkpO3ZhciBpdD1cInRvcFwiLG90PVwiYm90dG9tXCIscnQ9XCJyaWdodFwiLHN0PVwibGVmdFwiLGF0PVtpdCxvdCxydCxzdF0sbHQ9YXQucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbmNhdChbZStcIi1zdGFydFwiLGUrXCItZW5kXCJdKX0pLFtdKSxjdD1bXS5jb25jYXQoYXQsW1wiYXV0b1wiXSkucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbmNhdChbZSxlK1wiLXN0YXJ0XCIsZStcIi1lbmRcIl0pfSksW10pLHV0PVtcImJlZm9yZVJlYWRcIixcInJlYWRcIixcImFmdGVyUmVhZFwiLFwiYmVmb3JlTWFpblwiLFwibWFpblwiLFwiYWZ0ZXJNYWluXCIsXCJiZWZvcmVXcml0ZVwiLFwid3JpdGVcIixcImFmdGVyV3JpdGVcIl07ZnVuY3Rpb24gZnQodCl7cmV0dXJuIHQ/KHQubm9kZU5hbWV8fFwiXCIpLnRvTG93ZXJDYXNlKCk6bnVsbH1mdW5jdGlvbiBkdCh0KXtpZihcIltvYmplY3QgV2luZG93XVwiIT09dC50b1N0cmluZygpKXt2YXIgZT10Lm93bmVyRG9jdW1lbnQ7cmV0dXJuIGUmJmUuZGVmYXVsdFZpZXd8fHdpbmRvd31yZXR1cm4gdH1mdW5jdGlvbiBodCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGR0KHQpLkVsZW1lbnR8fHQgaW5zdGFuY2VvZiBFbGVtZW50fWZ1bmN0aW9uIHB0KHQpe3JldHVybiB0IGluc3RhbmNlb2YgZHQodCkuSFRNTEVsZW1lbnR8fHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudH12YXIgZ3Q9e25hbWU6XCJhcHBseVN0eWxlc1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJ3cml0ZVwiLGZuOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGU7T2JqZWN0LmtleXMoZS5lbGVtZW50cykuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49ZS5zdHlsZXNbdF18fHt9LGk9ZS5hdHRyaWJ1dGVzW3RdfHx7fSxvPWUuZWxlbWVudHNbdF07cHQobykmJmZ0KG8pJiYoT2JqZWN0LmFzc2lnbihvLnN0eWxlLG4pLE9iamVjdC5rZXlzKGkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWlbdF07ITE9PT1lP28ucmVtb3ZlQXR0cmlidXRlKHQpOm8uc2V0QXR0cmlidXRlKHQsITA9PT1lP1wiXCI6ZSl9KSkpfSkpfSxlZmZlY3Q6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXtwb3BwZXI6e3Bvc2l0aW9uOmUub3B0aW9ucy5zdHJhdGVneSxsZWZ0OlwiMFwiLHRvcDpcIjBcIixtYXJnaW46XCIwXCJ9LGFycm93Ontwb3NpdGlvbjpcImFic29sdXRlXCJ9LHJlZmVyZW5jZTp7fX07cmV0dXJuIE9iamVjdC5hc3NpZ24oZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsbi5wb3BwZXIpLGUuZWxlbWVudHMuYXJyb3cmJk9iamVjdC5hc3NpZ24oZS5lbGVtZW50cy5hcnJvdy5zdHlsZSxuLmFycm93KSxmdW5jdGlvbigpe09iamVjdC5rZXlzKGUuZWxlbWVudHMpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBpPWUuZWxlbWVudHNbdF0sbz1lLmF0dHJpYnV0ZXNbdF18fHt9LHI9T2JqZWN0LmtleXMoZS5zdHlsZXMuaGFzT3duUHJvcGVydHkodCk/ZS5zdHlsZXNbdF06blt0XSkucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0W2VdPVwiXCIsdH0pLHt9KTtwdChpKSYmZnQoaSkmJihPYmplY3QuYXNzaWduKGkuc3R5bGUsciksT2JqZWN0LmtleXMobykuZm9yRWFjaCgoZnVuY3Rpb24odCl7aS5yZW1vdmVBdHRyaWJ1dGUodCl9KSkpfSkpfX0scmVxdWlyZXM6W1wiY29tcHV0ZVN0eWxlc1wiXX07ZnVuY3Rpb24gbXQodCl7cmV0dXJuIHQuc3BsaXQoXCItXCIpWzBdfWZ1bmN0aW9uIHZ0KHQpe3JldHVybnt4OnQub2Zmc2V0TGVmdCx5OnQub2Zmc2V0VG9wLHdpZHRoOnQub2Zmc2V0V2lkdGgsaGVpZ2h0OnQub2Zmc2V0SGVpZ2h0fX1mdW5jdGlvbiBfdCh0LGUpe3ZhciBuLGk9ZS5nZXRSb290Tm9kZSYmZS5nZXRSb290Tm9kZSgpO2lmKHQuY29udGFpbnMoZSkpcmV0dXJuITA7aWYoaSYmKChuPWkpaW5zdGFuY2VvZiBkdChuKS5TaGFkb3dSb290fHxuIGluc3RhbmNlb2YgU2hhZG93Um9vdCkpe3ZhciBvPWU7ZG97aWYobyYmdC5pc1NhbWVOb2RlKG8pKXJldHVybiEwO289by5wYXJlbnROb2RlfHxvLmhvc3R9d2hpbGUobyl9cmV0dXJuITF9ZnVuY3Rpb24gYnQodCl7cmV0dXJuIGR0KHQpLmdldENvbXB1dGVkU3R5bGUodCl9ZnVuY3Rpb24geXQodCl7cmV0dXJuW1widGFibGVcIixcInRkXCIsXCJ0aFwiXS5pbmRleE9mKGZ0KHQpKT49MH1mdW5jdGlvbiB3dCh0KXtyZXR1cm4oKGh0KHQpP3Qub3duZXJEb2N1bWVudDp0LmRvY3VtZW50KXx8d2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnR9ZnVuY3Rpb24gRXQodCl7cmV0dXJuXCJodG1sXCI9PT1mdCh0KT90OnQuYXNzaWduZWRTbG90fHx0LnBhcmVudE5vZGV8fHQuaG9zdHx8d3QodCl9ZnVuY3Rpb24gVHQodCl7aWYoIXB0KHQpfHxcImZpeGVkXCI9PT1idCh0KS5wb3NpdGlvbilyZXR1cm4gbnVsbDt2YXIgZT10Lm9mZnNldFBhcmVudDtpZihlKXt2YXIgbj13dChlKTtpZihcImJvZHlcIj09PWZ0KGUpJiZcInN0YXRpY1wiPT09YnQoZSkucG9zaXRpb24mJlwic3RhdGljXCIhPT1idChuKS5wb3NpdGlvbilyZXR1cm4gbn1yZXR1cm4gZX1mdW5jdGlvbiBrdCh0KXtmb3IodmFyIGU9ZHQodCksbj1UdCh0KTtuJiZ5dChuKSYmXCJzdGF0aWNcIj09PWJ0KG4pLnBvc2l0aW9uOyluPVR0KG4pO3JldHVybiBuJiZcImJvZHlcIj09PWZ0KG4pJiZcInN0YXRpY1wiPT09YnQobikucG9zaXRpb24/ZTpufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9RXQodCk7cHQoZSkmJltcImh0bWxcIixcImJvZHlcIl0uaW5kZXhPZihmdChlKSk8MDspe3ZhciBuPWJ0KGUpO2lmKFwibm9uZVwiIT09bi50cmFuc2Zvcm18fFwibm9uZVwiIT09bi5wZXJzcGVjdGl2ZXx8bi53aWxsQ2hhbmdlJiZcImF1dG9cIiE9PW4ud2lsbENoYW5nZSlyZXR1cm4gZTtlPWUucGFyZW50Tm9kZX1yZXR1cm4gbnVsbH0odCl8fGV9ZnVuY3Rpb24gT3QodCl7cmV0dXJuW1widG9wXCIsXCJib3R0b21cIl0uaW5kZXhPZih0KT49MD9cInhcIjpcInlcIn1mdW5jdGlvbiBMdCh0LGUsbil7cmV0dXJuIE1hdGgubWF4KHQsTWF0aC5taW4oZSxuKSl9ZnVuY3Rpb24gQXQodCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx7dG9wOjAscmlnaHQ6MCxib3R0b206MCxsZWZ0OjB9KSx0KX1mdW5jdGlvbiBDdCh0LGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVtuXT10LGV9KSx7fSl9dmFyIER0PXtuYW1lOlwiYXJyb3dcIixlbmFibGVkOiEwLHBoYXNlOlwibWFpblwiLGZuOmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5zdGF0ZSxpPXQubmFtZSxvPW4uZWxlbWVudHMuYXJyb3cscj1uLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxzPW10KG4ucGxhY2VtZW50KSxhPU90KHMpLGw9W3N0LHJ0XS5pbmRleE9mKHMpPj0wP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiO2lmKG8mJnIpe3ZhciBjPW4ubW9kaWZpZXJzRGF0YVtpK1wiI3BlcnNpc3RlbnRcIl0ucGFkZGluZyx1PXZ0KG8pLGY9XCJ5XCI9PT1hP2l0OnN0LGQ9XCJ5XCI9PT1hP290OnJ0LGg9bi5yZWN0cy5yZWZlcmVuY2VbbF0rbi5yZWN0cy5yZWZlcmVuY2VbYV0tclthXS1uLnJlY3RzLnBvcHBlcltsXSxwPXJbYV0tbi5yZWN0cy5yZWZlcmVuY2VbYV0sZz1rdChvKSxtPWc/XCJ5XCI9PT1hP2cuY2xpZW50SGVpZ2h0fHwwOmcuY2xpZW50V2lkdGh8fDA6MCx2PWgvMi1wLzIsXz1jW2ZdLGI9bS11W2xdLWNbZF0seT1tLzItdVtsXS8yK3Ysdz1MdChfLHksYiksRT1hO24ubW9kaWZpZXJzRGF0YVtpXT0oKGU9e30pW0VdPXcsZS5jZW50ZXJPZmZzZXQ9dy15LGUpfX0sZWZmZWN0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj10Lm9wdGlvbnMsaT10Lm5hbWUsbz1uLmVsZW1lbnQscj12b2lkIDA9PT1vP1wiW2RhdGEtcG9wcGVyLWFycm93XVwiOm8scz1uLnBhZGRpbmcsYT12b2lkIDA9PT1zPzA6cztudWxsIT1yJiYoXCJzdHJpbmdcIiE9dHlwZW9mIHJ8fChyPWUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IocikpKSYmX3QoZS5lbGVtZW50cy5wb3BwZXIscikmJihlLmVsZW1lbnRzLmFycm93PXIsZS5tb2RpZmllcnNEYXRhW2krXCIjcGVyc2lzdGVudFwiXT17cGFkZGluZzpBdChcIm51bWJlclwiIT10eXBlb2YgYT9hOkN0KGEsYXQpKX0pfSxyZXF1aXJlczpbXCJwb3BwZXJPZmZzZXRzXCJdLHJlcXVpcmVzSWZFeGlzdHM6W1wicHJldmVudE92ZXJmbG93XCJdfSx4dD17dG9wOlwiYXV0b1wiLHJpZ2h0OlwiYXV0b1wiLGJvdHRvbTpcImF1dG9cIixsZWZ0OlwiYXV0b1wifTtmdW5jdGlvbiBTdCh0KXt2YXIgZSxuPXQucG9wcGVyLGk9dC5wb3BwZXJSZWN0LG89dC5wbGFjZW1lbnQscj10Lm9mZnNldHMscz10LnBvc2l0aW9uLGE9dC5ncHVBY2NlbGVyYXRpb24sbD10LmFkYXB0aXZlLGM9ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC55LGk9d2luZG93LmRldmljZVBpeGVsUmF0aW98fDE7cmV0dXJue3g6TWF0aC5yb3VuZChlKmkpL2l8fDAseTpNYXRoLnJvdW5kKG4qaSkvaXx8MH19KHIpLHU9Yy54LGY9Yy55LGQ9ci5oYXNPd25Qcm9wZXJ0eShcInhcIiksaD1yLmhhc093blByb3BlcnR5KFwieVwiKSxwPXN0LGc9aXQsbT13aW5kb3c7aWYobCl7dmFyIHY9a3Qobik7dj09PWR0KG4pJiYodj13dChuKSksbz09PWl0JiYoZz1vdCxmLT12LmNsaWVudEhlaWdodC1pLmhlaWdodCxmKj1hPzE6LTEpLG89PT1zdCYmKHA9cnQsdS09di5jbGllbnRXaWR0aC1pLndpZHRoLHUqPWE/MTotMSl9dmFyIF8sYj1PYmplY3QuYXNzaWduKHtwb3NpdGlvbjpzfSxsJiZ4dCk7cmV0dXJuIGE/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGIpLHt9LCgoXz17fSlbZ109aD9cIjBcIjpcIlwiLF9bcF09ZD9cIjBcIjpcIlwiLF8udHJhbnNmb3JtPShtLmRldmljZVBpeGVsUmF0aW98fDEpPDI/XCJ0cmFuc2xhdGUoXCIrdStcInB4LCBcIitmK1wicHgpXCI6XCJ0cmFuc2xhdGUzZChcIit1K1wicHgsIFwiK2YrXCJweCwgMClcIixfKSk6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGIpLHt9LCgoZT17fSlbZ109aD9mK1wicHhcIjpcIlwiLGVbcF09ZD91K1wicHhcIjpcIlwiLGUudHJhbnNmb3JtPVwiXCIsZSkpfXZhciBqdD17bmFtZTpcImNvbXB1dGVTdHlsZXNcIixlbmFibGVkOiEwLHBoYXNlOlwiYmVmb3JlV3JpdGVcIixmbjpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlLG49dC5vcHRpb25zLGk9bi5ncHVBY2NlbGVyYXRpb24sbz12b2lkIDA9PT1pfHxpLHI9bi5hZGFwdGl2ZSxzPXZvaWQgMD09PXJ8fHIsYT17cGxhY2VtZW50Om10KGUucGxhY2VtZW50KSxwb3BwZXI6ZS5lbGVtZW50cy5wb3BwZXIscG9wcGVyUmVjdDplLnJlY3RzLnBvcHBlcixncHVBY2NlbGVyYXRpb246b307bnVsbCE9ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMmJihlLnN0eWxlcy5wb3BwZXI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUuc3R5bGVzLnBvcHBlciksU3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHt9LHtvZmZzZXRzOmUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLHBvc2l0aW9uOmUub3B0aW9ucy5zdHJhdGVneSxhZGFwdGl2ZTpzfSkpKSksbnVsbCE9ZS5tb2RpZmllcnNEYXRhLmFycm93JiYoZS5zdHlsZXMuYXJyb3c9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUuc3R5bGVzLmFycm93KSxTdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse30se29mZnNldHM6ZS5tb2RpZmllcnNEYXRhLmFycm93LHBvc2l0aW9uOlwiYWJzb2x1dGVcIixhZGFwdGl2ZTohMX0pKSkpLGUuYXR0cmlidXRlcy5wb3BwZXI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUuYXR0cmlidXRlcy5wb3BwZXIpLHt9LHtcImRhdGEtcG9wcGVyLXBsYWNlbWVudFwiOmUucGxhY2VtZW50fSl9LGRhdGE6e319LE50PXtwYXNzaXZlOiEwfTt2YXIgSXQ9e25hbWU6XCJldmVudExpc3RlbmVyc1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJ3cml0ZVwiLGZuOmZ1bmN0aW9uKCl7fSxlZmZlY3Q6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQuaW5zdGFuY2UsaT10Lm9wdGlvbnMsbz1pLnNjcm9sbCxyPXZvaWQgMD09PW98fG8scz1pLnJlc2l6ZSxhPXZvaWQgMD09PXN8fHMsbD1kdChlLmVsZW1lbnRzLnBvcHBlciksYz1bXS5jb25jYXQoZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSxlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtyZXR1cm4gciYmYy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixuLnVwZGF0ZSxOdCl9KSksYSYmbC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsbi51cGRhdGUsTnQpLGZ1bmN0aW9uKCl7ciYmYy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixuLnVwZGF0ZSxOdCl9KSksYSYmbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsbi51cGRhdGUsTnQpfX0sZGF0YTp7fX0sUHQ9e2xlZnQ6XCJyaWdodFwiLHJpZ2h0OlwibGVmdFwiLGJvdHRvbTpcInRvcFwiLHRvcDpcImJvdHRvbVwifTtmdW5jdGlvbiBNdCh0KXtyZXR1cm4gdC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywoZnVuY3Rpb24odCl7cmV0dXJuIFB0W3RdfSkpfXZhciBCdD17c3RhcnQ6XCJlbmRcIixlbmQ6XCJzdGFydFwifTtmdW5jdGlvbiBIdCh0KXtyZXR1cm4gdC5yZXBsYWNlKC9zdGFydHxlbmQvZywoZnVuY3Rpb24odCl7cmV0dXJuIEJ0W3RdfSkpfWZ1bmN0aW9uIFJ0KHQpe3ZhciBlPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3dpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0LHRvcDplLnRvcCxyaWdodDplLnJpZ2h0LGJvdHRvbTplLmJvdHRvbSxsZWZ0OmUubGVmdCx4OmUubGVmdCx5OmUudG9wfX1mdW5jdGlvbiBXdCh0KXt2YXIgZT1kdCh0KTtyZXR1cm57c2Nyb2xsTGVmdDplLnBhZ2VYT2Zmc2V0LHNjcm9sbFRvcDplLnBhZ2VZT2Zmc2V0fX1mdW5jdGlvbiBLdCh0KXtyZXR1cm4gUnQod3QodCkpLmxlZnQrV3QodCkuc2Nyb2xsTGVmdH1mdW5jdGlvbiBRdCh0KXt2YXIgZT1idCh0KSxuPWUub3ZlcmZsb3csaT1lLm92ZXJmbG93WCxvPWUub3ZlcmZsb3dZO3JldHVybi9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChuK28raSl9ZnVuY3Rpb24gVXQodCxlKXt2b2lkIDA9PT1lJiYoZT1bXSk7dmFyIG49ZnVuY3Rpb24gdChlKXtyZXR1cm5bXCJodG1sXCIsXCJib2R5XCIsXCIjZG9jdW1lbnRcIl0uaW5kZXhPZihmdChlKSk+PTA/ZS5vd25lckRvY3VtZW50LmJvZHk6cHQoZSkmJlF0KGUpP2U6dChFdChlKSl9KHQpLGk9XCJib2R5XCI9PT1mdChuKSxvPWR0KG4pLHI9aT9bb10uY29uY2F0KG8udmlzdWFsVmlld3BvcnR8fFtdLFF0KG4pP246W10pOm4scz1lLmNvbmNhdChyKTtyZXR1cm4gaT9zOnMuY29uY2F0KFV0KEV0KHIpKSl9ZnVuY3Rpb24gRnQodCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7fSx7bGVmdDp0LngsdG9wOnQueSxyaWdodDp0LngrdC53aWR0aCxib3R0b206dC55K3QuaGVpZ2h0fSl9ZnVuY3Rpb24gWXQodCxlKXtyZXR1cm5cInZpZXdwb3J0XCI9PT1lP0Z0KGZ1bmN0aW9uKHQpe3ZhciBlPWR0KHQpLG49d3QodCksaT1lLnZpc3VhbFZpZXdwb3J0LG89bi5jbGllbnRXaWR0aCxyPW4uY2xpZW50SGVpZ2h0LHM9MCxhPTA7cmV0dXJuIGkmJihvPWkud2lkdGgscj1pLmhlaWdodCwvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfHwocz1pLm9mZnNldExlZnQsYT1pLm9mZnNldFRvcCkpLHt3aWR0aDpvLGhlaWdodDpyLHg6cytLdCh0KSx5OmF9fSh0KSk6cHQoZSk/ZnVuY3Rpb24odCl7dmFyIGU9UnQodCk7cmV0dXJuIGUudG9wPWUudG9wK3QuY2xpZW50VG9wLGUubGVmdD1lLmxlZnQrdC5jbGllbnRMZWZ0LGUuYm90dG9tPWUudG9wK3QuY2xpZW50SGVpZ2h0LGUucmlnaHQ9ZS5sZWZ0K3QuY2xpZW50V2lkdGgsZS53aWR0aD10LmNsaWVudFdpZHRoLGUuaGVpZ2h0PXQuY2xpZW50SGVpZ2h0LGUueD1lLmxlZnQsZS55PWUudG9wLGV9KGUpOkZ0KGZ1bmN0aW9uKHQpe3ZhciBlPXd0KHQpLG49V3QodCksaT10Lm93bmVyRG9jdW1lbnQuYm9keSxvPU1hdGgubWF4KGUuc2Nyb2xsV2lkdGgsZS5jbGllbnRXaWR0aCxpP2kuc2Nyb2xsV2lkdGg6MCxpP2kuY2xpZW50V2lkdGg6MCkscj1NYXRoLm1heChlLnNjcm9sbEhlaWdodCxlLmNsaWVudEhlaWdodCxpP2kuc2Nyb2xsSGVpZ2h0OjAsaT9pLmNsaWVudEhlaWdodDowKSxzPS1uLnNjcm9sbExlZnQrS3QodCksYT0tbi5zY3JvbGxUb3A7cmV0dXJuXCJydGxcIj09PWJ0KGl8fGUpLmRpcmVjdGlvbiYmKHMrPU1hdGgubWF4KGUuY2xpZW50V2lkdGgsaT9pLmNsaWVudFdpZHRoOjApLW8pLHt3aWR0aDpvLGhlaWdodDpyLHg6cyx5OmF9fSh3dCh0KSkpfWZ1bmN0aW9uIHF0KHQsZSxuKXt2YXIgaT1cImNsaXBwaW5nUGFyZW50c1wiPT09ZT9mdW5jdGlvbih0KXt2YXIgZT1VdChFdCh0KSksbj1bXCJhYnNvbHV0ZVwiLFwiZml4ZWRcIl0uaW5kZXhPZihidCh0KS5wb3NpdGlvbik+PTAmJnB0KHQpP2t0KHQpOnQ7cmV0dXJuIGh0KG4pP2UuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gaHQodCkmJl90KHQsbikmJlwiYm9keVwiIT09ZnQodCl9KSk6W119KHQpOltdLmNvbmNhdChlKSxvPVtdLmNvbmNhdChpLFtuXSkscj1vWzBdLHM9by5yZWR1Y2UoKGZ1bmN0aW9uKGUsbil7dmFyIGk9WXQodCxuKTtyZXR1cm4gZS50b3A9TWF0aC5tYXgoaS50b3AsZS50b3ApLGUucmlnaHQ9TWF0aC5taW4oaS5yaWdodCxlLnJpZ2h0KSxlLmJvdHRvbT1NYXRoLm1pbihpLmJvdHRvbSxlLmJvdHRvbSksZS5sZWZ0PU1hdGgubWF4KGkubGVmdCxlLmxlZnQpLGV9KSxZdCh0LHIpKTtyZXR1cm4gcy53aWR0aD1zLnJpZ2h0LXMubGVmdCxzLmhlaWdodD1zLmJvdHRvbS1zLnRvcCxzLng9cy5sZWZ0LHMueT1zLnRvcCxzfWZ1bmN0aW9uIHp0KHQpe3JldHVybiB0LnNwbGl0KFwiLVwiKVsxXX1mdW5jdGlvbiBWdCh0KXt2YXIgZSxuPXQucmVmZXJlbmNlLGk9dC5lbGVtZW50LG89dC5wbGFjZW1lbnQscj1vP210KG8pOm51bGwscz1vP3p0KG8pOm51bGwsYT1uLngrbi53aWR0aC8yLWkud2lkdGgvMixsPW4ueStuLmhlaWdodC8yLWkuaGVpZ2h0LzI7c3dpdGNoKHIpe2Nhc2UgaXQ6ZT17eDphLHk6bi55LWkuaGVpZ2h0fTticmVhaztjYXNlIG90OmU9e3g6YSx5Om4ueStuLmhlaWdodH07YnJlYWs7Y2FzZSBydDplPXt4Om4ueCtuLndpZHRoLHk6bH07YnJlYWs7Y2FzZSBzdDplPXt4Om4ueC1pLndpZHRoLHk6bH07YnJlYWs7ZGVmYXVsdDplPXt4Om4ueCx5Om4ueX19dmFyIGM9cj9PdChyKTpudWxsO2lmKG51bGwhPWMpe3ZhciB1PVwieVwiPT09Yz9cImhlaWdodFwiOlwid2lkdGhcIjtzd2l0Y2gocyl7Y2FzZVwic3RhcnRcIjplW2NdPU1hdGguZmxvb3IoZVtjXSktTWF0aC5mbG9vcihuW3VdLzItaVt1XS8yKTticmVhaztjYXNlXCJlbmRcIjplW2NdPU1hdGguZmxvb3IoZVtjXSkrTWF0aC5jZWlsKG5bdV0vMi1pW3VdLzIpfX1yZXR1cm4gZX1mdW5jdGlvbiBYdCh0LGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgbj1lLGk9bi5wbGFjZW1lbnQsbz12b2lkIDA9PT1pP3QucGxhY2VtZW50Omkscj1uLmJvdW5kYXJ5LHM9dm9pZCAwPT09cj9cImNsaXBwaW5nUGFyZW50c1wiOnIsYT1uLnJvb3RCb3VuZGFyeSxsPXZvaWQgMD09PWE/XCJ2aWV3cG9ydFwiOmEsYz1uLmVsZW1lbnRDb250ZXh0LHU9dm9pZCAwPT09Yz9cInBvcHBlclwiOmMsZj1uLmFsdEJvdW5kYXJ5LGQ9dm9pZCAwIT09ZiYmZixoPW4ucGFkZGluZyxwPXZvaWQgMD09PWg/MDpoLGc9QXQoXCJudW1iZXJcIiE9dHlwZW9mIHA/cDpDdChwLGF0KSksbT1cInBvcHBlclwiPT09dT9cInJlZmVyZW5jZVwiOlwicG9wcGVyXCIsdj10LmVsZW1lbnRzLnJlZmVyZW5jZSxfPXQucmVjdHMucG9wcGVyLGI9dC5lbGVtZW50c1tkP206dV0seT1xdChodChiKT9iOmIuY29udGV4dEVsZW1lbnR8fHd0KHQuZWxlbWVudHMucG9wcGVyKSxzLGwpLHc9UnQodiksRT1WdCh7cmVmZXJlbmNlOncsZWxlbWVudDpfLHN0cmF0ZWd5OlwiYWJzb2x1dGVcIixwbGFjZW1lbnQ6b30pLFQ9RnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LF8pLEUpKSxrPVwicG9wcGVyXCI9PT11P1Q6dyxPPXt0b3A6eS50b3Atay50b3ArZy50b3AsYm90dG9tOmsuYm90dG9tLXkuYm90dG9tK2cuYm90dG9tLGxlZnQ6eS5sZWZ0LWsubGVmdCtnLmxlZnQscmlnaHQ6ay5yaWdodC15LnJpZ2h0K2cucmlnaHR9LEw9dC5tb2RpZmllcnNEYXRhLm9mZnNldDtpZihcInBvcHBlclwiPT09dSYmTCl7dmFyIEE9TFtvXTtPYmplY3Qua2V5cyhPKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1bcnQsb3RdLmluZGV4T2YodCk+PTA/MTotMSxuPVtpdCxvdF0uaW5kZXhPZih0KT49MD9cInlcIjpcInhcIjtPW3RdKz1BW25dKmV9KSl9cmV0dXJuIE99ZnVuY3Rpb24gJHQodCxlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIG49ZSxpPW4ucGxhY2VtZW50LG89bi5ib3VuZGFyeSxyPW4ucm9vdEJvdW5kYXJ5LHM9bi5wYWRkaW5nLGE9bi5mbGlwVmFyaWF0aW9ucyxsPW4uYWxsb3dlZEF1dG9QbGFjZW1lbnRzLGM9dm9pZCAwPT09bD9jdDpsLHU9enQoaSksZj11P2E/bHQ6bHQuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4genQodCk9PT11fSkpOmF0LGQ9Zi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBjLmluZGV4T2YodCk+PTB9KSk7MD09PWQubGVuZ3RoJiYoZD1mKTt2YXIgaD1kLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVtuXT1YdCh0LHtwbGFjZW1lbnQ6bixib3VuZGFyeTpvLHJvb3RCb3VuZGFyeTpyLHBhZGRpbmc6c30pW210KG4pXSxlfSkse30pO3JldHVybiBPYmplY3Qua2V5cyhoKS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBoW3RdLWhbZV19KSl9dmFyIEd0PXtuYW1lOlwiZmxpcFwiLGVuYWJsZWQ6ITAscGhhc2U6XCJtYWluXCIsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQub3B0aW9ucyxpPXQubmFtZTtpZighZS5tb2RpZmllcnNEYXRhW2ldLl9za2lwKXtmb3IodmFyIG89bi5tYWluQXhpcyxyPXZvaWQgMD09PW98fG8scz1uLmFsdEF4aXMsYT12b2lkIDA9PT1zfHxzLGw9bi5mYWxsYmFja1BsYWNlbWVudHMsYz1uLnBhZGRpbmcsdT1uLmJvdW5kYXJ5LGY9bi5yb290Qm91bmRhcnksZD1uLmFsdEJvdW5kYXJ5LGg9bi5mbGlwVmFyaWF0aW9ucyxwPXZvaWQgMD09PWh8fGgsZz1uLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxtPWUub3B0aW9ucy5wbGFjZW1lbnQsdj1tdChtKSxfPWx8fCh2PT09bXx8IXA/W010KG0pXTpmdW5jdGlvbih0KXtpZihcImF1dG9cIj09PW10KHQpKXJldHVybltdO3ZhciBlPU10KHQpO3JldHVybltIdCh0KSxlLEh0KGUpXX0obSkpLGI9W21dLmNvbmNhdChfKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQuY29uY2F0KFwiYXV0b1wiPT09bXQobik/JHQoZSx7cGxhY2VtZW50Om4sYm91bmRhcnk6dSxyb290Qm91bmRhcnk6ZixwYWRkaW5nOmMsZmxpcFZhcmlhdGlvbnM6cCxhbGxvd2VkQXV0b1BsYWNlbWVudHM6Z30pOm4pfSksW10pLHk9ZS5yZWN0cy5yZWZlcmVuY2Usdz1lLnJlY3RzLnBvcHBlcixFPW5ldyBNYXAsVD0hMCxrPWJbMF0sTz0wO088Yi5sZW5ndGg7TysrKXt2YXIgTD1iW09dLEE9bXQoTCksQz1cInN0YXJ0XCI9PT16dChMKSxEPVtpdCxvdF0uaW5kZXhPZihBKT49MCx4PUQ/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsUz1YdChlLHtwbGFjZW1lbnQ6TCxib3VuZGFyeTp1LHJvb3RCb3VuZGFyeTpmLGFsdEJvdW5kYXJ5OmQscGFkZGluZzpjfSksaj1EP0M/cnQ6c3Q6Qz9vdDppdDt5W3hdPndbeF0mJihqPU10KGopKTt2YXIgTj1NdChqKSxJPVtdO2lmKHImJkkucHVzaChTW0FdPD0wKSxhJiZJLnB1c2goU1tqXTw9MCxTW05dPD0wKSxJLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKSl7az1MLFQ9ITE7YnJlYWt9RS5zZXQoTCxJKX1pZihUKWZvcih2YXIgUD1mdW5jdGlvbih0KXt2YXIgZT1iLmZpbmQoKGZ1bmN0aW9uKGUpe3ZhciBuPUUuZ2V0KGUpO2lmKG4pcmV0dXJuIG4uc2xpY2UoMCx0KS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSl9KSk7aWYoZSlyZXR1cm4gaz1lLFwiYnJlYWtcIn0sTT1wPzM6MTtNPjA7TS0tKXtpZihcImJyZWFrXCI9PT1QKE0pKWJyZWFrfWUucGxhY2VtZW50IT09ayYmKGUubW9kaWZpZXJzRGF0YVtpXS5fc2tpcD0hMCxlLnBsYWNlbWVudD1rLGUucmVzZXQ9ITApfX0scmVxdWlyZXNJZkV4aXN0czpbXCJvZmZzZXRcIl0sZGF0YTp7X3NraXA6ITF9fTtmdW5jdGlvbiBadCh0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt4OjAseTowfSkse3RvcDp0LnRvcC1lLmhlaWdodC1uLnkscmlnaHQ6dC5yaWdodC1lLndpZHRoK24ueCxib3R0b206dC5ib3R0b20tZS5oZWlnaHQrbi55LGxlZnQ6dC5sZWZ0LWUud2lkdGgtbi54fX1mdW5jdGlvbiBKdCh0KXtyZXR1cm5baXQscnQsb3Qsc3RdLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdPj0wfSkpfXZhciB0ZT17bmFtZTpcImhpZGVcIixlbmFibGVkOiEwLHBoYXNlOlwibWFpblwiLHJlcXVpcmVzSWZFeGlzdHM6W1wicHJldmVudE92ZXJmbG93XCJdLGZuOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj10Lm5hbWUsaT1lLnJlY3RzLnJlZmVyZW5jZSxvPWUucmVjdHMucG9wcGVyLHI9ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdyxzPVh0KGUse2VsZW1lbnRDb250ZXh0OlwicmVmZXJlbmNlXCJ9KSxhPVh0KGUse2FsdEJvdW5kYXJ5OiEwfSksbD1adChzLGkpLGM9WnQoYSxvLHIpLHU9SnQobCksZj1KdChjKTtlLm1vZGlmaWVyc0RhdGFbbl09e3JlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czpsLHBvcHBlckVzY2FwZU9mZnNldHM6Yyxpc1JlZmVyZW5jZUhpZGRlbjp1LGhhc1BvcHBlckVzY2FwZWQ6Zn0sZS5hdHRyaWJ1dGVzLnBvcHBlcj1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZS5hdHRyaWJ1dGVzLnBvcHBlcikse30se1wiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOnUsXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6Zn0pfX07dmFyIGVlPXtuYW1lOlwib2Zmc2V0XCIsZW5hYmxlZDohMCxwaGFzZTpcIm1haW5cIixyZXF1aXJlczpbXCJwb3BwZXJPZmZzZXRzXCJdLGZuOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj10Lm9wdGlvbnMsaT10Lm5hbWUsbz1uLm9mZnNldCxyPXZvaWQgMD09PW8/WzAsMF06byxzPWN0LnJlZHVjZSgoZnVuY3Rpb24odCxuKXtyZXR1cm4gdFtuXT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bXQodCksbz1bc3QsaXRdLmluZGV4T2YoaSk+PTA/LTE6MSxyPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse30se3BsYWNlbWVudDp0fSkpOm4scz1yWzBdLGE9clsxXTtyZXR1cm4gcz1zfHwwLGE9KGF8fDApKm8sW3N0LHJ0XS5pbmRleE9mKGkpPj0wP3t4OmEseTpzfTp7eDpzLHk6YX19KG4sZS5yZWN0cyxyKSx0fSkse30pLGE9c1tlLnBsYWNlbWVudF0sbD1hLngsYz1hLnk7bnVsbCE9ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMmJihlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54Kz1sLGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkrPWMpLGUubW9kaWZpZXJzRGF0YVtpXT1zfX07dmFyIG5lPXtuYW1lOlwicG9wcGVyT2Zmc2V0c1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJyZWFkXCIsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXQubmFtZTtlLm1vZGlmaWVyc0RhdGFbbl09VnQoe3JlZmVyZW5jZTplLnJlY3RzLnJlZmVyZW5jZSxlbGVtZW50OmUucmVjdHMucG9wcGVyLHN0cmF0ZWd5OlwiYWJzb2x1dGVcIixwbGFjZW1lbnQ6ZS5wbGFjZW1lbnR9KX0sZGF0YTp7fX07dmFyIGllPXtuYW1lOlwicHJldmVudE92ZXJmbG93XCIsZW5hYmxlZDohMCxwaGFzZTpcIm1haW5cIixmbjpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlLG49dC5vcHRpb25zLGk9dC5uYW1lLG89bi5tYWluQXhpcyxyPXZvaWQgMD09PW98fG8scz1uLmFsdEF4aXMsYT12b2lkIDAhPT1zJiZzLGw9bi5ib3VuZGFyeSxjPW4ucm9vdEJvdW5kYXJ5LHU9bi5hbHRCb3VuZGFyeSxmPW4ucGFkZGluZyxkPW4udGV0aGVyLGg9dm9pZCAwPT09ZHx8ZCxwPW4udGV0aGVyT2Zmc2V0LGc9dm9pZCAwPT09cD8wOnAsbT1YdChlLHtib3VuZGFyeTpsLHJvb3RCb3VuZGFyeTpjLHBhZGRpbmc6ZixhbHRCb3VuZGFyeTp1fSksdj1tdChlLnBsYWNlbWVudCksXz16dChlLnBsYWNlbWVudCksYj0hXyx5PU90KHYpLHc9XCJ4XCI9PT15P1wieVwiOlwieFwiLEU9ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsVD1lLnJlY3RzLnJlZmVyZW5jZSxrPWUucmVjdHMucG9wcGVyLE89XCJmdW5jdGlvblwiPT10eXBlb2YgZz9nKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlLnJlY3RzKSx7fSx7cGxhY2VtZW50OmUucGxhY2VtZW50fSkpOmcsTD17eDowLHk6MH07aWYoRSl7aWYocil7dmFyIEE9XCJ5XCI9PT15P2l0OnN0LEM9XCJ5XCI9PT15P290OnJ0LEQ9XCJ5XCI9PT15P1wiaGVpZ2h0XCI6XCJ3aWR0aFwiLHg9RVt5XSxTPUVbeV0rbVtBXSxqPUVbeV0tbVtDXSxOPWg/LWtbRF0vMjowLEk9XCJzdGFydFwiPT09Xz9UW0RdOmtbRF0sUD1cInN0YXJ0XCI9PT1fPy1rW0RdOi1UW0RdLE09ZS5lbGVtZW50cy5hcnJvdyxCPWgmJk0/dnQoTSk6e3dpZHRoOjAsaGVpZ2h0OjB9LEg9ZS5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXT9lLm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdLnBhZGRpbmc6e3RvcDowLHJpZ2h0OjAsYm90dG9tOjAsbGVmdDowfSxSPUhbQV0sVz1IW0NdLEs9THQoMCxUW0RdLEJbRF0pLFE9Yj9UW0RdLzItTi1LLVItTzpJLUstUi1PLFU9Yj8tVFtEXS8yK04rSytXK086UCtLK1crTyxGPWUuZWxlbWVudHMuYXJyb3cmJmt0KGUuZWxlbWVudHMuYXJyb3cpLFk9Rj9cInlcIj09PXk/Ri5jbGllbnRUb3B8fDA6Ri5jbGllbnRMZWZ0fHwwOjAscT1lLm1vZGlmaWVyc0RhdGEub2Zmc2V0P2UubW9kaWZpZXJzRGF0YS5vZmZzZXRbZS5wbGFjZW1lbnRdW3ldOjAsej1FW3ldK1EtcS1ZLFY9RVt5XStVLXEsWD1MdChoP01hdGgubWluKFMseik6Uyx4LGg/TWF0aC5tYXgoaixWKTpqKTtFW3ldPVgsTFt5XT1YLXh9aWYoYSl7dmFyICQ9XCJ4XCI9PT15P2l0OnN0LEc9XCJ4XCI9PT15P290OnJ0LFo9RVt3XSxKPUx0KForbVskXSxaLFotbVtHXSk7RVt3XT1KLExbd109Si1afWUubW9kaWZpZXJzRGF0YVtpXT1MfX0scmVxdWlyZXNJZkV4aXN0czpbXCJvZmZzZXRcIl19O2Z1bmN0aW9uIG9lKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIGksbyxyPXd0KGUpLHM9UnQodCksYT1wdChlKSxsPXtzY3JvbGxMZWZ0OjAsc2Nyb2xsVG9wOjB9LGM9e3g6MCx5OjB9O3JldHVybihhfHwhYSYmIW4pJiYoKFwiYm9keVwiIT09ZnQoZSl8fFF0KHIpKSYmKGw9KGk9ZSkhPT1kdChpKSYmcHQoaSk/e3Njcm9sbExlZnQ6KG89aSkuc2Nyb2xsTGVmdCxzY3JvbGxUb3A6by5zY3JvbGxUb3B9Old0KGkpKSxwdChlKT8oKGM9UnQoZSkpLngrPWUuY2xpZW50TGVmdCxjLnkrPWUuY2xpZW50VG9wKTpyJiYoYy54PUt0KHIpKSkse3g6cy5sZWZ0K2wuc2Nyb2xsTGVmdC1jLngseTpzLnRvcCtsLnNjcm9sbFRvcC1jLnksd2lkdGg6cy53aWR0aCxoZWlnaHQ6cy5oZWlnaHR9fWZ1bmN0aW9uIHJlKHQpe3ZhciBlPW5ldyBNYXAsbj1uZXcgU2V0LGk9W107cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5zZXQodC5uYW1lLHQpfSkpLHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5oYXModC5uYW1lKXx8ZnVuY3Rpb24gdChvKXtuLmFkZChvLm5hbWUpLFtdLmNvbmNhdChvLnJlcXVpcmVzfHxbXSxvLnJlcXVpcmVzSWZFeGlzdHN8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihpKXtpZighbi5oYXMoaSkpe3ZhciBvPWUuZ2V0KGkpO28mJnQobyl9fSkpLGkucHVzaChvKX0odCl9KSksaX12YXIgc2U9e3BsYWNlbWVudDpcImJvdHRvbVwiLG1vZGlmaWVyczpbXSxzdHJhdGVneTpcImFic29sdXRlXCJ9O2Z1bmN0aW9uIGFlKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCksbj0wO248dDtuKyspZVtuXT1hcmd1bWVudHNbbl07cmV0dXJuIWUuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuISh0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCl9KSl9ZnVuY3Rpb24gbGUodCl7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciBlPXQsbj1lLmRlZmF1bHRNb2RpZmllcnMsaT12b2lkIDA9PT1uP1tdOm4sbz1lLmRlZmF1bHRPcHRpb25zLHI9dm9pZCAwPT09bz9zZTpvO3JldHVybiBmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49cik7dmFyIG8scyxhPXtwbGFjZW1lbnQ6XCJib3R0b21cIixvcmRlcmVkTW9kaWZpZXJzOltdLG9wdGlvbnM6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHNlKSxyKSxtb2RpZmllcnNEYXRhOnt9LGVsZW1lbnRzOntyZWZlcmVuY2U6dCxwb3BwZXI6ZX0sYXR0cmlidXRlczp7fSxzdHlsZXM6e319LGw9W10sYz0hMSx1PXtzdGF0ZTphLHNldE9wdGlvbnM6ZnVuY3Rpb24obil7ZigpLGEub3B0aW9ucz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSxhLm9wdGlvbnMpLG4pLGEuc2Nyb2xsUGFyZW50cz17cmVmZXJlbmNlOmh0KHQpP1V0KHQpOnQuY29udGV4dEVsZW1lbnQ/VXQodC5jb250ZXh0RWxlbWVudCk6W10scG9wcGVyOlV0KGUpfTt2YXIgbyxzLGM9ZnVuY3Rpb24odCl7dmFyIGU9cmUodCk7cmV0dXJuIHV0LnJlZHVjZSgoZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5jb25jYXQoZS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBoYXNlPT09bn0pKSl9KSxbXSl9KChvPVtdLmNvbmNhdChpLGEub3B0aW9ucy5tb2RpZmllcnMpLHM9by5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dFtlLm5hbWVdO3JldHVybiB0W2UubmFtZV09bj9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSxlKSx7fSx7b3B0aW9uczpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbi5vcHRpb25zKSxlLm9wdGlvbnMpLGRhdGE6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4uZGF0YSksZS5kYXRhKX0pOmUsdH0pLHt9KSxPYmplY3Qua2V5cyhzKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBzW3RdfSkpKSk7cmV0dXJuIGEub3JkZXJlZE1vZGlmaWVycz1jLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZW5hYmxlZH0pKSxhLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49dC5vcHRpb25zLGk9dm9pZCAwPT09bj97fTpuLG89dC5lZmZlY3Q7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbyl7dmFyIHI9byh7c3RhdGU6YSxuYW1lOmUsaW5zdGFuY2U6dSxvcHRpb25zOml9KSxzPWZ1bmN0aW9uKCl7fTtsLnB1c2gocnx8cyl9fSkpLHUudXBkYXRlKCl9LGZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7aWYoIWMpe3ZhciB0PWEuZWxlbWVudHMsZT10LnJlZmVyZW5jZSxuPXQucG9wcGVyO2lmKGFlKGUsbikpe2EucmVjdHM9e3JlZmVyZW5jZTpvZShlLGt0KG4pLFwiZml4ZWRcIj09PWEub3B0aW9ucy5zdHJhdGVneSkscG9wcGVyOnZ0KG4pfSxhLnJlc2V0PSExLGEucGxhY2VtZW50PWEub3B0aW9ucy5wbGFjZW1lbnQsYS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBhLm1vZGlmaWVyc0RhdGFbdC5uYW1lXT1PYmplY3QuYXNzaWduKHt9LHQuZGF0YSl9KSk7Zm9yKHZhciBpPTA7aTxhLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoO2krKylpZighMCE9PWEucmVzZXQpe3ZhciBvPWEub3JkZXJlZE1vZGlmaWVyc1tpXSxyPW8uZm4scz1vLm9wdGlvbnMsbD12b2lkIDA9PT1zP3t9OnMsZj1vLm5hbWU7XCJmdW5jdGlvblwiPT10eXBlb2YgciYmKGE9cih7c3RhdGU6YSxvcHRpb25zOmwsbmFtZTpmLGluc3RhbmNlOnV9KXx8YSl9ZWxzZSBhLnJlc2V0PSExLGk9LTF9fX0sdXBkYXRlOihvPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXt1LmZvcmNlVXBkYXRlKCksdChhKX0pKX0sZnVuY3Rpb24oKXtyZXR1cm4gc3x8KHM9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cz12b2lkIDAsdChvKCkpfSkpfSkpKSxzfSksZGVzdHJveTpmdW5jdGlvbigpe2YoKSxjPSEwfX07aWYoIWFlKHQsZSkpcmV0dXJuIHU7ZnVuY3Rpb24gZigpe2wuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKSxsPVtdfXJldHVybiB1LnNldE9wdGlvbnMobikudGhlbigoZnVuY3Rpb24odCl7IWMmJm4ub25GaXJzdFVwZGF0ZSYmbi5vbkZpcnN0VXBkYXRlKHQpfSkpLHV9fXZhciBjZT1sZSgpLHVlPWxlKHtkZWZhdWx0TW9kaWZpZXJzOltJdCxuZSxqdCxndF19KSxmZT1sZSh7ZGVmYXVsdE1vZGlmaWVyczpbSXQsbmUsanQsZ3QsZWUsR3QsaWUsRHQsdGVdfSksZGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwscG9wcGVyR2VuZXJhdG9yOmxlLGRldGVjdE92ZXJmbG93Olh0LGNyZWF0ZVBvcHBlckJhc2U6Y2UsY3JlYXRlUG9wcGVyOmZlLGNyZWF0ZVBvcHBlckxpdGU6dWUsdG9wOml0LGJvdHRvbTpvdCxyaWdodDpydCxsZWZ0OnN0LGF1dG86XCJhdXRvXCIsYmFzZVBsYWNlbWVudHM6YXQsc3RhcnQ6XCJzdGFydFwiLGVuZDpcImVuZFwiLGNsaXBwaW5nUGFyZW50czpcImNsaXBwaW5nUGFyZW50c1wiLHZpZXdwb3J0Olwidmlld3BvcnRcIixwb3BwZXI6XCJwb3BwZXJcIixyZWZlcmVuY2U6XCJyZWZlcmVuY2VcIix2YXJpYXRpb25QbGFjZW1lbnRzOmx0LHBsYWNlbWVudHM6Y3QsYmVmb3JlUmVhZDpcImJlZm9yZVJlYWRcIixyZWFkOlwicmVhZFwiLGFmdGVyUmVhZDpcImFmdGVyUmVhZFwiLGJlZm9yZU1haW46XCJiZWZvcmVNYWluXCIsbWFpbjpcIm1haW5cIixhZnRlck1haW46XCJhZnRlck1haW5cIixiZWZvcmVXcml0ZTpcImJlZm9yZVdyaXRlXCIsd3JpdGU6XCJ3cml0ZVwiLGFmdGVyV3JpdGU6XCJhZnRlcldyaXRlXCIsbW9kaWZpZXJQaGFzZXM6dXQsYXBwbHlTdHlsZXM6Z3QsYXJyb3c6RHQsY29tcHV0ZVN0eWxlczpqdCxldmVudExpc3RlbmVyczpJdCxmbGlwOkd0LGhpZGU6dGUsb2Zmc2V0OmVlLHBvcHBlck9mZnNldHM6bmUscHJldmVudE92ZXJmbG93OmllfSksaGU9XCJkcm9wZG93blwiLHBlPW5ldyBSZWdFeHAoXCJBcnJvd1VwfEFycm93RG93bnxFc2NhcGVcIiksZ2U9eT9cInRvcC1lbmRcIjpcInRvcC1zdGFydFwiLG1lPXk/XCJ0b3Atc3RhcnRcIjpcInRvcC1lbmRcIix2ZT15P1wiYm90dG9tLWVuZFwiOlwiYm90dG9tLXN0YXJ0XCIsX2U9eT9cImJvdHRvbS1zdGFydFwiOlwiYm90dG9tLWVuZFwiLGJlPXk/XCJsZWZ0LXN0YXJ0XCI6XCJyaWdodC1zdGFydFwiLHllPXk/XCJyaWdodC1zdGFydFwiOlwibGVmdC1zdGFydFwiLHdlPXtvZmZzZXQ6MCxmbGlwOiEwLGJvdW5kYXJ5OlwiY2xpcHBpbmdQYXJlbnRzXCIscmVmZXJlbmNlOlwidG9nZ2xlXCIsZGlzcGxheTpcImR5bmFtaWNcIixwb3BwZXJDb25maWc6bnVsbH0sRWU9e29mZnNldDpcIihudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKVwiLGZsaXA6XCJib29sZWFuXCIsYm91bmRhcnk6XCIoc3RyaW5nfGVsZW1lbnQpXCIscmVmZXJlbmNlOlwiKHN0cmluZ3xlbGVtZW50KVwiLGRpc3BsYXk6XCJzdHJpbmdcIixwb3BwZXJDb25maWc6XCIobnVsbHxvYmplY3QpXCJ9LFRlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuKXt2YXIgaTtyZXR1cm4oaT10LmNhbGwodGhpcyxlKXx8dGhpcykuX3BvcHBlcj1udWxsLGkuX2NvbmZpZz1pLl9nZXRDb25maWcobiksaS5fbWVudT1pLl9nZXRNZW51RWxlbWVudCgpLGkuX2luTmF2YmFyPWkuX2RldGVjdE5hdmJhcigpLGkuX2FkZEV2ZW50TGlzdGVuZXJzKCksaX1pKG8sdCk7dmFyIHI9by5wcm90b3R5cGU7cmV0dXJuIHIudG9nZ2xlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2VsZW1lbnQuZGlzYWJsZWQmJiF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpKXt2YXIgdD10aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIik7by5jbGVhck1lbnVzKCksdHx8dGhpcy5zaG93KCl9fSxyLnNob3c9ZnVuY3Rpb24oKXtpZighKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWR8fHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIil8fHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSkpe3ZhciB0PW8uZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCksZT17cmVsYXRlZFRhcmdldDp0aGlzLl9lbGVtZW50fTtpZighSC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsXCJzaG93LmJzLmRyb3Bkb3duXCIsZSkuZGVmYXVsdFByZXZlbnRlZCl7aWYoIXRoaXMuX2luTmF2YmFyKXtpZih2b2lkIDA9PT1kZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQm9vdHN0cmFwJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCIpO3ZhciBuPXRoaXMuX2VsZW1lbnQ7XCJwYXJlbnRcIj09PXRoaXMuX2NvbmZpZy5yZWZlcmVuY2U/bj10OmQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkmJihuPXRoaXMuX2NvbmZpZy5yZWZlcmVuY2Usdm9pZCAwIT09dGhpcy5fY29uZmlnLnJlZmVyZW5jZS5qcXVlcnkmJihuPXRoaXMuX2NvbmZpZy5yZWZlcmVuY2VbMF0pKSx0aGlzLl9wb3BwZXI9ZmUobix0aGlzLl9tZW51LHRoaXMuX2dldFBvcHBlckNvbmZpZygpKX12YXIgaTtpZihcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYhdC5jbG9zZXN0KFwiLm5hdmJhci1uYXZcIikpKGk9W10pLmNvbmNhdC5hcHBseShpLGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBILm9uKHQsXCJtb3VzZW92ZXJcIixudWxsLChmdW5jdGlvbigpe30pKX0pKTt0aGlzLl9lbGVtZW50LmZvY3VzKCksdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsITApLHRoaXMuX21lbnUuY2xhc3NMaXN0LnRvZ2dsZShcInNob3dcIiksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwic2hvd1wiKSxILnRyaWdnZXIodCxcInNob3duLmJzLmRyb3Bkb3duXCIsZSl9fX0sci5oaWRlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2VsZW1lbnQuZGlzYWJsZWQmJiF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpJiZ0aGlzLl9tZW51LmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIikpe3ZhciB0PW8uZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCksZT17cmVsYXRlZFRhcmdldDp0aGlzLl9lbGVtZW50fTtILnRyaWdnZXIodCxcImhpZGUuYnMuZHJvcGRvd25cIixlKS5kZWZhdWx0UHJldmVudGVkfHwodGhpcy5fcG9wcGVyJiZ0aGlzLl9wb3BwZXIuZGVzdHJveSgpLHRoaXMuX21lbnUuY2xhc3NMaXN0LnRvZ2dsZShcInNob3dcIiksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwic2hvd1wiKSxILnRyaWdnZXIodCxcImhpZGRlbi5icy5kcm9wZG93blwiLGUpKX19LHIuZGlzcG9zZT1mdW5jdGlvbigpe3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSxILm9mZih0aGlzLl9lbGVtZW50LFwiLmJzLmRyb3Bkb3duXCIpLHRoaXMuX21lbnU9bnVsbCx0aGlzLl9wb3BwZXImJih0aGlzLl9wb3BwZXIuZGVzdHJveSgpLHRoaXMuX3BvcHBlcj1udWxsKX0sci51cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLl9pbk5hdmJhcj10aGlzLl9kZXRlY3ROYXZiYXIoKSx0aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci51cGRhdGUoKX0sci5fYWRkRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO0gub24odGhpcy5fZWxlbWVudCxcImNsaWNrLmJzLmRyb3Bkb3duXCIsKGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHQudG9nZ2xlKCl9KSl9LHIuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1uKHt9LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxZLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLHQpLHAoaGUsdCx0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSx0fSxyLl9nZXRNZW51RWxlbWVudD1mdW5jdGlvbigpe3JldHVybiBxLm5leHQodGhpcy5fZWxlbWVudCxcIi5kcm9wZG93bi1tZW51XCIpWzBdfSxyLl9nZXRQbGFjZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7aWYodC5jbGFzc0xpc3QuY29udGFpbnMoXCJkcm9wZW5kXCIpKXJldHVybiBiZTtpZih0LmNsYXNzTGlzdC5jb250YWlucyhcImRyb3BzdGFydFwiKSlyZXR1cm4geWU7dmFyIGU9XCJlbmRcIj09PWdldENvbXB1dGVkU3R5bGUodGhpcy5fbWVudSkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tYnMtcG9zaXRpb25cIikudHJpbSgpO3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcImRyb3B1cFwiKT9lP21lOmdlOmU/X2U6dmV9LHIuX2RldGVjdE5hdmJhcj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5fZWxlbWVudC5jbG9zZXN0KFwiLm5hdmJhclwiKX0sci5fZ2V0UG9wcGVyQ29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3BsYWNlbWVudDp0aGlzLl9nZXRQbGFjZW1lbnQoKSxtb2RpZmllcnM6W3tuYW1lOlwicHJldmVudE92ZXJmbG93XCIsb3B0aW9uczp7YWx0Qm91bmRhcnk6dGhpcy5fY29uZmlnLmZsaXAscm9vdEJvdW5kYXJ5OnRoaXMuX2NvbmZpZy5ib3VuZGFyeX19XX07cmV0dXJuXCJzdGF0aWNcIj09PXRoaXMuX2NvbmZpZy5kaXNwbGF5JiYodC5tb2RpZmllcnM9W3tuYW1lOlwiYXBwbHlTdHlsZXNcIixlbmFibGVkOiExfV0pLG4oe30sdCx0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKX0sby5kcm9wZG93bkludGVyZmFjZT1mdW5jdGlvbih0LGUpe3ZhciBuPVQodCxcImJzLmRyb3Bkb3duXCIpO2lmKG58fChuPW5ldyBvKHQsXCJvYmplY3RcIj09dHlwZW9mIGU/ZTpudWxsKSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKHZvaWQgMD09PW5bZV0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytlKydcIicpO25bZV0oKX19LG8ualF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVhY2goKGZ1bmN0aW9uKCl7by5kcm9wZG93bkludGVyZmFjZSh0aGlzLHQpfSkpfSxvLmNsZWFyTWVudXM9ZnVuY3Rpb24odCl7aWYoIXR8fDIhPT10LmJ1dHRvbiYmKFwia2V5dXBcIiE9PXQudHlwZXx8XCJUYWJcIj09PXQua2V5KSlmb3IodmFyIGU9cS5maW5kKCdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXScpLG49MCxpPWUubGVuZ3RoO248aTtuKyspe3ZhciByPW8uZ2V0UGFyZW50RnJvbUVsZW1lbnQoZVtuXSkscz1UKGVbbl0sXCJicy5kcm9wZG93blwiKSxhPXtyZWxhdGVkVGFyZ2V0OmVbbl19O2lmKHQmJlwiY2xpY2tcIj09PXQudHlwZSYmKGEuY2xpY2tFdmVudD10KSxzKXt2YXIgbD1zLl9tZW51O2lmKGVbbl0uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSlpZighKHQmJihcImNsaWNrXCI9PT10LnR5cGUmJi9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSl8fFwia2V5dXBcIj09PXQudHlwZSYmXCJUYWJcIj09PXQua2V5KSYmbC5jb250YWlucyh0LnRhcmdldCkpKWlmKCFILnRyaWdnZXIocixcImhpZGUuYnMuZHJvcGRvd25cIixhKS5kZWZhdWx0UHJldmVudGVkKXt2YXIgYztpZihcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KShjPVtdKS5jb25jYXQuYXBwbHkoYyxkb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gSC5vZmYodCxcIm1vdXNlb3ZlclwiLG51bGwsKGZ1bmN0aW9uKCl7fSkpfSkpO2Vbbl0uc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLFwiZmFsc2VcIikscy5fcG9wcGVyJiZzLl9wb3BwZXIuZGVzdHJveSgpLGwuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIiksZVtuXS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKSxILnRyaWdnZXIocixcImhpZGRlbi5icy5kcm9wZG93blwiLGEpfX19fSxvLmdldFBhcmVudEZyb21FbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiBjKHQpfHx0LnBhcmVudE5vZGV9LG8uZGF0YUFwaUtleWRvd25IYW5kbGVyPWZ1bmN0aW9uKHQpe2lmKCEoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKT9cIlNwYWNlXCI9PT10LmtleXx8XCJFc2NhcGVcIiE9PXQua2V5JiYoXCJBcnJvd0Rvd25cIiE9PXQua2V5JiZcIkFycm93VXBcIiE9PXQua2V5fHx0LnRhcmdldC5jbG9zZXN0KFwiLmRyb3Bkb3duLW1lbnVcIikpOiFwZS50ZXN0KHQua2V5KSkmJih0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSwhdGhpcy5kaXNhYmxlZCYmIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikpKXt2YXIgZT1vLmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMpLG49dGhpcy5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpO2lmKFwiRXNjYXBlXCI9PT10LmtleSlyZXR1cm4odGhpcy5tYXRjaGVzKCdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXScpP3RoaXM6cS5wcmV2KHRoaXMsJ1tkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJdJylbMF0pLmZvY3VzKCksdm9pZCBvLmNsZWFyTWVudXMoKTtpZihuJiZcIlNwYWNlXCIhPT10LmtleSl7dmFyIGk9cS5maW5kKFwiLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIixlKS5maWx0ZXIoZyk7aWYoaS5sZW5ndGgpe3ZhciByPWkuaW5kZXhPZih0LnRhcmdldCk7XCJBcnJvd1VwXCI9PT10LmtleSYmcj4wJiZyLS0sXCJBcnJvd0Rvd25cIj09PXQua2V5JiZyPGkubGVuZ3RoLTEmJnIrKyxpW3I9LTE9PT1yPzA6cl0uZm9jdXMoKX19ZWxzZSBvLmNsZWFyTWVudXMoKX19LGUobyxudWxsLFt7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB3ZX19LHtrZXk6XCJEZWZhdWx0VHlwZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBFZX19LHtrZXk6XCJEQVRBX0tFWVwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiYnMuZHJvcGRvd25cIn19XSksb30oUik7SC5vbihkb2N1bWVudCxcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIiwnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLFRlLmRhdGFBcGlLZXlkb3duSGFuZGxlciksSC5vbihkb2N1bWVudCxcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixcIi5kcm9wZG93bi1tZW51XCIsVGUuZGF0YUFwaUtleWRvd25IYW5kbGVyKSxILm9uKGRvY3VtZW50LFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIixUZS5jbGVhck1lbnVzKSxILm9uKGRvY3VtZW50LFwia2V5dXAuYnMuZHJvcGRvd24uZGF0YS1hcGlcIixUZS5jbGVhck1lbnVzKSxILm9uKGRvY3VtZW50LFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIiwnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLChmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSxUZS5kcm9wZG93bkludGVyZmFjZSh0aGlzLFwidG9nZ2xlXCIpfSkpLEgub24oZG9jdW1lbnQsXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duIGZvcm1cIiwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCl9KSksYigoZnVuY3Rpb24oKXt2YXIgdD1fKCk7aWYodCl7dmFyIGU9dC5mbltoZV07dC5mbltoZV09VGUualF1ZXJ5SW50ZXJmYWNlLHQuZm5baGVdLkNvbnN0cnVjdG9yPVRlLHQuZm5baGVdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5mbltoZV09ZSxUZS5qUXVlcnlJbnRlcmZhY2V9fX0pKTt2YXIga2U9e2JhY2tkcm9wOiEwLGtleWJvYXJkOiEwLGZvY3VzOiEwfSxPZT17YmFja2Ryb3A6XCIoYm9vbGVhbnxzdHJpbmcpXCIsa2V5Ym9hcmQ6XCJib29sZWFuXCIsZm9jdXM6XCJib29sZWFuXCJ9LExlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuKXt2YXIgaTtyZXR1cm4oaT10LmNhbGwodGhpcyxlKXx8dGhpcykuX2NvbmZpZz1pLl9nZXRDb25maWcobiksaS5fZGlhbG9nPXEuZmluZE9uZShcIi5tb2RhbC1kaWFsb2dcIixlKSxpLl9iYWNrZHJvcD1udWxsLGkuX2lzU2hvd249ITEsaS5faXNCb2R5T3ZlcmZsb3dpbmc9ITEsaS5faWdub3JlQmFja2Ryb3BDbGljaz0hMSxpLl9pc1RyYW5zaXRpb25pbmc9ITEsaS5fc2Nyb2xsYmFyV2lkdGg9MCxpfWkobyx0KTt2YXIgcj1vLnByb3RvdHlwZTtyZXR1cm4gci50b2dnbGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2lzU2hvd24/dGhpcy5oaWRlKCk6dGhpcy5zaG93KHQpfSxyLnNob3c9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighdGhpcy5faXNTaG93biYmIXRoaXMuX2lzVHJhbnNpdGlvbmluZyl7dGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpJiYodGhpcy5faXNUcmFuc2l0aW9uaW5nPSEwKTt2YXIgbj1ILnRyaWdnZXIodGhpcy5fZWxlbWVudCxcInNob3cuYnMubW9kYWxcIix7cmVsYXRlZFRhcmdldDp0fSk7dGhpcy5faXNTaG93bnx8bi5kZWZhdWx0UHJldmVudGVkfHwodGhpcy5faXNTaG93bj0hMCx0aGlzLl9jaGVja1Njcm9sbGJhcigpLHRoaXMuX3NldFNjcm9sbGJhcigpLHRoaXMuX2FkanVzdERpYWxvZygpLHRoaXMuX3NldEVzY2FwZUV2ZW50KCksdGhpcy5fc2V0UmVzaXplRXZlbnQoKSxILm9uKHRoaXMuX2VsZW1lbnQsXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsJ1tkYXRhLWJzLWRpc21pc3M9XCJtb2RhbFwiXScsKGZ1bmN0aW9uKHQpe3JldHVybiBlLmhpZGUodCl9KSksSC5vbih0aGlzLl9kaWFsb2csXCJtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbFwiLChmdW5jdGlvbigpe0gub25lKGUuX2VsZW1lbnQsXCJtb3VzZXVwLmRpc21pc3MuYnMubW9kYWxcIiwoZnVuY3Rpb24odCl7dC50YXJnZXQ9PT1lLl9lbGVtZW50JiYoZS5faWdub3JlQmFja2Ryb3BDbGljaz0hMCl9KSl9KSksdGhpcy5fc2hvd0JhY2tkcm9wKChmdW5jdGlvbigpe3JldHVybiBlLl9zaG93RWxlbWVudCh0KX0pKSl9fSxyLmhpZGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZigodCYmdC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuX2lzU2hvd24mJiF0aGlzLl9pc1RyYW5zaXRpb25pbmcpJiYhSC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsXCJoaWRlLmJzLm1vZGFsXCIpLmRlZmF1bHRQcmV2ZW50ZWQpe3RoaXMuX2lzU2hvd249ITE7dmFyIG49dGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpO2lmKG4mJih0aGlzLl9pc1RyYW5zaXRpb25pbmc9ITApLHRoaXMuX3NldEVzY2FwZUV2ZW50KCksdGhpcy5fc2V0UmVzaXplRXZlbnQoKSxILm9mZihkb2N1bWVudCxcImZvY3VzaW4uYnMubW9kYWxcIiksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKSxILm9mZih0aGlzLl9lbGVtZW50LFwiY2xpY2suZGlzbWlzcy5icy5tb2RhbFwiKSxILm9mZih0aGlzLl9kaWFsb2csXCJtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbFwiKSxuKXt2YXIgaT11KHRoaXMuX2VsZW1lbnQpO0gub25lKHRoaXMuX2VsZW1lbnQsXCJ0cmFuc2l0aW9uZW5kXCIsKGZ1bmN0aW9uKHQpe3JldHVybiBlLl9oaWRlTW9kYWwodCl9KSksaCh0aGlzLl9lbGVtZW50LGkpfWVsc2UgdGhpcy5faGlkZU1vZGFsKCl9fSxyLmRpc3Bvc2U9ZnVuY3Rpb24oKXtbd2luZG93LHRoaXMuX2VsZW1lbnQsdGhpcy5fZGlhbG9nXS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gSC5vZmYodCxcIi5icy5tb2RhbFwiKX0pKSx0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksSC5vZmYoZG9jdW1lbnQsXCJmb2N1c2luLmJzLm1vZGFsXCIpLHRoaXMuX2NvbmZpZz1udWxsLHRoaXMuX2RpYWxvZz1udWxsLHRoaXMuX2JhY2tkcm9wPW51bGwsdGhpcy5faXNTaG93bj1udWxsLHRoaXMuX2lzQm9keU92ZXJmbG93aW5nPW51bGwsdGhpcy5faWdub3JlQmFja2Ryb3BDbGljaz1udWxsLHRoaXMuX2lzVHJhbnNpdGlvbmluZz1udWxsLHRoaXMuX3Njcm9sbGJhcldpZHRoPW51bGx9LHIuaGFuZGxlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fYWRqdXN0RGlhbG9nKCl9LHIuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1uKHt9LGtlLHQpLHAoXCJtb2RhbFwiLHQsT2UpLHR9LHIuX3Nob3dFbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImZhZGVcIiksaT1xLmZpbmRPbmUoXCIubW9kYWwtYm9keVwiLHRoaXMuX2RpYWxvZyk7dGhpcy5fZWxlbWVudC5wYXJlbnROb2RlJiZ0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERXx8ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSx0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsITApLHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwiZGlhbG9nXCIpLHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wPTAsaSYmKGkuc2Nyb2xsVG9wPTApLG4mJnYodGhpcy5fZWxlbWVudCksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKSx0aGlzLl9jb25maWcuZm9jdXMmJnRoaXMuX2VuZm9yY2VGb2N1cygpO3ZhciBvPWZ1bmN0aW9uKCl7ZS5fY29uZmlnLmZvY3VzJiZlLl9lbGVtZW50LmZvY3VzKCksZS5faXNUcmFuc2l0aW9uaW5nPSExLEgudHJpZ2dlcihlLl9lbGVtZW50LFwic2hvd24uYnMubW9kYWxcIix7cmVsYXRlZFRhcmdldDp0fSl9O2lmKG4pe3ZhciByPXUodGhpcy5fZGlhbG9nKTtILm9uZSh0aGlzLl9kaWFsb2csXCJ0cmFuc2l0aW9uZW5kXCIsbyksaCh0aGlzLl9kaWFsb2cscil9ZWxzZSBvKCl9LHIuX2VuZm9yY2VGb2N1cz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7SC5vZmYoZG9jdW1lbnQsXCJmb2N1c2luLmJzLm1vZGFsXCIpLEgub24oZG9jdW1lbnQsXCJmb2N1c2luLmJzLm1vZGFsXCIsKGZ1bmN0aW9uKGUpe2RvY3VtZW50PT09ZS50YXJnZXR8fHQuX2VsZW1lbnQ9PT1lLnRhcmdldHx8dC5fZWxlbWVudC5jb250YWlucyhlLnRhcmdldCl8fHQuX2VsZW1lbnQuZm9jdXMoKX0pKX0sci5fc2V0RXNjYXBlRXZlbnQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2lzU2hvd24/SC5vbih0aGlzLl9lbGVtZW50LFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsKGZ1bmN0aW9uKGUpe3QuX2NvbmZpZy5rZXlib2FyZCYmXCJFc2NhcGVcIj09PWUua2V5PyhlLnByZXZlbnREZWZhdWx0KCksdC5oaWRlKCkpOnQuX2NvbmZpZy5rZXlib2FyZHx8XCJFc2NhcGVcIiE9PWUua2V5fHx0Ll90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCl9KSk6SC5vZmYodGhpcy5fZWxlbWVudCxcImtleWRvd24uZGlzbWlzcy5icy5tb2RhbFwiKX0sci5fc2V0UmVzaXplRXZlbnQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2lzU2hvd24/SC5vbih3aW5kb3csXCJyZXNpemUuYnMubW9kYWxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdC5fYWRqdXN0RGlhbG9nKCl9KSk6SC5vZmYod2luZG93LFwicmVzaXplLmJzLm1vZGFsXCIpfSxyLl9oaWRlTW9kYWw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsITApLHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSx0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksdGhpcy5faXNUcmFuc2l0aW9uaW5nPSExLHRoaXMuX3Nob3dCYWNrZHJvcCgoZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2RhbC1vcGVuXCIpLHQuX3Jlc2V0QWRqdXN0bWVudHMoKSx0Ll9yZXNldFNjcm9sbGJhcigpLEgudHJpZ2dlcih0Ll9lbGVtZW50LFwiaGlkZGVuLmJzLm1vZGFsXCIpfSkpfSxyLl9yZW1vdmVCYWNrZHJvcD1mdW5jdGlvbigpe3RoaXMuX2JhY2tkcm9wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fYmFja2Ryb3ApLHRoaXMuX2JhY2tkcm9wPW51bGx9LHIuX3Nob3dCYWNrZHJvcD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpP1wiZmFkZVwiOlwiXCI7aWYodGhpcy5faXNTaG93biYmdGhpcy5fY29uZmlnLmJhY2tkcm9wKXtpZih0aGlzLl9iYWNrZHJvcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuX2JhY2tkcm9wLmNsYXNzTmFtZT1cIm1vZGFsLWJhY2tkcm9wXCIsbiYmdGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChuKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2JhY2tkcm9wKSxILm9uKHRoaXMuX2VsZW1lbnQsXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsKGZ1bmN0aW9uKHQpe2UuX2lnbm9yZUJhY2tkcm9wQ2xpY2s/ZS5faWdub3JlQmFja2Ryb3BDbGljaz0hMTp0LnRhcmdldD09PXQuY3VycmVudFRhcmdldCYmKFwic3RhdGljXCI9PT1lLl9jb25maWcuYmFja2Ryb3A/ZS5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpOmUuaGlkZSgpKX0pKSxuJiZ2KHRoaXMuX2JhY2tkcm9wKSx0aGlzLl9iYWNrZHJvcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKSwhbilyZXR1cm4gdm9pZCB0KCk7dmFyIGk9dSh0aGlzLl9iYWNrZHJvcCk7SC5vbmUodGhpcy5fYmFja2Ryb3AsXCJ0cmFuc2l0aW9uZW5kXCIsdCksaCh0aGlzLl9iYWNrZHJvcCxpKX1lbHNlIGlmKCF0aGlzLl9pc1Nob3duJiZ0aGlzLl9iYWNrZHJvcCl7dGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7dmFyIG89ZnVuY3Rpb24oKXtlLl9yZW1vdmVCYWNrZHJvcCgpLHQoKX07aWYodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpKXt2YXIgcj11KHRoaXMuX2JhY2tkcm9wKTtILm9uZSh0aGlzLl9iYWNrZHJvcCxcInRyYW5zaXRpb25lbmRcIixvKSxoKHRoaXMuX2JhY2tkcm9wLHIpfWVsc2UgbygpfWVsc2UgdCgpfSxyLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighSC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsXCJoaWRlUHJldmVudGVkLmJzLm1vZGFsXCIpLmRlZmF1bHRQcmV2ZW50ZWQpe3ZhciBlPXRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0PmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7ZXx8KHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZPVwiaGlkZGVuXCIpLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1vZGFsLXN0YXRpY1wiKTt2YXIgbj11KHRoaXMuX2RpYWxvZyk7SC5vZmYodGhpcy5fZWxlbWVudCxcInRyYW5zaXRpb25lbmRcIiksSC5vbmUodGhpcy5fZWxlbWVudCxcInRyYW5zaXRpb25lbmRcIiwoZnVuY3Rpb24oKXt0Ll9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2RhbC1zdGF0aWNcIiksZXx8KEgub25lKHQuX2VsZW1lbnQsXCJ0cmFuc2l0aW9uZW5kXCIsKGZ1bmN0aW9uKCl7dC5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1k9XCJcIn0pKSxoKHQuX2VsZW1lbnQsbikpfSkpLGgodGhpcy5fZWxlbWVudCxuKSx0aGlzLl9lbGVtZW50LmZvY3VzKCl9fSxyLl9hZGp1c3REaWFsb2c9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodD5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcmJnQmJiF5fHx0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyYmIXQmJnkpJiYodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdD10aGlzLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpLCh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyYmIXQmJiF5fHwhdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcmJnQmJnkpJiYodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ9dGhpcy5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKX0sci5fcmVzZXRBZGp1c3RtZW50cz1mdW5jdGlvbigpe3RoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQ9XCJcIix0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodD1cIlwifSxyLl9jaGVja1Njcm9sbGJhcj1mdW5jdGlvbigpe3ZhciB0PWRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dGhpcy5faXNCb2R5T3ZlcmZsb3dpbmc9TWF0aC5yb3VuZCh0LmxlZnQrdC5yaWdodCk8d2luZG93LmlubmVyV2lkdGgsdGhpcy5fc2Nyb2xsYmFyV2lkdGg9dGhpcy5fZ2V0U2Nyb2xsYmFyV2lkdGgoKX0sci5fc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyl7cS5maW5kKFwiLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcFwiKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnN0eWxlLnBhZGRpbmdSaWdodCxpPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpW1wicGFkZGluZy1yaWdodFwiXTtZLnNldERhdGFBdHRyaWJ1dGUoZSxcInBhZGRpbmctcmlnaHRcIixuKSxlLnN0eWxlLnBhZGRpbmdSaWdodD1OdW1iZXIucGFyc2VGbG9hdChpKSt0Ll9zY3JvbGxiYXJXaWR0aCtcInB4XCJ9KSkscS5maW5kKFwiLnN0aWNreS10b3BcIikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5zdHlsZS5tYXJnaW5SaWdodCxpPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpW1wibWFyZ2luLXJpZ2h0XCJdO1kuc2V0RGF0YUF0dHJpYnV0ZShlLFwibWFyZ2luLXJpZ2h0XCIsbiksZS5zdHlsZS5tYXJnaW5SaWdodD1OdW1iZXIucGFyc2VGbG9hdChpKS10Ll9zY3JvbGxiYXJXaWR0aCtcInB4XCJ9KSk7dmFyIGU9ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQsbj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KVtcInBhZGRpbmctcmlnaHRcIl07WS5zZXREYXRhQXR0cmlidXRlKGRvY3VtZW50LmJvZHksXCJwYWRkaW5nLXJpZ2h0XCIsZSksZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQ9TnVtYmVyLnBhcnNlRmxvYXQobikrdGhpcy5fc2Nyb2xsYmFyV2lkdGgrXCJweFwifWRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcIm1vZGFsLW9wZW5cIil9LHIuX3Jlc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7cS5maW5kKFwiLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcFwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1ZLmdldERhdGFBdHRyaWJ1dGUodCxcInBhZGRpbmctcmlnaHRcIik7dm9pZCAwIT09ZSYmKFkucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0LFwicGFkZGluZy1yaWdodFwiKSx0LnN0eWxlLnBhZGRpbmdSaWdodD1lKX0pKSxxLmZpbmQoXCIuc3RpY2t5LXRvcFwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1ZLmdldERhdGFBdHRyaWJ1dGUodCxcIm1hcmdpbi1yaWdodFwiKTt2b2lkIDAhPT1lJiYoWS5yZW1vdmVEYXRhQXR0cmlidXRlKHQsXCJtYXJnaW4tcmlnaHRcIiksdC5zdHlsZS5tYXJnaW5SaWdodD1lKX0pKTt2YXIgdD1ZLmdldERhdGFBdHRyaWJ1dGUoZG9jdW1lbnQuYm9keSxcInBhZGRpbmctcmlnaHRcIik7dm9pZCAwPT09dD9kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD1cIlwiOihZLnJlbW92ZURhdGFBdHRyaWJ1dGUoZG9jdW1lbnQuYm9keSxcInBhZGRpbmctcmlnaHRcIiksZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQ9dCl9LHIuX2dldFNjcm9sbGJhcldpZHRoPWZ1bmN0aW9uKCl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT1cIm1vZGFsLXNjcm9sbGJhci1tZWFzdXJlXCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTt2YXIgZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLXQuY2xpZW50V2lkdGg7cmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksZX0sby5qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lYWNoKChmdW5jdGlvbigpe3ZhciBpPVQodGhpcyxcImJzLm1vZGFsXCIpLHI9bih7fSxrZSxZLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMpLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0P3Q6e30pO2lmKGl8fChpPW5ldyBvKHRoaXMscikpLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtpZih2b2lkIDA9PT1pW3RdKXRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicrdCsnXCInKTtpW3RdKGUpfX0pKX0sZShvLG51bGwsW3trZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGtlfX0se2tleTpcIkRBVEFfS0VZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJicy5tb2RhbFwifX1dKSxvfShSKTtILm9uKGRvY3VtZW50LFwiY2xpY2suYnMubW9kYWwuZGF0YS1hcGlcIiwnW2RhdGEtYnMtdG9nZ2xlPVwibW9kYWxcIl0nLChmdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9Yyh0aGlzKTtcIkFcIiE9PXRoaXMudGFnTmFtZSYmXCJBUkVBXCIhPT10aGlzLnRhZ05hbWV8fHQucHJldmVudERlZmF1bHQoKSxILm9uZShpLFwic2hvdy5icy5tb2RhbFwiLChmdW5jdGlvbih0KXt0LmRlZmF1bHRQcmV2ZW50ZWR8fEgub25lKGksXCJoaWRkZW4uYnMubW9kYWxcIiwoZnVuY3Rpb24oKXtnKGUpJiZlLmZvY3VzKCl9KSl9KSk7dmFyIG89VChpLFwiYnMubW9kYWxcIik7aWYoIW8pe3ZhciByPW4oe30sWS5nZXREYXRhQXR0cmlidXRlcyhpKSxZLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMpKTtvPW5ldyBMZShpLHIpfW8uc2hvdyh0aGlzKX0pKSxiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuLm1vZGFsO3QuZm4ubW9kYWw9TGUualF1ZXJ5SW50ZXJmYWNlLHQuZm4ubW9kYWwuQ29uc3RydWN0b3I9TGUsdC5mbi5tb2RhbC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm4ubW9kYWw9ZSxMZS5qUXVlcnlJbnRlcmZhY2V9fX0pKTt2YXIgQWU9bmV3IFNldChbXCJiYWNrZ3JvdW5kXCIsXCJjaXRlXCIsXCJocmVmXCIsXCJpdGVtdHlwZVwiLFwibG9uZ2Rlc2NcIixcInBvc3RlclwiLFwic3JjXCIsXCJ4bGluazpocmVmXCJdKSxDZT0vXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlKTp8W14jJi86P10qKD86WyMvP118JCkpL2dpLERlPS9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2kseGU9e1wiKlwiOltcImNsYXNzXCIsXCJkaXJcIixcImlkXCIsXCJsYW5nXCIsXCJyb2xlXCIsL15hcmlhLVtcXHctXSokL2ldLGE6W1widGFyZ2V0XCIsXCJocmVmXCIsXCJ0aXRsZVwiLFwicmVsXCJdLGFyZWE6W10sYjpbXSxicjpbXSxjb2w6W10sY29kZTpbXSxkaXY6W10sZW06W10saHI6W10saDE6W10saDI6W10saDM6W10saDQ6W10saDU6W10saDY6W10saTpbXSxpbWc6W1wic3JjXCIsXCJzcmNzZXRcIixcImFsdFwiLFwidGl0bGVcIixcIndpZHRoXCIsXCJoZWlnaHRcIl0sbGk6W10sb2w6W10scDpbXSxwcmU6W10sczpbXSxzbWFsbDpbXSxzcGFuOltdLHN1YjpbXSxzdXA6W10sc3Ryb25nOltdLHU6W10sdWw6W119O2Z1bmN0aW9uIFNlKHQsZSxuKXt2YXIgaTtpZighdC5sZW5ndGgpcmV0dXJuIHQ7aWYobiYmXCJmdW5jdGlvblwiPT10eXBlb2YgbilyZXR1cm4gbih0KTtmb3IodmFyIG89KG5ldyB3aW5kb3cuRE9NUGFyc2VyKS5wYXJzZUZyb21TdHJpbmcodCxcInRleHQvaHRtbFwiKSxyPU9iamVjdC5rZXlzKGUpLHM9KGk9W10pLmNvbmNhdC5hcHBseShpLG8uYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSksYT1mdW5jdGlvbih0LG4pe3ZhciBpLG89c1t0XSxhPW8ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZighci5pbmNsdWRlcyhhKSlyZXR1cm4gby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pLFwiY29udGludWVcIjt2YXIgbD0oaT1bXSkuY29uY2F0LmFwcGx5KGksby5hdHRyaWJ1dGVzKSxjPVtdLmNvbmNhdChlW1wiKlwiXXx8W10sZVthXXx8W10pO2wuZm9yRWFjaCgoZnVuY3Rpb24odCl7KGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKGUuaW5jbHVkZXMobikpcmV0dXJuIUFlLmhhcyhuKXx8Qm9vbGVhbih0Lm5vZGVWYWx1ZS5tYXRjaChDZSl8fHQubm9kZVZhbHVlLm1hdGNoKERlKSk7Zm9yKHZhciBpPWUuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFJlZ0V4cH0pKSxvPTAscj1pLmxlbmd0aDtvPHI7bysrKWlmKG4ubWF0Y2goaVtvXSkpcmV0dXJuITA7cmV0dXJuITF9KSh0LGMpfHxvLnJlbW92ZUF0dHJpYnV0ZSh0Lm5vZGVOYW1lKX0pKX0sbD0wLGM9cy5sZW5ndGg7bDxjO2wrKylhKGwpO3JldHVybiBvLmJvZHkuaW5uZXJIVE1MfXZhciBqZT1cInRvb2x0aXBcIixOZT1uZXcgUmVnRXhwKFwiKF58XFxcXHMpYnMtdG9vbHRpcFxcXFxTK1wiLFwiZ1wiKSxJZT1uZXcgU2V0KFtcInNhbml0aXplXCIsXCJhbGxvd0xpc3RcIixcInNhbml0aXplRm5cIl0pLFBlPXthbmltYXRpb246XCJib29sZWFuXCIsdGVtcGxhdGU6XCJzdHJpbmdcIix0aXRsZTpcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIix0cmlnZ2VyOlwic3RyaW5nXCIsZGVsYXk6XCIobnVtYmVyfG9iamVjdClcIixodG1sOlwiYm9vbGVhblwiLHNlbGVjdG9yOlwiKHN0cmluZ3xib29sZWFuKVwiLHBsYWNlbWVudDpcIihzdHJpbmd8ZnVuY3Rpb24pXCIsY29udGFpbmVyOlwiKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pXCIsZmFsbGJhY2tQbGFjZW1lbnRzOlwiKG51bGx8YXJyYXkpXCIsYm91bmRhcnk6XCIoc3RyaW5nfGVsZW1lbnQpXCIsY3VzdG9tQ2xhc3M6XCIoc3RyaW5nfGZ1bmN0aW9uKVwiLHNhbml0aXplOlwiYm9vbGVhblwiLHNhbml0aXplRm46XCIobnVsbHxmdW5jdGlvbilcIixhbGxvd0xpc3Q6XCJvYmplY3RcIixwb3BwZXJDb25maWc6XCIobnVsbHxvYmplY3QpXCJ9LE1lPXtBVVRPOlwiYXV0b1wiLFRPUDpcInRvcFwiLFJJR0hUOnk/XCJsZWZ0XCI6XCJyaWdodFwiLEJPVFRPTTpcImJvdHRvbVwiLExFRlQ6eT9cInJpZ2h0XCI6XCJsZWZ0XCJ9LEJlPXthbmltYXRpb246ITAsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+Jyx0cmlnZ2VyOlwiaG92ZXIgZm9jdXNcIix0aXRsZTpcIlwiLGRlbGF5OjAsaHRtbDohMSxzZWxlY3RvcjohMSxwbGFjZW1lbnQ6XCJ0b3BcIixjb250YWluZXI6ITEsZmFsbGJhY2tQbGFjZW1lbnRzOm51bGwsYm91bmRhcnk6XCJjbGlwcGluZ1BhcmVudHNcIixjdXN0b21DbGFzczpcIlwiLHNhbml0aXplOiEwLHNhbml0aXplRm46bnVsbCxhbGxvd0xpc3Q6eGUscG9wcGVyQ29uZmlnOm51bGx9LEhlPXtISURFOlwiaGlkZS5icy50b29sdGlwXCIsSElEREVOOlwiaGlkZGVuLmJzLnRvb2x0aXBcIixTSE9XOlwic2hvdy5icy50b29sdGlwXCIsU0hPV046XCJzaG93bi5icy50b29sdGlwXCIsSU5TRVJURUQ6XCJpbnNlcnRlZC5icy50b29sdGlwXCIsQ0xJQ0s6XCJjbGljay5icy50b29sdGlwXCIsRk9DVVNJTjpcImZvY3VzaW4uYnMudG9vbHRpcFwiLEZPQ1VTT1VUOlwiZm9jdXNvdXQuYnMudG9vbHRpcFwiLE1PVVNFRU5URVI6XCJtb3VzZWVudGVyLmJzLnRvb2x0aXBcIixNT1VTRUxFQVZFOlwibW91c2VsZWF2ZS5icy50b29sdGlwXCJ9LFJlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuKXt2YXIgaTtpZih2b2lkIDA9PT1kZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIik7cmV0dXJuKGk9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLl9pc0VuYWJsZWQ9ITAsaS5fdGltZW91dD0wLGkuX2hvdmVyU3RhdGU9XCJcIixpLl9hY3RpdmVUcmlnZ2VyPXt9LGkuX3BvcHBlcj1udWxsLGkuY29uZmlnPWkuX2dldENvbmZpZyhuKSxpLnRpcD1udWxsLGkuX3NldExpc3RlbmVycygpLGl9aShvLHQpO3ZhciByPW8ucHJvdG90eXBlO3JldHVybiByLmVuYWJsZT1mdW5jdGlvbigpe3RoaXMuX2lzRW5hYmxlZD0hMH0sci5kaXNhYmxlPWZ1bmN0aW9uKCl7dGhpcy5faXNFbmFibGVkPSExfSxyLnRvZ2dsZUVuYWJsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9pc0VuYWJsZWQ9IXRoaXMuX2lzRW5hYmxlZH0sci50b2dnbGU9ZnVuY3Rpb24odCl7aWYodGhpcy5faXNFbmFibGVkKWlmKHQpe3ZhciBlPXRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksbj1UKHQuZGVsZWdhdGVUYXJnZXQsZSk7bnx8KG49bmV3IHRoaXMuY29uc3RydWN0b3IodC5kZWxlZ2F0ZVRhcmdldCx0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKSxFKHQuZGVsZWdhdGVUYXJnZXQsZSxuKSksbi5fYWN0aXZlVHJpZ2dlci5jbGljaz0hbi5fYWN0aXZlVHJpZ2dlci5jbGljayxuLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCk/bi5fZW50ZXIobnVsbCxuKTpuLl9sZWF2ZShudWxsLG4pfWVsc2V7aWYodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSlyZXR1cm4gdm9pZCB0aGlzLl9sZWF2ZShudWxsLHRoaXMpO3RoaXMuX2VudGVyKG51bGwsdGhpcyl9fSxyLmRpc3Bvc2U9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksSC5vZmYodGhpcy5fZWxlbWVudCx0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSksSC5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KFwiLm1vZGFsXCIpLFwiaGlkZS5icy5tb2RhbFwiLHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpLHRoaXMudGlwJiZ0aGlzLnRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGlwKSx0aGlzLl9pc0VuYWJsZWQ9bnVsbCx0aGlzLl90aW1lb3V0PW51bGwsdGhpcy5faG92ZXJTdGF0ZT1udWxsLHRoaXMuX2FjdGl2ZVRyaWdnZXI9bnVsbCx0aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5kZXN0cm95KCksdGhpcy5fcG9wcGVyPW51bGwsdGhpcy5jb25maWc9bnVsbCx0aGlzLnRpcD1udWxsLHQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKX0sci5zaG93PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZihcIm5vbmVcIj09PXRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50c1wiKTtpZih0aGlzLmlzV2l0aENvbnRlbnQoKSYmdGhpcy5faXNFbmFibGVkKXt2YXIgZT1ILnRyaWdnZXIodGhpcy5fZWxlbWVudCx0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpLG49ZnVuY3Rpb24gdChlKXtpZighZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdylyZXR1cm4gbnVsbDtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldFJvb3ROb2RlKXt2YXIgbj1lLmdldFJvb3ROb2RlKCk7cmV0dXJuIG4gaW5zdGFuY2VvZiBTaGFkb3dSb290P246bnVsbH1yZXR1cm4gZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q/ZTplLnBhcmVudE5vZGU/dChlLnBhcmVudE5vZGUpOm51bGx9KHRoaXMuX2VsZW1lbnQpLGk9bnVsbD09PW4/dGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLl9lbGVtZW50KTpuLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO2lmKGUuZGVmYXVsdFByZXZlbnRlZHx8IWkpcmV0dXJuO3ZhciBvPXRoaXMuZ2V0VGlwRWxlbWVudCgpLHI9cyh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO28uc2V0QXR0cmlidXRlKFwiaWRcIixyKSx0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixyKSx0aGlzLnNldENvbnRlbnQoKSx0aGlzLmNvbmZpZy5hbmltYXRpb24mJm8uY2xhc3NMaXN0LmFkZChcImZhZGVcIik7dmFyIGE9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcucGxhY2VtZW50P3RoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsbyx0aGlzLl9lbGVtZW50KTp0aGlzLmNvbmZpZy5wbGFjZW1lbnQsbD10aGlzLl9nZXRBdHRhY2htZW50KGEpO3RoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyhsKTt2YXIgYz10aGlzLl9nZXRDb250YWluZXIoKTtFKG8sdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSx0aGlzKSx0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKXx8Yy5hcHBlbmRDaGlsZChvKSxILnRyaWdnZXIodGhpcy5fZWxlbWVudCx0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSx0aGlzLl9wb3BwZXI9ZmUodGhpcy5fZWxlbWVudCxvLHRoaXMuX2dldFBvcHBlckNvbmZpZyhsKSksby5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTt2YXIgZixkLHA9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcuY3VzdG9tQ2xhc3M/dGhpcy5jb25maWcuY3VzdG9tQ2xhc3MoKTp0aGlzLmNvbmZpZy5jdXN0b21DbGFzcztpZihwKShmPW8uY2xhc3NMaXN0KS5hZGQuYXBwbHkoZixwLnNwbGl0KFwiIFwiKSk7aWYoXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkoZD1bXSkuY29uY2F0LmFwcGx5KGQsZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgoZnVuY3Rpb24odCl7SC5vbih0LFwibW91c2VvdmVyXCIsKGZ1bmN0aW9uKCl7fSkpfSkpO3ZhciBnPWZ1bmN0aW9uKCl7dmFyIGU9dC5faG92ZXJTdGF0ZTt0Ll9ob3ZlclN0YXRlPW51bGwsSC50cmlnZ2VyKHQuX2VsZW1lbnQsdC5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksXCJvdXRcIj09PWUmJnQuX2xlYXZlKG51bGwsdCl9O2lmKHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcImZhZGVcIikpe3ZhciBtPXUodGhpcy50aXApO0gub25lKHRoaXMudGlwLFwidHJhbnNpdGlvbmVuZFwiLGcpLGgodGhpcy50aXAsbSl9ZWxzZSBnKCl9fSxyLmhpZGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHRoaXMuX3BvcHBlcil7dmFyIGU9dGhpcy5nZXRUaXBFbGVtZW50KCksbj1mdW5jdGlvbigpe1wic2hvd1wiIT09dC5faG92ZXJTdGF0ZSYmZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksdC5fY2xlYW5UaXBDbGFzcygpLHQuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiKSxILnRyaWdnZXIodC5fZWxlbWVudCx0LmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTiksdC5fcG9wcGVyJiYodC5fcG9wcGVyLmRlc3Ryb3koKSx0Ll9wb3BwZXI9bnVsbCl9O2lmKCFILnRyaWdnZXIodGhpcy5fZWxlbWVudCx0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpLmRlZmF1bHRQcmV2ZW50ZWQpe3ZhciBpO2lmKGUuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIiksXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkoaT1bXSkuY29uY2F0LmFwcGx5KGksZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIEgub2ZmKHQsXCJtb3VzZW92ZXJcIixtKX0pKTtpZih0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrPSExLHRoaXMuX2FjdGl2ZVRyaWdnZXIuZm9jdXM9ITEsdGhpcy5fYWN0aXZlVHJpZ2dlci5ob3Zlcj0hMSx0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpKXt2YXIgbz11KGUpO0gub25lKGUsXCJ0cmFuc2l0aW9uZW5kXCIsbiksaChlLG8pfWVsc2UgbigpO3RoaXMuX2hvdmVyU3RhdGU9XCJcIn19fSxyLnVwZGF0ZT1mdW5jdGlvbigpe251bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci51cGRhdGUoKX0sci5pc1dpdGhDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKX0sci5nZXRUaXBFbGVtZW50PWZ1bmN0aW9uKCl7aWYodGhpcy50aXApcmV0dXJuIHRoaXMudGlwO3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIHQuaW5uZXJIVE1MPXRoaXMuY29uZmlnLnRlbXBsYXRlLHRoaXMudGlwPXQuY2hpbGRyZW5bMF0sdGhpcy50aXB9LHIuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0VGlwRWxlbWVudCgpO3RoaXMuc2V0RWxlbWVudENvbnRlbnQocS5maW5kT25lKFwiLnRvb2x0aXAtaW5uZXJcIix0KSx0aGlzLmdldFRpdGxlKCkpLHQuY2xhc3NMaXN0LnJlbW92ZShcImZhZGVcIixcInNob3dcIil9LHIuc2V0RWxlbWVudENvbnRlbnQ9ZnVuY3Rpb24odCxlKXtpZihudWxsIT09dClyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZSYmZChlKT8oZS5qcXVlcnkmJihlPWVbMF0pLHZvaWQodGhpcy5jb25maWcuaHRtbD9lLnBhcmVudE5vZGUhPT10JiYodC5pbm5lckhUTUw9XCJcIix0LmFwcGVuZENoaWxkKGUpKTp0LnRleHRDb250ZW50PWUudGV4dENvbnRlbnQpKTp2b2lkKHRoaXMuY29uZmlnLmh0bWw/KHRoaXMuY29uZmlnLnNhbml0aXplJiYoZT1TZShlLHRoaXMuY29uZmlnLmFsbG93TGlzdCx0aGlzLmNvbmZpZy5zYW5pdGl6ZUZuKSksdC5pbm5lckhUTUw9ZSk6dC50ZXh0Q29udGVudD1lKX0sci5nZXRUaXRsZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1icy1vcmlnaW5hbC10aXRsZVwiKTtyZXR1cm4gdHx8KHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcudGl0bGU/dGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLl9lbGVtZW50KTp0aGlzLmNvbmZpZy50aXRsZSksdH0sci51cGRhdGVBdHRhY2htZW50PWZ1bmN0aW9uKHQpe3JldHVyblwicmlnaHRcIj09PXQ/XCJlbmRcIjpcImxlZnRcIj09PXQ/XCJzdGFydFwiOnR9LHIuX2dldFBvcHBlckNvbmZpZz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLGk9e25hbWU6XCJmbGlwXCIsb3B0aW9uczp7YWx0Qm91bmRhcnk6ITB9fTtyZXR1cm4gdGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzJiYoaS5vcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cz10aGlzLmNvbmZpZy5mYWxsYmFja1BsYWNlbWVudHMpLG4oe30se3BsYWNlbWVudDp0LG1vZGlmaWVyczpbaSx7bmFtZTpcInByZXZlbnRPdmVyZmxvd1wiLG9wdGlvbnM6e3Jvb3RCb3VuZGFyeTp0aGlzLmNvbmZpZy5ib3VuZGFyeX19LHtuYW1lOlwiYXJyb3dcIixvcHRpb25zOntlbGVtZW50OlwiLlwiK3RoaXMuY29uc3RydWN0b3IuTkFNRStcIi1hcnJvd1wifX0se25hbWU6XCJvbkNoYW5nZVwiLGVuYWJsZWQ6ITAscGhhc2U6XCJhZnRlcldyaXRlXCIsZm46ZnVuY3Rpb24odCl7cmV0dXJuIGUuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSh0KX19XSxvbkZpcnN0VXBkYXRlOmZ1bmN0aW9uKHQpe3Qub3B0aW9ucy5wbGFjZW1lbnQhPT10LnBsYWNlbWVudCYmZS5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpfX0sdGhpcy5jb25maWcucG9wcGVyQ29uZmlnKX0sci5fYWRkQXR0YWNobWVudENsYXNzPWZ1bmN0aW9uKHQpe3RoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXCJicy10b29sdGlwLVwiK3RoaXMudXBkYXRlQXR0YWNobWVudCh0KSl9LHIuX2dldENvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiExPT09dGhpcy5jb25maWcuY29udGFpbmVyP2RvY3VtZW50LmJvZHk6ZCh0aGlzLmNvbmZpZy5jb250YWluZXIpP3RoaXMuY29uZmlnLmNvbnRhaW5lcjpxLmZpbmRPbmUodGhpcy5jb25maWcuY29udGFpbmVyKX0sci5fZ2V0QXR0YWNobWVudD1mdW5jdGlvbih0KXtyZXR1cm4gTWVbdC50b1VwcGVyQ2FzZSgpXX0sci5fc2V0TGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihcImNsaWNrXCI9PT1lKUgub24odC5fZWxlbWVudCx0LmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLHQuY29uZmlnLnNlbGVjdG9yLChmdW5jdGlvbihlKXtyZXR1cm4gdC50b2dnbGUoZSl9KSk7ZWxzZSBpZihcIm1hbnVhbFwiIT09ZSl7dmFyIG49XCJob3ZlclwiPT09ZT90LmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVI6dC5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOLGk9XCJob3ZlclwiPT09ZT90LmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkU6dC5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtILm9uKHQuX2VsZW1lbnQsbix0LmNvbmZpZy5zZWxlY3RvciwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuX2VudGVyKGUpfSkpLEgub24odC5fZWxlbWVudCxpLHQuY29uZmlnLnNlbGVjdG9yLChmdW5jdGlvbihlKXtyZXR1cm4gdC5fbGVhdmUoZSl9KSl9fSkpLHRoaXMuX2hpZGVNb2RhbEhhbmRsZXI9ZnVuY3Rpb24oKXt0Ll9lbGVtZW50JiZ0LmhpZGUoKX0sSC5vbih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoXCIubW9kYWxcIiksXCJoaWRlLmJzLm1vZGFsXCIsdGhpcy5faGlkZU1vZGFsSGFuZGxlciksdGhpcy5jb25maWcuc2VsZWN0b3I/dGhpcy5jb25maWc9bih7fSx0aGlzLmNvbmZpZyx7dHJpZ2dlcjpcIm1hbnVhbFwiLHNlbGVjdG9yOlwiXCJ9KTp0aGlzLl9maXhUaXRsZSgpfSxyLl9maXhUaXRsZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGl0bGVcIiksZT10eXBlb2YgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJzLW9yaWdpbmFsLXRpdGxlXCIpOyh0fHxcInN0cmluZ1wiIT09ZSkmJih0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtYnMtb3JpZ2luYWwtdGl0bGVcIix0fHxcIlwiKSwhdHx8dGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpfHx0aGlzLl9lbGVtZW50LnRleHRDb250ZW50fHx0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIix0KSx0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJcIikpfSxyLl9lbnRlcj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7KGU9ZXx8VCh0LmRlbGVnYXRlVGFyZ2V0LG4pKXx8KGU9bmV3IHRoaXMuY29uc3RydWN0b3IodC5kZWxlZ2F0ZVRhcmdldCx0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKSxFKHQuZGVsZWdhdGVUYXJnZXQsbixlKSksdCYmKGUuX2FjdGl2ZVRyaWdnZXJbXCJmb2N1c2luXCI9PT10LnR5cGU/XCJmb2N1c1wiOlwiaG92ZXJcIl09ITApLGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIil8fFwic2hvd1wiPT09ZS5faG92ZXJTdGF0ZT9lLl9ob3ZlclN0YXRlPVwic2hvd1wiOihjbGVhclRpbWVvdXQoZS5fdGltZW91dCksZS5faG92ZXJTdGF0ZT1cInNob3dcIixlLmNvbmZpZy5kZWxheSYmZS5jb25maWcuZGVsYXkuc2hvdz9lLl90aW1lb3V0PXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7XCJzaG93XCI9PT1lLl9ob3ZlclN0YXRlJiZlLnNob3coKX0pLGUuY29uZmlnLmRlbGF5LnNob3cpOmUuc2hvdygpKX0sci5fbGVhdmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZOyhlPWV8fFQodC5kZWxlZ2F0ZVRhcmdldCxuKSl8fChlPW5ldyB0aGlzLmNvbnN0cnVjdG9yKHQuZGVsZWdhdGVUYXJnZXQsdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSksRSh0LmRlbGVnYXRlVGFyZ2V0LG4sZSkpLHQmJihlLl9hY3RpdmVUcmlnZ2VyW1wiZm9jdXNvdXRcIj09PXQudHlwZT9cImZvY3VzXCI6XCJob3ZlclwiXT0hMSksZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpfHwoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLGUuX2hvdmVyU3RhdGU9XCJvdXRcIixlLmNvbmZpZy5kZWxheSYmZS5jb25maWcuZGVsYXkuaGlkZT9lLl90aW1lb3V0PXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7XCJvdXRcIj09PWUuX2hvdmVyU3RhdGUmJmUuaGlkZSgpfSksZS5jb25maWcuZGVsYXkuaGlkZSk6ZS5oaWRlKCkpfSxyLl9pc1dpdGhBY3RpdmVUcmlnZ2VyPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpaWYodGhpcy5fYWN0aXZlVHJpZ2dlclt0XSlyZXR1cm4hMDtyZXR1cm4hMX0sci5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe3ZhciBlPVkuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe0llLmhhcyh0KSYmZGVsZXRlIGVbdF19KSksdCYmXCJvYmplY3RcIj09dHlwZW9mIHQuY29udGFpbmVyJiZ0LmNvbnRhaW5lci5qcXVlcnkmJih0LmNvbnRhaW5lcj10LmNvbnRhaW5lclswXSksXCJudW1iZXJcIj09dHlwZW9mKHQ9bih7fSx0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsZSxcIm9iamVjdFwiPT10eXBlb2YgdCYmdD90Ont9KSkuZGVsYXkmJih0LmRlbGF5PXtzaG93OnQuZGVsYXksaGlkZTp0LmRlbGF5fSksXCJudW1iZXJcIj09dHlwZW9mIHQudGl0bGUmJih0LnRpdGxlPXQudGl0bGUudG9TdHJpbmcoKSksXCJudW1iZXJcIj09dHlwZW9mIHQuY29udGVudCYmKHQuY29udGVudD10LmNvbnRlbnQudG9TdHJpbmcoKSkscChqZSx0LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLHQuc2FuaXRpemUmJih0LnRlbXBsYXRlPVNlKHQudGVtcGxhdGUsdC5hbGxvd0xpc3QsdC5zYW5pdGl6ZUZuKSksdH0sci5fZ2V0RGVsZWdhdGVDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17fTtpZih0aGlzLmNvbmZpZylmb3IodmFyIGUgaW4gdGhpcy5jb25maWcpdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdIT09dGhpcy5jb25maWdbZV0mJih0W2VdPXRoaXMuY29uZmlnW2VdKTtyZXR1cm4gdH0sci5fY2xlYW5UaXBDbGFzcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0VGlwRWxlbWVudCgpLGU9dC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5tYXRjaChOZSk7bnVsbCE9PWUmJmUubGVuZ3RoPjAmJmUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCl9KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2xhc3NMaXN0LnJlbW92ZShlKX0pKX0sci5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGU7ZSYmKHRoaXMudGlwPWUuZWxlbWVudHMucG9wcGVyLHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSx0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3ModGhpcy5fZ2V0QXR0YWNobWVudChlLnBsYWNlbWVudCkpKX0sby5qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWFjaCgoZnVuY3Rpb24oKXt2YXIgZT1UKHRoaXMsXCJicy50b29sdGlwXCIpLG49XCJvYmplY3RcIj09dHlwZW9mIHQmJnQ7aWYoKGV8fCEvZGlzcG9zZXxoaWRlLy50ZXN0KHQpKSYmKGV8fChlPW5ldyBvKHRoaXMsbikpLFwic3RyaW5nXCI9PXR5cGVvZiB0KSl7aWYodm9pZCAwPT09ZVt0XSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK3QrJ1wiJyk7ZVt0XSgpfX0pKX0sZShvLG51bGwsW3trZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJlfX0se2tleTpcIk5BTUVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gamV9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLnRvb2x0aXBcIn19LHtrZXk6XCJFdmVudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBIZX19LHtrZXk6XCJFVkVOVF9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIi5icy50b29sdGlwXCJ9fSx7a2V5OlwiRGVmYXVsdFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGV9fV0pLG99KFIpO2IoKGZ1bmN0aW9uKCl7dmFyIHQ9XygpO2lmKHQpe3ZhciBlPXQuZm5bamVdO3QuZm5bamVdPVJlLmpRdWVyeUludGVyZmFjZSx0LmZuW2plXS5Db25zdHJ1Y3Rvcj1SZSx0LmZuW2plXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm5bamVdPWUsUmUualF1ZXJ5SW50ZXJmYWNlfX19KSk7dmFyIFdlPVwicG9wb3ZlclwiLEtlPW5ldyBSZWdFeHAoXCIoXnxcXFxccylicy1wb3BvdmVyXFxcXFMrXCIsXCJnXCIpLFFlPW4oe30sUmUuRGVmYXVsdCx7cGxhY2VtZW50OlwicmlnaHRcIix0cmlnZ2VyOlwiY2xpY2tcIixjb250ZW50OlwiXCIsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+J30pLFVlPW4oe30sUmUuRGVmYXVsdFR5cGUse2NvbnRlbnQ6XCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCJ9KSxGZT17SElERTpcImhpZGUuYnMucG9wb3ZlclwiLEhJRERFTjpcImhpZGRlbi5icy5wb3BvdmVyXCIsU0hPVzpcInNob3cuYnMucG9wb3ZlclwiLFNIT1dOOlwic2hvd24uYnMucG9wb3ZlclwiLElOU0VSVEVEOlwiaW5zZXJ0ZWQuYnMucG9wb3ZlclwiLENMSUNLOlwiY2xpY2suYnMucG9wb3ZlclwiLEZPQ1VTSU46XCJmb2N1c2luLmJzLnBvcG92ZXJcIixGT0NVU09VVDpcImZvY3Vzb3V0LmJzLnBvcG92ZXJcIixNT1VTRUVOVEVSOlwibW91c2VlbnRlci5icy5wb3BvdmVyXCIsTU9VU0VMRUFWRTpcIm1vdXNlbGVhdmUuYnMucG9wb3ZlclwifSxZZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfWkobix0KTt2YXIgbz1uLnByb3RvdHlwZTtyZXR1cm4gby5pc1dpdGhDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VGl0bGUoKXx8dGhpcy5fZ2V0Q29udGVudCgpfSxvLnNldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFRpcEVsZW1lbnQoKTt0aGlzLnNldEVsZW1lbnRDb250ZW50KHEuZmluZE9uZShcIi5wb3BvdmVyLWhlYWRlclwiLHQpLHRoaXMuZ2V0VGl0bGUoKSk7dmFyIGU9dGhpcy5fZ2V0Q29udGVudCgpO1wiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihlPWUuY2FsbCh0aGlzLl9lbGVtZW50KSksdGhpcy5zZXRFbGVtZW50Q29udGVudChxLmZpbmRPbmUoXCIucG9wb3Zlci1ib2R5XCIsdCksZSksdC5jbGFzc0xpc3QucmVtb3ZlKFwiZmFkZVwiLFwic2hvd1wiKX0sby5fYWRkQXR0YWNobWVudENsYXNzPWZ1bmN0aW9uKHQpe3RoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXCJicy1wb3BvdmVyLVwiK3RoaXMudXBkYXRlQXR0YWNobWVudCh0KSl9LG8uX2dldENvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJzLWNvbnRlbnRcIil8fHRoaXMuY29uZmlnLmNvbnRlbnR9LG8uX2NsZWFuVGlwQ2xhc3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFRpcEVsZW1lbnQoKSxlPXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikubWF0Y2goS2UpO251bGwhPT1lJiZlLmxlbmd0aD4wJiZlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJpbSgpfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB0LmNsYXNzTGlzdC5yZW1vdmUoZSl9KSl9LG4ualF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVhY2goKGZ1bmN0aW9uKCl7dmFyIGU9VCh0aGlzLFwiYnMucG9wb3ZlclwiKSxpPVwib2JqZWN0XCI9PXR5cGVvZiB0P3Q6bnVsbDtpZigoZXx8IS9kaXNwb3NlfGhpZGUvLnRlc3QodCkpJiYoZXx8KGU9bmV3IG4odGhpcyxpKSxFKHRoaXMsXCJicy5wb3BvdmVyXCIsZSkpLFwic3RyaW5nXCI9PXR5cGVvZiB0KSl7aWYodm9pZCAwPT09ZVt0XSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK3QrJ1wiJyk7ZVt0XSgpfX0pKX0sZShuLG51bGwsW3trZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFFlfX0se2tleTpcIk5BTUVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gV2V9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLnBvcG92ZXJcIn19LHtrZXk6XCJFdmVudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBGZX19LHtrZXk6XCJFVkVOVF9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIi5icy5wb3BvdmVyXCJ9fSx7a2V5OlwiRGVmYXVsdFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gVWV9fV0pLG59KFJlKTtiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuW1dlXTt0LmZuW1dlXT1ZZS5qUXVlcnlJbnRlcmZhY2UsdC5mbltXZV0uQ29uc3RydWN0b3I9WWUsdC5mbltXZV0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB0LmZuW1dlXT1lLFllLmpRdWVyeUludGVyZmFjZX19fSkpO3ZhciBxZT1cInNjcm9sbHNweVwiLHplPXtvZmZzZXQ6MTAsbWV0aG9kOlwiYXV0b1wiLHRhcmdldDpcIlwifSxWZT17b2Zmc2V0OlwibnVtYmVyXCIsbWV0aG9kOlwic3RyaW5nXCIsdGFyZ2V0OlwiKHN0cmluZ3xlbGVtZW50KVwifSxYZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLl9zY3JvbGxFbGVtZW50PVwiQk9EWVwiPT09ZS50YWdOYW1lP3dpbmRvdzplLGkuX2NvbmZpZz1pLl9nZXRDb25maWcobiksaS5fc2VsZWN0b3I9aS5fY29uZmlnLnRhcmdldCtcIiAubmF2LWxpbmssIFwiK2kuX2NvbmZpZy50YXJnZXQrXCIgLmxpc3QtZ3JvdXAtaXRlbSwgXCIraS5fY29uZmlnLnRhcmdldCtcIiAuZHJvcGRvd24taXRlbVwiLGkuX29mZnNldHM9W10saS5fdGFyZ2V0cz1bXSxpLl9hY3RpdmVUYXJnZXQ9bnVsbCxpLl9zY3JvbGxIZWlnaHQ9MCxILm9uKGkuX3Njcm9sbEVsZW1lbnQsXCJzY3JvbGwuYnMuc2Nyb2xsc3B5XCIsKGZ1bmN0aW9uKHQpe3JldHVybiBpLl9wcm9jZXNzKHQpfSkpLGkucmVmcmVzaCgpLGkuX3Byb2Nlc3MoKSxpfWkobyx0KTt2YXIgcj1vLnByb3RvdHlwZTtyZXR1cm4gci5yZWZyZXNoPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuX3Njcm9sbEVsZW1lbnQ9PT10aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdz9cIm9mZnNldFwiOlwicG9zaXRpb25cIixuPVwiYXV0b1wiPT09dGhpcy5fY29uZmlnLm1ldGhvZD9lOnRoaXMuX2NvbmZpZy5tZXRob2QsaT1cInBvc2l0aW9uXCI9PT1uP3RoaXMuX2dldFNjcm9sbFRvcCgpOjA7dGhpcy5fb2Zmc2V0cz1bXSx0aGlzLl90YXJnZXRzPVtdLHRoaXMuX3Njcm9sbEhlaWdodD10aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSxxLmZpbmQodGhpcy5fc2VsZWN0b3IpLm1hcCgoZnVuY3Rpb24odCl7dmFyIGU9bCh0KSxvPWU/cS5maW5kT25lKGUpOm51bGw7aWYobyl7dmFyIHI9by5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihyLndpZHRofHxyLmhlaWdodClyZXR1cm5bWVtuXShvKS50b3AraSxlXX1yZXR1cm4gbnVsbH0pKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMF0tZVswXX0pKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0Ll9vZmZzZXRzLnB1c2goZVswXSksdC5fdGFyZ2V0cy5wdXNoKGVbMV0pfSkpfSxyLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksSC5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCxcIi5icy5zY3JvbGxzcHlcIiksdGhpcy5fc2Nyb2xsRWxlbWVudD1udWxsLHRoaXMuX2NvbmZpZz1udWxsLHRoaXMuX3NlbGVjdG9yPW51bGwsdGhpcy5fb2Zmc2V0cz1udWxsLHRoaXMuX3RhcmdldHM9bnVsbCx0aGlzLl9hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLl9zY3JvbGxIZWlnaHQ9bnVsbH0sci5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZih0PW4oe30semUsXCJvYmplY3RcIj09dHlwZW9mIHQmJnQ/dDp7fSkpLnRhcmdldCYmZCh0LnRhcmdldCkpe3ZhciBlPXQudGFyZ2V0LmlkO2V8fChlPXMocWUpLHQudGFyZ2V0LmlkPWUpLHQudGFyZ2V0PVwiI1wiK2V9cmV0dXJuIHAocWUsdCxWZSksdH0sci5fZ2V0U2Nyb2xsVG9wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQ9PT13aW5kb3c/dGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldDp0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcH0sci5fZ2V0U2Nyb2xsSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0fHxNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KX0sci5fZ2V0T2Zmc2V0SGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQ9PT13aW5kb3c/d2luZG93LmlubmVySGVpZ2h0OnRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0fSxyLl9wcm9jZXNzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0U2Nyb2xsVG9wKCkrdGhpcy5fY29uZmlnLm9mZnNldCxlPXRoaXMuX2dldFNjcm9sbEhlaWdodCgpLG49dGhpcy5fY29uZmlnLm9mZnNldCtlLXRoaXMuX2dldE9mZnNldEhlaWdodCgpO2lmKHRoaXMuX3Njcm9sbEhlaWdodCE9PWUmJnRoaXMucmVmcmVzaCgpLHQ+PW4pe3ZhciBpPXRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGgtMV07dGhpcy5fYWN0aXZlVGFyZ2V0IT09aSYmdGhpcy5fYWN0aXZhdGUoaSl9ZWxzZXtpZih0aGlzLl9hY3RpdmVUYXJnZXQmJnQ8dGhpcy5fb2Zmc2V0c1swXSYmdGhpcy5fb2Zmc2V0c1swXT4wKXJldHVybiB0aGlzLl9hY3RpdmVUYXJnZXQ9bnVsbCx2b2lkIHRoaXMuX2NsZWFyKCk7Zm9yKHZhciBvPXRoaXMuX29mZnNldHMubGVuZ3RoO28tLTspe3RoaXMuX2FjdGl2ZVRhcmdldCE9PXRoaXMuX3RhcmdldHNbb10mJnQ+PXRoaXMuX29mZnNldHNbb10mJih2b2lkIDA9PT10aGlzLl9vZmZzZXRzW28rMV18fHQ8dGhpcy5fb2Zmc2V0c1tvKzFdKSYmdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tvXSl9fX0sci5fYWN0aXZhdGU9ZnVuY3Rpb24odCl7dGhpcy5fYWN0aXZlVGFyZ2V0PXQsdGhpcy5fY2xlYXIoKTt2YXIgZT10aGlzLl9zZWxlY3Rvci5zcGxpdChcIixcIikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZSsnW2RhdGEtYnMtdGFyZ2V0PVwiJyt0KydcIl0sJytlKydbaHJlZj1cIicrdCsnXCJdJ30pKSxuPXEuZmluZE9uZShlLmpvaW4oXCIsXCIpKTtuLmNsYXNzTGlzdC5jb250YWlucyhcImRyb3Bkb3duLWl0ZW1cIik/KHEuZmluZE9uZShcIi5kcm9wZG93bi10b2dnbGVcIixuLmNsb3Nlc3QoXCIuZHJvcGRvd25cIikpLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIiksbi5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpKToobi5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpLHEucGFyZW50cyhuLFwiLm5hdiwgLmxpc3QtZ3JvdXBcIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7cS5wcmV2KHQsXCIubmF2LWxpbmssIC5saXN0LWdyb3VwLWl0ZW1cIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKX0pKSxxLnByZXYodCxcIi5uYXYtaXRlbVwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXtxLmNoaWxkcmVuKHQsXCIubmF2LWxpbmtcIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKX0pKX0pKX0pKSksSC50cmlnZ2VyKHRoaXMuX3Njcm9sbEVsZW1lbnQsXCJhY3RpdmF0ZS5icy5zY3JvbGxzcHlcIix7cmVsYXRlZFRhcmdldDp0fSl9LHIuX2NsZWFyPWZ1bmN0aW9uKCl7cS5maW5kKHRoaXMuX3NlbGVjdG9yKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKX0pKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpfSkpfSxvLmpRdWVyeUludGVyZmFjZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoKChmdW5jdGlvbigpe3ZhciBlPVQodGhpcyxcImJzLnNjcm9sbHNweVwiKTtpZihlfHwoZT1uZXcgbyh0aGlzLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0KSksXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKHZvaWQgMD09PWVbdF0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyt0KydcIicpO2VbdF0oKX19KSl9LGUobyxudWxsLFt7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB6ZX19LHtrZXk6XCJEQVRBX0tFWVwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiYnMuc2Nyb2xsc3B5XCJ9fV0pLG99KFIpO0gub24od2luZG93LFwibG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGlcIiwoZnVuY3Rpb24oKXtxLmZpbmQoJ1tkYXRhLWJzLXNweT1cInNjcm9sbFwiXScpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgWGUodCxZLmdldERhdGFBdHRyaWJ1dGVzKHQpKX0pKX0pKSxiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuW3FlXTt0LmZuW3FlXT1YZS5qUXVlcnlJbnRlcmZhY2UsdC5mbltxZV0uQ29uc3RydWN0b3I9WGUsdC5mbltxZV0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB0LmZuW3FlXT1lLFhlLmpRdWVyeUludGVyZmFjZX19fSkpO3ZhciAkZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfWkobix0KTt2YXIgbz1uLnByb3RvdHlwZTtyZXR1cm4gby5zaG93PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSYmdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpfHx0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpKSl7dmFyIGUsbj1jKHRoaXMuX2VsZW1lbnQpLGk9dGhpcy5fZWxlbWVudC5jbG9zZXN0KFwiLm5hdiwgLmxpc3QtZ3JvdXBcIik7aWYoaSl7dmFyIG89XCJVTFwiPT09aS5ub2RlTmFtZXx8XCJPTFwiPT09aS5ub2RlTmFtZT9cIjpzY29wZSA+IGxpID4gLmFjdGl2ZVwiOlwiLmFjdGl2ZVwiO2U9KGU9cS5maW5kKG8saSkpW2UubGVuZ3RoLTFdfXZhciByPW51bGw7aWYoZSYmKHI9SC50cmlnZ2VyKGUsXCJoaWRlLmJzLnRhYlwiLHtyZWxhdGVkVGFyZ2V0OnRoaXMuX2VsZW1lbnR9KSksIShILnRyaWdnZXIodGhpcy5fZWxlbWVudCxcInNob3cuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6ZX0pLmRlZmF1bHRQcmV2ZW50ZWR8fG51bGwhPT1yJiZyLmRlZmF1bHRQcmV2ZW50ZWQpKXt0aGlzLl9hY3RpdmF0ZSh0aGlzLl9lbGVtZW50LGkpO3ZhciBzPWZ1bmN0aW9uKCl7SC50cmlnZ2VyKGUsXCJoaWRkZW4uYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6dC5fZWxlbWVudH0pLEgudHJpZ2dlcih0Ll9lbGVtZW50LFwic2hvd24uYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6ZX0pfTtuP3RoaXMuX2FjdGl2YXRlKG4sbi5wYXJlbnROb2RlLHMpOnMoKX19fSxvLl9hY3RpdmF0ZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcyxvPSghZXx8XCJVTFwiIT09ZS5ub2RlTmFtZSYmXCJPTFwiIT09ZS5ub2RlTmFtZT9xLmNoaWxkcmVuKGUsXCIuYWN0aXZlXCIpOnEuZmluZChcIjpzY29wZSA+IGxpID4gLmFjdGl2ZVwiLGUpKVswXSxyPW4mJm8mJm8uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmFkZVwiKSxzPWZ1bmN0aW9uKCl7cmV0dXJuIGkuX3RyYW5zaXRpb25Db21wbGV0ZSh0LG8sbil9O2lmKG8mJnIpe3ZhciBhPXUobyk7by5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKSxILm9uZShvLFwidHJhbnNpdGlvbmVuZFwiLHMpLGgobyxhKX1lbHNlIHMoKX0sby5fdHJhbnNpdGlvbkNvbXBsZXRlPWZ1bmN0aW9uKHQsZSxuKXtpZihlKXtlLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7dmFyIGk9cS5maW5kT25lKFwiOnNjb3BlID4gLmRyb3Bkb3duLW1lbnUgLmFjdGl2ZVwiLGUucGFyZW50Tm9kZSk7aSYmaS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpLFwidGFiXCI9PT1lLmdldEF0dHJpYnV0ZShcInJvbGVcIikmJmUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCExKX0odC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpLFwidGFiXCI9PT10LmdldEF0dHJpYnV0ZShcInJvbGVcIikmJnQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCEwKSx2KHQpLHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmFkZVwiKSYmdC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKSx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkcm9wZG93bi1tZW51XCIpKSYmKHQuY2xvc2VzdChcIi5kcm9wZG93blwiKSYmcS5maW5kKFwiLmRyb3Bkb3duLXRvZ2dsZVwiKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpfSkpLHQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCEwKSk7biYmbigpfSxuLmpRdWVyeUludGVyZmFjZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lYWNoKChmdW5jdGlvbigpe3ZhciBlPVQodGhpcyxcImJzLnRhYlwiKXx8bmV3IG4odGhpcyk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKHZvaWQgMD09PWVbdF0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyt0KydcIicpO2VbdF0oKX19KSl9LGUobixudWxsLFt7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLnRhYlwifX1dKSxufShSKTtILm9uKGRvY3VtZW50LFwiY2xpY2suYnMudGFiLmRhdGEtYXBpXCIsJ1tkYXRhLWJzLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwibGlzdFwiXScsKGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSwoVCh0aGlzLFwiYnMudGFiXCIpfHxuZXcgJGUodGhpcykpLnNob3coKX0pKSxiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuLnRhYjt0LmZuLnRhYj0kZS5qUXVlcnlJbnRlcmZhY2UsdC5mbi50YWIuQ29uc3RydWN0b3I9JGUsdC5mbi50YWIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB0LmZuLnRhYj1lLCRlLmpRdWVyeUludGVyZmFjZX19fSkpO3ZhciBHZT17YW5pbWF0aW9uOlwiYm9vbGVhblwiLGF1dG9oaWRlOlwiYm9vbGVhblwiLGRlbGF5OlwibnVtYmVyXCJ9LFplPXthbmltYXRpb246ITAsYXV0b2hpZGU6ITAsZGVsYXk6NWUzfSxKZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLl9jb25maWc9aS5fZ2V0Q29uZmlnKG4pLGkuX3RpbWVvdXQ9bnVsbCxpLl9zZXRMaXN0ZW5lcnMoKSxpfWkobyx0KTt2YXIgcj1vLnByb3RvdHlwZTtyZXR1cm4gci5zaG93PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighSC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsXCJzaG93LmJzLnRvYXN0XCIpLmRlZmF1bHRQcmV2ZW50ZWQpe3RoaXMuX2NsZWFyVGltZW91dCgpLHRoaXMuX2NvbmZpZy5hbmltYXRpb24mJnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZhZGVcIik7dmFyIGU9ZnVuY3Rpb24oKXt0Ll9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93aW5nXCIpLHQuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNob3dcIiksSC50cmlnZ2VyKHQuX2VsZW1lbnQsXCJzaG93bi5icy50b2FzdFwiKSx0Ll9jb25maWcuYXV0b2hpZGUmJih0Ll90aW1lb3V0PXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5oaWRlKCl9KSx0Ll9jb25maWcuZGVsYXkpKX07aWYodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZVwiKSx2KHRoaXMuX2VsZW1lbnQpLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNob3dpbmdcIiksdGhpcy5fY29uZmlnLmFuaW1hdGlvbil7dmFyIG49dSh0aGlzLl9lbGVtZW50KTtILm9uZSh0aGlzLl9lbGVtZW50LFwidHJhbnNpdGlvbmVuZFwiLGUpLGgodGhpcy5fZWxlbWVudCxuKX1lbHNlIGUoKX19LHIuaGlkZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpJiYhSC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsXCJoaWRlLmJzLnRvYXN0XCIpLmRlZmF1bHRQcmV2ZW50ZWQpe3ZhciBlPWZ1bmN0aW9uKCl7dC5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlkZVwiKSxILnRyaWdnZXIodC5fZWxlbWVudCxcImhpZGRlbi5icy50b2FzdFwiKX07aWYodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKSx0aGlzLl9jb25maWcuYW5pbWF0aW9uKXt2YXIgbj11KHRoaXMuX2VsZW1lbnQpO0gub25lKHRoaXMuX2VsZW1lbnQsXCJ0cmFuc2l0aW9uZW5kXCIsZSksaCh0aGlzLl9lbGVtZW50LG4pfWVsc2UgZSgpfX0sci5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY2xlYXJUaW1lb3V0KCksdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpJiZ0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpLEgub2ZmKHRoaXMuX2VsZW1lbnQsXCJjbGljay5kaXNtaXNzLmJzLnRvYXN0XCIpLHQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9jb25maWc9bnVsbH0sci5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe3JldHVybiB0PW4oe30sWmUsWS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcIm9iamVjdFwiPT10eXBlb2YgdCYmdD90Ont9KSxwKFwidG9hc3RcIix0LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLHR9LHIuX3NldExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7SC5vbih0aGlzLl9lbGVtZW50LFwiY2xpY2suZGlzbWlzcy5icy50b2FzdFwiLCdbZGF0YS1icy1kaXNtaXNzPVwidG9hc3RcIl0nLChmdW5jdGlvbigpe3JldHVybiB0LmhpZGUoKX0pKX0sci5fY2xlYXJUaW1lb3V0PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLHRoaXMuX3RpbWVvdXQ9bnVsbH0sby5qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWFjaCgoZnVuY3Rpb24oKXt2YXIgZT1UKHRoaXMsXCJicy50b2FzdFwiKTtpZihlfHwoZT1uZXcgbyh0aGlzLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0KSksXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKHZvaWQgMD09PWVbdF0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyt0KydcIicpO2VbdF0odGhpcyl9fSkpfSxlKG8sbnVsbCxbe2tleTpcIkRlZmF1bHRUeXBlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEdlfX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gWmV9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLnRvYXN0XCJ9fV0pLG99KFIpO3JldHVybiBiKChmdW5jdGlvbigpe3ZhciB0PV8oKTtpZih0KXt2YXIgZT10LmZuLnRvYXN0O3QuZm4udG9hc3Q9SmUualF1ZXJ5SW50ZXJmYWNlLHQuZm4udG9hc3QuQ29uc3RydWN0b3I9SmUsdC5mbi50b2FzdC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm4udG9hc3Q9ZSxKZS5qUXVlcnlJbnRlcmZhY2V9fX0pKSx7QWxlcnQ6SyxCdXR0b246USxDYXJvdXNlbDpaLENvbGxhcHNlOm50LERyb3Bkb3duOlRlLE1vZGFsOkxlLFBvcG92ZXI6WWUsU2Nyb2xsU3B5OlhlLFRhYjokZSxUb2FzdDpKZSxUb29sdGlwOlJlfX0pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLmJ1bmRsZS5taW4uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.bundle.min.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("window._ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/**\r\n * We'll load the axios HTTP library which allows us to easily issue requests\r\n * to our Laravel back-end. This library automatically handles sending the\r\n * CSRF token as a header based on the value of the \"XSRF\" token cookie.\r\n */\n\nwindow.axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\nwindow.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';\n/**\r\n * Echo exposes an expressive API for subscribing to channels and listening\r\n * for events that are broadcast by Laravel. Echo and event broadcasting\r\n * allows your team to easily build robust real-time web applications.\r\n */\n// import Echo from 'laravel-echo';\n// window.Pusher = require('pusher-js');\n// window.Echo = new Echo({\n//     broadcaster: 'pusher',\n//     key: process.env.MIX_PUSHER_APP_KEY,\n//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n//     forceTLS: true\n// });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzP2Y1NjgiXSwibmFtZXMiOlsid2luZG93IiwiXyIsInJlcXVpcmUiLCJheGlvcyIsImRlZmF1bHRzIiwiaGVhZGVycyIsImNvbW1vbiJdLCJtYXBwaW5ncyI6IkFBQUFBLE1BQU0sQ0FBQ0MsQ0FBUCxHQUFXQyxtQkFBTyxDQUFDLCtDQUFELENBQWxCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQUYsTUFBTSxDQUFDRyxLQUFQLEdBQWVELG1CQUFPLENBQUMsNENBQUQsQ0FBdEI7QUFFQUYsTUFBTSxDQUFDRyxLQUFQLENBQWFDLFFBQWIsQ0FBc0JDLE9BQXRCLENBQThCQyxNQUE5QixDQUFxQyxrQkFBckMsSUFBMkQsZ0JBQTNEO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsid2luZG93Ll8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbi8qKlxyXG4gKiBXZSdsbCBsb2FkIHRoZSBheGlvcyBIVFRQIGxpYnJhcnkgd2hpY2ggYWxsb3dzIHVzIHRvIGVhc2lseSBpc3N1ZSByZXF1ZXN0c1xyXG4gKiB0byBvdXIgTGFyYXZlbCBiYWNrLWVuZC4gVGhpcyBsaWJyYXJ5IGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBzZW5kaW5nIHRoZVxyXG4gKiBDU1JGIHRva2VuIGFzIGEgaGVhZGVyIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgXCJYU1JGXCIgdG9rZW4gY29va2llLlxyXG4gKi9cclxuXHJcbndpbmRvdy5heGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XHJcblxyXG53aW5kb3cuYXhpb3MuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XHJcblxyXG4vKipcclxuICogRWNobyBleHBvc2VzIGFuIGV4cHJlc3NpdmUgQVBJIGZvciBzdWJzY3JpYmluZyB0byBjaGFubmVscyBhbmQgbGlzdGVuaW5nXHJcbiAqIGZvciBldmVudHMgdGhhdCBhcmUgYnJvYWRjYXN0IGJ5IExhcmF2ZWwuIEVjaG8gYW5kIGV2ZW50IGJyb2FkY2FzdGluZ1xyXG4gKiBhbGxvd3MgeW91ciB0ZWFtIHRvIGVhc2lseSBidWlsZCByb2J1c3QgcmVhbC10aW1lIHdlYiBhcHBsaWNhdGlvbnMuXHJcbiAqL1xyXG5cclxuLy8gaW1wb3J0IEVjaG8gZnJvbSAnbGFyYXZlbC1lY2hvJztcclxuXHJcbi8vIHdpbmRvdy5QdXNoZXIgPSByZXF1aXJlKCdwdXNoZXItanMnKTtcclxuXHJcbi8vIHdpbmRvdy5FY2hvID0gbmV3IEVjaG8oe1xyXG4vLyAgICAgYnJvYWRjYXN0ZXI6ICdwdXNoZXInLFxyXG4vLyAgICAga2V5OiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9LRVksXHJcbi8vICAgICBjbHVzdGVyOiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9DTFVTVEVSLFxyXG4vLyAgICAgZm9yY2VUTFM6IHRydWVcclxuLy8gfSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/js/swiper.min.js":
/*!************************************!*\
  !*** ./resources/js/swiper.min.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\r\n * Swiper 6.4.5\r\n * Most modern mobile touch slider and framework with hardware accelerated transitions\r\n * https://swiperjs.com\r\n *\r\n * Copyright 2014-2020 Vladimir Kharlampidi\r\n *\r\n * Released under the MIT License\r\n *\r\n * Released on: December 18, 2020\r\n */\n!function (e, t) {\n  \"object\" == ( false ? 0 : _typeof(exports)) && \"undefined\" != \"object\" ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(this, function () {\n  \"use strict\";\n\n  function e(e, t) {\n    for (var a = 0; a < t.length; a++) {\n      var i = t[a];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n    }\n  }\n\n  function t() {\n    return (t = Object.assign || function (e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var a = arguments[t];\n\n        for (var i in a) {\n          Object.prototype.hasOwnProperty.call(a, i) && (e[i] = a[i]);\n        }\n      }\n\n      return e;\n    }).apply(this, arguments);\n  }\n\n  function a(e) {\n    return null !== e && \"object\" == _typeof(e) && \"constructor\" in e && e.constructor === Object;\n  }\n\n  function i(e, t) {\n    void 0 === e && (e = {}), void 0 === t && (t = {}), Object.keys(t).forEach(function (s) {\n      void 0 === e[s] ? e[s] = t[s] : a(t[s]) && a(e[s]) && Object.keys(t[s]).length > 0 && i(e[s], t[s]);\n    });\n  }\n\n  var s = {\n    body: {},\n    addEventListener: function addEventListener() {},\n    removeEventListener: function removeEventListener() {},\n    activeElement: {\n      blur: function blur() {},\n      nodeName: \"\"\n    },\n    querySelector: function querySelector() {\n      return null;\n    },\n    querySelectorAll: function querySelectorAll() {\n      return [];\n    },\n    getElementById: function getElementById() {\n      return null;\n    },\n    createEvent: function createEvent() {\n      return {\n        initEvent: function initEvent() {}\n      };\n    },\n    createElement: function createElement() {\n      return {\n        children: [],\n        childNodes: [],\n        style: {},\n        setAttribute: function setAttribute() {},\n        getElementsByTagName: function getElementsByTagName() {\n          return [];\n        }\n      };\n    },\n    createElementNS: function createElementNS() {\n      return {};\n    },\n    importNode: function importNode() {\n      return null;\n    },\n    location: {\n      hash: \"\",\n      host: \"\",\n      hostname: \"\",\n      href: \"\",\n      origin: \"\",\n      pathname: \"\",\n      protocol: \"\",\n      search: \"\"\n    }\n  };\n\n  function r() {\n    var e = \"undefined\" != typeof document ? document : {};\n    return i(e, s), e;\n  }\n\n  var n = {\n    document: s,\n    navigator: {\n      userAgent: \"\"\n    },\n    location: {\n      hash: \"\",\n      host: \"\",\n      hostname: \"\",\n      href: \"\",\n      origin: \"\",\n      pathname: \"\",\n      protocol: \"\",\n      search: \"\"\n    },\n    history: {\n      replaceState: function replaceState() {},\n      pushState: function pushState() {},\n      go: function go() {},\n      back: function back() {}\n    },\n    CustomEvent: function CustomEvent() {\n      return this;\n    },\n    addEventListener: function addEventListener() {},\n    removeEventListener: function removeEventListener() {},\n    getComputedStyle: function getComputedStyle() {\n      return {\n        getPropertyValue: function getPropertyValue() {\n          return \"\";\n        }\n      };\n    },\n    Image: function Image() {},\n    Date: function Date() {},\n    screen: {},\n    setTimeout: function setTimeout() {},\n    clearTimeout: function clearTimeout() {},\n    matchMedia: function matchMedia() {\n      return {};\n    },\n    requestAnimationFrame: function requestAnimationFrame(e) {\n      return \"undefined\" == typeof setTimeout ? (e(), null) : setTimeout(e, 0);\n    },\n    cancelAnimationFrame: function cancelAnimationFrame(e) {\n      \"undefined\" != typeof setTimeout && clearTimeout(e);\n    }\n  };\n\n  function l() {\n    var e = \"undefined\" != typeof window ? window : {};\n    return i(e, n), e;\n  }\n\n  function o(e) {\n    return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function d(e, t) {\n    return (d = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n\n  function p() {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }\n\n  function u(e, t, a) {\n    return (u = p() ? Reflect.construct : function (e, t, a) {\n      var i = [null];\n      i.push.apply(i, t);\n      var s = new (Function.bind.apply(e, i))();\n      return a && d(s, a.prototype), s;\n    }).apply(null, arguments);\n  }\n\n  function c(e) {\n    var t = \"function\" == typeof Map ? new Map() : void 0;\n    return (c = function c(e) {\n      if (null === e || (a = e, -1 === Function.toString.call(a).indexOf(\"[native code]\"))) return e;\n      var a;\n      if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n\n      if (void 0 !== t) {\n        if (t.has(e)) return t.get(e);\n        t.set(e, i);\n      }\n\n      function i() {\n        return u(e, arguments, o(this).constructor);\n      }\n\n      return i.prototype = Object.create(e.prototype, {\n        constructor: {\n          value: i,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), d(i, e);\n    })(e);\n  }\n\n  var h = function (e) {\n    var t, a;\n\n    function i(t) {\n      var a, i, s;\n      return a = e.call.apply(e, [this].concat(t)) || this, i = function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(a), s = i.__proto__, Object.defineProperty(i, \"__proto__\", {\n        get: function get() {\n          return s;\n        },\n        set: function set(e) {\n          s.__proto__ = e;\n        }\n      }), a;\n    }\n\n    return a = e, (t = i).prototype = Object.create(a.prototype), t.prototype.constructor = t, t.__proto__ = a, i;\n  }(c(Array));\n\n  function v(e) {\n    void 0 === e && (e = []);\n    var t = [];\n    return e.forEach(function (e) {\n      Array.isArray(e) ? t.push.apply(t, v(e)) : t.push(e);\n    }), t;\n  }\n\n  function f(e, t) {\n    return Array.prototype.filter.call(e, t);\n  }\n\n  function m(e, t) {\n    var a = l(),\n        i = r(),\n        s = [];\n    if (!t && e instanceof h) return e;\n    if (!e) return new h(s);\n\n    if (\"string\" == typeof e) {\n      var n = e.trim();\n\n      if (n.indexOf(\"<\") >= 0 && n.indexOf(\">\") >= 0) {\n        var o = \"div\";\n        0 === n.indexOf(\"<li\") && (o = \"ul\"), 0 === n.indexOf(\"<tr\") && (o = \"tbody\"), 0 !== n.indexOf(\"<td\") && 0 !== n.indexOf(\"<th\") || (o = \"tr\"), 0 === n.indexOf(\"<tbody\") && (o = \"table\"), 0 === n.indexOf(\"<option\") && (o = \"select\");\n        var d = i.createElement(o);\n        d.innerHTML = n;\n\n        for (var p = 0; p < d.childNodes.length; p += 1) {\n          s.push(d.childNodes[p]);\n        }\n      } else s = function (e, t) {\n        if (\"string\" != typeof e) return [e];\n\n        for (var a = [], i = t.querySelectorAll(e), s = 0; s < i.length; s += 1) {\n          a.push(i[s]);\n        }\n\n        return a;\n      }(e.trim(), t || i);\n    } else if (e.nodeType || e === a || e === i) s.push(e);else if (Array.isArray(e)) {\n      if (e instanceof h) return e;\n      s = e;\n    }\n\n    return new h(function (e) {\n      for (var t = [], a = 0; a < e.length; a += 1) {\n        -1 === t.indexOf(e[a]) && t.push(e[a]);\n      }\n\n      return t;\n    }(s));\n  }\n\n  m.fn = h.prototype;\n  var g,\n      y,\n      w,\n      b = {\n    addClass: function addClass() {\n      for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++) {\n        t[a] = arguments[a];\n      }\n\n      var i = v(t.map(function (e) {\n        return e.split(\" \");\n      }));\n      return this.forEach(function (e) {\n        var t;\n        (t = e.classList).add.apply(t, i);\n      }), this;\n    },\n    removeClass: function removeClass() {\n      for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++) {\n        t[a] = arguments[a];\n      }\n\n      var i = v(t.map(function (e) {\n        return e.split(\" \");\n      }));\n      return this.forEach(function (e) {\n        var t;\n        (t = e.classList).remove.apply(t, i);\n      }), this;\n    },\n    hasClass: function hasClass() {\n      for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++) {\n        t[a] = arguments[a];\n      }\n\n      var i = v(t.map(function (e) {\n        return e.split(\" \");\n      }));\n      return f(this, function (e) {\n        return i.filter(function (t) {\n          return e.classList.contains(t);\n        }).length > 0;\n      }).length > 0;\n    },\n    toggleClass: function toggleClass() {\n      for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++) {\n        t[a] = arguments[a];\n      }\n\n      var i = v(t.map(function (e) {\n        return e.split(\" \");\n      }));\n      this.forEach(function (e) {\n        i.forEach(function (t) {\n          e.classList.toggle(t);\n        });\n      });\n    },\n    attr: function attr(e, t) {\n      if (1 === arguments.length && \"string\" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;\n\n      for (var a = 0; a < this.length; a += 1) {\n        if (2 === arguments.length) this[a].setAttribute(e, t);else for (var i in e) {\n          this[a][i] = e[i], this[a].setAttribute(i, e[i]);\n        }\n      }\n\n      return this;\n    },\n    removeAttr: function removeAttr(e) {\n      for (var t = 0; t < this.length; t += 1) {\n        this[t].removeAttribute(e);\n      }\n\n      return this;\n    },\n    transform: function transform(e) {\n      for (var t = 0; t < this.length; t += 1) {\n        this[t].style.transform = e;\n      }\n\n      return this;\n    },\n    transition: function transition(e) {\n      for (var t = 0; t < this.length; t += 1) {\n        this[t].style.transitionDuration = \"string\" != typeof e ? e + \"ms\" : e;\n      }\n\n      return this;\n    },\n    on: function on() {\n      for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++) {\n        t[a] = arguments[a];\n      }\n\n      var i = t[0],\n          s = t[1],\n          r = t[2],\n          n = t[3];\n\n      function l(e) {\n        var t = e.target;\n\n        if (t) {\n          var a = e.target.dom7EventData || [];\n          if (a.indexOf(e) < 0 && a.unshift(e), m(t).is(s)) r.apply(t, a);else for (var i = m(t).parents(), n = 0; n < i.length; n += 1) {\n            m(i[n]).is(s) && r.apply(i[n], a);\n          }\n        }\n      }\n\n      function o(e) {\n        var t = e && e.target && e.target.dom7EventData || [];\n        t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t);\n      }\n\n      \"function\" == typeof t[1] && (i = t[0], r = t[1], n = t[2], s = void 0), n || (n = !1);\n\n      for (var d, p = i.split(\" \"), u = 0; u < this.length; u += 1) {\n        var c = this[u];\n        if (s) for (d = 0; d < p.length; d += 1) {\n          var h = p[d];\n          c.dom7LiveListeners || (c.dom7LiveListeners = {}), c.dom7LiveListeners[h] || (c.dom7LiveListeners[h] = []), c.dom7LiveListeners[h].push({\n            listener: r,\n            proxyListener: l\n          }), c.addEventListener(h, l, n);\n        } else for (d = 0; d < p.length; d += 1) {\n          var v = p[d];\n          c.dom7Listeners || (c.dom7Listeners = {}), c.dom7Listeners[v] || (c.dom7Listeners[v] = []), c.dom7Listeners[v].push({\n            listener: r,\n            proxyListener: o\n          }), c.addEventListener(v, o, n);\n        }\n      }\n\n      return this;\n    },\n    off: function off() {\n      for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++) {\n        t[a] = arguments[a];\n      }\n\n      var i = t[0],\n          s = t[1],\n          r = t[2],\n          n = t[3];\n      \"function\" == typeof t[1] && (i = t[0], r = t[1], n = t[2], s = void 0), n || (n = !1);\n\n      for (var l = i.split(\" \"), o = 0; o < l.length; o += 1) {\n        for (var d = l[o], p = 0; p < this.length; p += 1) {\n          var u = this[p],\n              c = void 0;\n          if (!s && u.dom7Listeners ? c = u.dom7Listeners[d] : s && u.dom7LiveListeners && (c = u.dom7LiveListeners[d]), c && c.length) for (var h = c.length - 1; h >= 0; h -= 1) {\n            var v = c[h];\n            r && v.listener === r || r && v.listener && v.listener.dom7proxy && v.listener.dom7proxy === r ? (u.removeEventListener(d, v.proxyListener, n), c.splice(h, 1)) : r || (u.removeEventListener(d, v.proxyListener, n), c.splice(h, 1));\n          }\n        }\n      }\n\n      return this;\n    },\n    trigger: function trigger() {\n      for (var e = l(), t = arguments.length, a = new Array(t), i = 0; i < t; i++) {\n        a[i] = arguments[i];\n      }\n\n      for (var s = a[0].split(\" \"), r = a[1], n = 0; n < s.length; n += 1) {\n        for (var o = s[n], d = 0; d < this.length; d += 1) {\n          var p = this[d];\n\n          if (e.CustomEvent) {\n            var u = new e.CustomEvent(o, {\n              detail: r,\n              bubbles: !0,\n              cancelable: !0\n            });\n            p.dom7EventData = a.filter(function (e, t) {\n              return t > 0;\n            }), p.dispatchEvent(u), p.dom7EventData = [], delete p.dom7EventData;\n          }\n        }\n      }\n\n      return this;\n    },\n    transitionEnd: function transitionEnd(e) {\n      var t = this;\n      return e && t.on(\"transitionend\", function a(i) {\n        i.target === this && (e.call(this, i), t.off(\"transitionend\", a));\n      }), this;\n    },\n    outerWidth: function outerWidth(e) {\n      if (this.length > 0) {\n        if (e) {\n          var t = this.styles();\n          return this[0].offsetWidth + parseFloat(t.getPropertyValue(\"margin-right\")) + parseFloat(t.getPropertyValue(\"margin-left\"));\n        }\n\n        return this[0].offsetWidth;\n      }\n\n      return null;\n    },\n    outerHeight: function outerHeight(e) {\n      if (this.length > 0) {\n        if (e) {\n          var t = this.styles();\n          return this[0].offsetHeight + parseFloat(t.getPropertyValue(\"margin-top\")) + parseFloat(t.getPropertyValue(\"margin-bottom\"));\n        }\n\n        return this[0].offsetHeight;\n      }\n\n      return null;\n    },\n    styles: function styles() {\n      var e = l();\n      return this[0] ? e.getComputedStyle(this[0], null) : {};\n    },\n    offset: function offset() {\n      if (this.length > 0) {\n        var e = l(),\n            t = r(),\n            a = this[0],\n            i = a.getBoundingClientRect(),\n            s = t.body,\n            n = a.clientTop || s.clientTop || 0,\n            o = a.clientLeft || s.clientLeft || 0,\n            d = a === e ? e.scrollY : a.scrollTop,\n            p = a === e ? e.scrollX : a.scrollLeft;\n        return {\n          top: i.top + d - n,\n          left: i.left + p - o\n        };\n      }\n\n      return null;\n    },\n    css: function css(e, t) {\n      var a,\n          i = l();\n\n      if (1 === arguments.length) {\n        if (\"string\" != typeof e) {\n          for (a = 0; a < this.length; a += 1) {\n            for (var s in e) {\n              this[a].style[s] = e[s];\n            }\n          }\n\n          return this;\n        }\n\n        if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(e);\n      }\n\n      if (2 === arguments.length && \"string\" == typeof e) {\n        for (a = 0; a < this.length; a += 1) {\n          this[a].style[e] = t;\n        }\n\n        return this;\n      }\n\n      return this;\n    },\n    each: function each(e) {\n      return e ? (this.forEach(function (t, a) {\n        e.apply(t, [t, a]);\n      }), this) : this;\n    },\n    html: function html(e) {\n      if (void 0 === e) return this[0] ? this[0].innerHTML : null;\n\n      for (var t = 0; t < this.length; t += 1) {\n        this[t].innerHTML = e;\n      }\n\n      return this;\n    },\n    text: function text(e) {\n      if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;\n\n      for (var t = 0; t < this.length; t += 1) {\n        this[t].textContent = e;\n      }\n\n      return this;\n    },\n    is: function is(e) {\n      var t,\n          a,\n          i = l(),\n          s = r(),\n          n = this[0];\n      if (!n || void 0 === e) return !1;\n\n      if (\"string\" == typeof e) {\n        if (n.matches) return n.matches(e);\n        if (n.webkitMatchesSelector) return n.webkitMatchesSelector(e);\n        if (n.msMatchesSelector) return n.msMatchesSelector(e);\n\n        for (t = m(e), a = 0; a < t.length; a += 1) {\n          if (t[a] === n) return !0;\n        }\n\n        return !1;\n      }\n\n      if (e === s) return n === s;\n      if (e === i) return n === i;\n\n      if (e.nodeType || e instanceof h) {\n        for (t = e.nodeType ? [e] : e, a = 0; a < t.length; a += 1) {\n          if (t[a] === n) return !0;\n        }\n\n        return !1;\n      }\n\n      return !1;\n    },\n    index: function index() {\n      var e,\n          t = this[0];\n\n      if (t) {\n        for (e = 0; null !== (t = t.previousSibling);) {\n          1 === t.nodeType && (e += 1);\n        }\n\n        return e;\n      }\n    },\n    eq: function eq(e) {\n      if (void 0 === e) return this;\n      var t = this.length;\n      if (e > t - 1) return m([]);\n\n      if (e < 0) {\n        var a = t + e;\n        return m(a < 0 ? [] : [this[a]]);\n      }\n\n      return m([this[e]]);\n    },\n    append: function append() {\n      for (var e, t = r(), a = 0; a < arguments.length; a += 1) {\n        e = a < 0 || arguments.length <= a ? void 0 : arguments[a];\n\n        for (var i = 0; i < this.length; i += 1) {\n          if (\"string\" == typeof e) {\n            var s = t.createElement(\"div\");\n\n            for (s.innerHTML = e; s.firstChild;) {\n              this[i].appendChild(s.firstChild);\n            }\n          } else if (e instanceof h) for (var n = 0; n < e.length; n += 1) {\n            this[i].appendChild(e[n]);\n          } else this[i].appendChild(e);\n        }\n      }\n\n      return this;\n    },\n    prepend: function prepend(e) {\n      var t,\n          a,\n          i = r();\n\n      for (t = 0; t < this.length; t += 1) {\n        if (\"string\" == typeof e) {\n          var s = i.createElement(\"div\");\n\n          for (s.innerHTML = e, a = s.childNodes.length - 1; a >= 0; a -= 1) {\n            this[t].insertBefore(s.childNodes[a], this[t].childNodes[0]);\n          }\n        } else if (e instanceof h) for (a = 0; a < e.length; a += 1) {\n          this[t].insertBefore(e[a], this[t].childNodes[0]);\n        } else this[t].insertBefore(e, this[t].childNodes[0]);\n      }\n\n      return this;\n    },\n    next: function next(e) {\n      return this.length > 0 ? e ? this[0].nextElementSibling && m(this[0].nextElementSibling).is(e) ? m([this[0].nextElementSibling]) : m([]) : this[0].nextElementSibling ? m([this[0].nextElementSibling]) : m([]) : m([]);\n    },\n    nextAll: function nextAll(e) {\n      var t = [],\n          a = this[0];\n      if (!a) return m([]);\n\n      for (; a.nextElementSibling;) {\n        var i = a.nextElementSibling;\n        e ? m(i).is(e) && t.push(i) : t.push(i), a = i;\n      }\n\n      return m(t);\n    },\n    prev: function prev(e) {\n      if (this.length > 0) {\n        var t = this[0];\n        return e ? t.previousElementSibling && m(t.previousElementSibling).is(e) ? m([t.previousElementSibling]) : m([]) : t.previousElementSibling ? m([t.previousElementSibling]) : m([]);\n      }\n\n      return m([]);\n    },\n    prevAll: function prevAll(e) {\n      var t = [],\n          a = this[0];\n      if (!a) return m([]);\n\n      for (; a.previousElementSibling;) {\n        var i = a.previousElementSibling;\n        e ? m(i).is(e) && t.push(i) : t.push(i), a = i;\n      }\n\n      return m(t);\n    },\n    parent: function parent(e) {\n      for (var t = [], a = 0; a < this.length; a += 1) {\n        null !== this[a].parentNode && (e ? m(this[a].parentNode).is(e) && t.push(this[a].parentNode) : t.push(this[a].parentNode));\n      }\n\n      return m(t);\n    },\n    parents: function parents(e) {\n      for (var t = [], a = 0; a < this.length; a += 1) {\n        for (var i = this[a].parentNode; i;) {\n          e ? m(i).is(e) && t.push(i) : t.push(i), i = i.parentNode;\n        }\n      }\n\n      return m(t);\n    },\n    closest: function closest(e) {\n      var t = this;\n      return void 0 === e ? m([]) : (t.is(e) || (t = t.parents(e).eq(0)), t);\n    },\n    find: function find(e) {\n      for (var t = [], a = 0; a < this.length; a += 1) {\n        for (var i = this[a].querySelectorAll(e), s = 0; s < i.length; s += 1) {\n          t.push(i[s]);\n        }\n      }\n\n      return m(t);\n    },\n    children: function children(e) {\n      for (var t = [], a = 0; a < this.length; a += 1) {\n        for (var i = this[a].children, s = 0; s < i.length; s += 1) {\n          e && !m(i[s]).is(e) || t.push(i[s]);\n        }\n      }\n\n      return m(t);\n    },\n    filter: function filter(e) {\n      return m(f(this, e));\n    },\n    remove: function remove() {\n      for (var e = 0; e < this.length; e += 1) {\n        this[e].parentNode && this[e].parentNode.removeChild(this[e]);\n      }\n\n      return this;\n    }\n  };\n\n  function E(e, t) {\n    return void 0 === t && (t = 0), setTimeout(e, t);\n  }\n\n  function x() {\n    return Date.now();\n  }\n\n  function T(e, t) {\n    void 0 === t && (t = \"x\");\n    var a,\n        i,\n        s,\n        r = l(),\n        n = r.getComputedStyle(e, null);\n    return r.WebKitCSSMatrix ? ((i = n.transform || n.webkitTransform).split(\",\").length > 6 && (i = i.split(\", \").map(function (e) {\n      return e.replace(\",\", \".\");\n    }).join(\", \")), s = new r.WebKitCSSMatrix(\"none\" === i ? \"\" : i)) : a = (s = n.MozTransform || n.OTransform || n.MsTransform || n.msTransform || n.transform || n.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\")).toString().split(\",\"), \"x\" === t && (i = r.WebKitCSSMatrix ? s.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), \"y\" === t && (i = r.WebKitCSSMatrix ? s.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0;\n  }\n\n  function C(e) {\n    return \"object\" == _typeof(e) && null !== e && e.constructor && e.constructor === Object;\n  }\n\n  function S() {\n    for (var e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = 1; t < arguments.length; t += 1) {\n      var a = t < 0 || arguments.length <= t ? void 0 : arguments[t];\n      if (null != a) for (var i = Object.keys(Object(a)), s = 0, r = i.length; s < r; s += 1) {\n        var n = i[s],\n            l = Object.getOwnPropertyDescriptor(a, n);\n        void 0 !== l && l.enumerable && (C(e[n]) && C(a[n]) ? S(e[n], a[n]) : !C(e[n]) && C(a[n]) ? (e[n] = {}, S(e[n], a[n])) : e[n] = a[n]);\n      }\n    }\n\n    return e;\n  }\n\n  function M(e, t) {\n    Object.keys(t).forEach(function (a) {\n      C(t[a]) && Object.keys(t[a]).forEach(function (i) {\n        \"function\" == typeof t[a][i] && (t[a][i] = t[a][i].bind(e));\n      }), e[a] = t[a];\n    });\n  }\n\n  function z() {\n    return g || (g = function () {\n      var e = l(),\n          t = r();\n      return {\n        touch: !!(\"ontouchstart\" in e || e.DocumentTouch && t instanceof e.DocumentTouch),\n        pointerEvents: !!e.PointerEvent && \"maxTouchPoints\" in e.navigator && e.navigator.maxTouchPoints >= 0,\n        observer: \"MutationObserver\" in e || \"WebkitMutationObserver\" in e,\n        passiveListener: function () {\n          var t = !1;\n\n          try {\n            var a = Object.defineProperty({}, \"passive\", {\n              get: function get() {\n                t = !0;\n              }\n            });\n            e.addEventListener(\"testPassiveListener\", null, a);\n          } catch (e) {}\n\n          return t;\n        }(),\n        gestures: \"ongesturestart\" in e\n      };\n    }()), g;\n  }\n\n  function P(e) {\n    return void 0 === e && (e = {}), y || (y = function (e) {\n      var t = (void 0 === e ? {} : e).userAgent,\n          a = z(),\n          i = l(),\n          s = i.navigator.platform,\n          r = t || i.navigator.userAgent,\n          n = {\n        ios: !1,\n        android: !1\n      },\n          o = i.screen.width,\n          d = i.screen.height,\n          p = r.match(/(Android);?[\\s\\/]+([\\d.]+)?/),\n          u = r.match(/(iPad).*OS\\s([\\d_]+)/),\n          c = r.match(/(iPod)(.*OS\\s([\\d_]+))?/),\n          h = !u && r.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/),\n          v = \"Win32\" === s,\n          f = \"MacIntel\" === s;\n      return !u && f && a.touch && [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"].indexOf(o + \"x\" + d) >= 0 && ((u = r.match(/(Version)\\/([\\d.]+)/)) || (u = [0, 1, \"13_0_0\"]), f = !1), p && !v && (n.os = \"android\", n.android = !0), (u || h || c) && (n.os = \"ios\", n.ios = !0), n;\n    }(e)), y;\n  }\n\n  function k() {\n    return w || (w = function () {\n      var e,\n          t = l();\n      return {\n        isEdge: !!t.navigator.userAgent.match(/Edge/g),\n        isSafari: (e = t.navigator.userAgent.toLowerCase(), e.indexOf(\"safari\") >= 0 && e.indexOf(\"chrome\") < 0 && e.indexOf(\"android\") < 0),\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)\n      };\n    }()), w;\n  }\n\n  Object.keys(b).forEach(function (e) {\n    m.fn[e] = b[e];\n  });\n  var L = {\n    name: \"resize\",\n    create: function create() {\n      var e = this;\n      S(e, {\n        resize: {\n          resizeHandler: function resizeHandler() {\n            e && !e.destroyed && e.initialized && (e.emit(\"beforeResize\"), e.emit(\"resize\"));\n          },\n          orientationChangeHandler: function orientationChangeHandler() {\n            e && !e.destroyed && e.initialized && e.emit(\"orientationchange\");\n          }\n        }\n      });\n    },\n    on: {\n      init: function init(e) {\n        var t = l();\n        t.addEventListener(\"resize\", e.resize.resizeHandler), t.addEventListener(\"orientationchange\", e.resize.orientationChangeHandler);\n      },\n      destroy: function destroy(e) {\n        var t = l();\n        t.removeEventListener(\"resize\", e.resize.resizeHandler), t.removeEventListener(\"orientationchange\", e.resize.orientationChangeHandler);\n      }\n    }\n  },\n      $ = {\n    attach: function attach(e, t) {\n      void 0 === t && (t = {});\n      var a = l(),\n          i = this,\n          s = new (a.MutationObserver || a.WebkitMutationObserver)(function (e) {\n        if (1 !== e.length) {\n          var t = function t() {\n            i.emit(\"observerUpdate\", e[0]);\n          };\n\n          a.requestAnimationFrame ? a.requestAnimationFrame(t) : a.setTimeout(t, 0);\n        } else i.emit(\"observerUpdate\", e[0]);\n      });\n      s.observe(e, {\n        attributes: void 0 === t.attributes || t.attributes,\n        childList: void 0 === t.childList || t.childList,\n        characterData: void 0 === t.characterData || t.characterData\n      }), i.observer.observers.push(s);\n    },\n    init: function init() {\n      var e = this;\n\n      if (e.support.observer && e.params.observer) {\n        if (e.params.observeParents) for (var t = e.$el.parents(), a = 0; a < t.length; a += 1) {\n          e.observer.attach(t[a]);\n        }\n        e.observer.attach(e.$el[0], {\n          childList: e.params.observeSlideChildren\n        }), e.observer.attach(e.$wrapperEl[0], {\n          attributes: !1\n        });\n      }\n    },\n    destroy: function destroy() {\n      this.observer.observers.forEach(function (e) {\n        e.disconnect();\n      }), this.observer.observers = [];\n    }\n  },\n      I = {\n    name: \"observer\",\n    params: {\n      observer: !1,\n      observeParents: !1,\n      observeSlideChildren: !1\n    },\n    create: function create() {\n      M(this, {\n        observer: t({}, $, {\n          observers: []\n        })\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.observer.init();\n      },\n      destroy: function destroy(e) {\n        e.observer.destroy();\n      }\n    }\n  };\n\n  function O(e) {\n    var t = this,\n        a = r(),\n        i = l(),\n        s = t.touchEventsData,\n        n = t.params,\n        o = t.touches;\n\n    if (!t.animating || !n.preventInteractionOnTransition) {\n      var d = e;\n      d.originalEvent && (d = d.originalEvent);\n      var p = m(d.target);\n      if (\"wrapper\" !== n.touchEventsTarget || p.closest(t.wrapperEl).length) if (s.isTouchEvent = \"touchstart\" === d.type, s.isTouchEvent || !(\"which\" in d) || 3 !== d.which) if (!(!s.isTouchEvent && \"button\" in d && d.button > 0)) if (!s.isTouched || !s.isMoved) if (!!n.noSwipingClass && \"\" !== n.noSwipingClass && d.target && d.target.shadowRoot && e.path && e.path[0] && (p = m(e.path[0])), n.noSwiping && p.closest(n.noSwipingSelector ? n.noSwipingSelector : \".\" + n.noSwipingClass)[0]) t.allowClick = !0;else if (!n.swipeHandler || p.closest(n.swipeHandler)[0]) {\n        o.currentX = \"touchstart\" === d.type ? d.targetTouches[0].pageX : d.pageX, o.currentY = \"touchstart\" === d.type ? d.targetTouches[0].pageY : d.pageY;\n        var u = o.currentX,\n            c = o.currentY,\n            h = n.edgeSwipeDetection || n.iOSEdgeSwipeDetection,\n            v = n.edgeSwipeThreshold || n.iOSEdgeSwipeThreshold;\n\n        if (!h || !(u <= v || u >= i.innerWidth - v)) {\n          if (S(s, {\n            isTouched: !0,\n            isMoved: !1,\n            allowTouchCallbacks: !0,\n            isScrolling: void 0,\n            startMoving: void 0\n          }), o.startX = u, o.startY = c, s.touchStartTime = x(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, n.threshold > 0 && (s.allowThresholdMove = !1), \"touchstart\" !== d.type) {\n            var f = !0;\n            p.is(s.formElements) && (f = !1), a.activeElement && m(a.activeElement).is(s.formElements) && a.activeElement !== p[0] && a.activeElement.blur();\n            var g = f && t.allowTouchMove && n.touchStartPreventDefault;\n            !n.touchStartForcePreventDefault && !g || p[0].isContentEditable || d.preventDefault();\n          }\n\n          t.emit(\"touchStart\", d);\n        }\n      }\n    }\n  }\n\n  function A(e) {\n    var t = r(),\n        a = this,\n        i = a.touchEventsData,\n        s = a.params,\n        n = a.touches,\n        l = a.rtlTranslate,\n        o = e;\n\n    if (o.originalEvent && (o = o.originalEvent), i.isTouched) {\n      if (!i.isTouchEvent || \"touchmove\" === o.type) {\n        var d = \"touchmove\" === o.type && o.targetTouches && (o.targetTouches[0] || o.changedTouches[0]),\n            p = \"touchmove\" === o.type ? d.pageX : o.pageX,\n            u = \"touchmove\" === o.type ? d.pageY : o.pageY;\n        if (o.preventedByNestedSwiper) return n.startX = p, void (n.startY = u);\n        if (!a.allowTouchMove) return a.allowClick = !1, void (i.isTouched && (S(n, {\n          startX: p,\n          startY: u,\n          currentX: p,\n          currentY: u\n        }), i.touchStartTime = x()));\n        if (i.isTouchEvent && s.touchReleaseOnEdges && !s.loop) if (a.isVertical()) {\n          if (u < n.startY && a.translate <= a.maxTranslate() || u > n.startY && a.translate >= a.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1);\n        } else if (p < n.startX && a.translate <= a.maxTranslate() || p > n.startX && a.translate >= a.minTranslate()) return;\n        if (i.isTouchEvent && t.activeElement && o.target === t.activeElement && m(o.target).is(i.formElements)) return i.isMoved = !0, void (a.allowClick = !1);\n\n        if (i.allowTouchCallbacks && a.emit(\"touchMove\", o), !(o.targetTouches && o.targetTouches.length > 1)) {\n          n.currentX = p, n.currentY = u;\n          var c = n.currentX - n.startX,\n              h = n.currentY - n.startY;\n\n          if (!(a.params.threshold && Math.sqrt(Math.pow(c, 2) + Math.pow(h, 2)) < a.params.threshold)) {\n            var v;\n            if (void 0 === i.isScrolling) a.isHorizontal() && n.currentY === n.startY || a.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : c * c + h * h >= 25 && (v = 180 * Math.atan2(Math.abs(h), Math.abs(c)) / Math.PI, i.isScrolling = a.isHorizontal() ? v > s.touchAngle : 90 - v > s.touchAngle);\n            if (i.isScrolling && a.emit(\"touchMoveOpposite\", o), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) i.isTouched = !1;else if (i.startMoving) {\n              a.allowClick = !1, !s.cssMode && o.cancelable && o.preventDefault(), s.touchMoveStopPropagation && !s.nested && o.stopPropagation(), i.isMoved || (s.loop && a.loopFix(), i.startTranslate = a.getTranslate(), a.setTransition(0), a.animating && a.$wrapperEl.trigger(\"webkitTransitionEnd transitionend\"), i.allowMomentumBounce = !1, !s.grabCursor || !0 !== a.allowSlideNext && !0 !== a.allowSlidePrev || a.setGrabCursor(!0), a.emit(\"sliderFirstMove\", o)), a.emit(\"sliderMove\", o), i.isMoved = !0;\n              var f = a.isHorizontal() ? c : h;\n              n.diff = f, f *= s.touchRatio, l && (f = -f), a.swipeDirection = f > 0 ? \"prev\" : \"next\", i.currentTranslate = f + i.startTranslate;\n              var g = !0,\n                  y = s.resistanceRatio;\n\n              if (s.touchReleaseOnEdges && (y = 0), f > 0 && i.currentTranslate > a.minTranslate() ? (g = !1, s.resistance && (i.currentTranslate = a.minTranslate() - 1 + Math.pow(-a.minTranslate() + i.startTranslate + f, y))) : f < 0 && i.currentTranslate < a.maxTranslate() && (g = !1, s.resistance && (i.currentTranslate = a.maxTranslate() + 1 - Math.pow(a.maxTranslate() - i.startTranslate - f, y))), g && (o.preventedByNestedSwiper = !0), !a.allowSlideNext && \"next\" === a.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !a.allowSlidePrev && \"prev\" === a.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.threshold > 0) {\n                if (!(Math.abs(f) > s.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate);\n                if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = a.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY);\n              }\n\n              s.followFinger && !s.cssMode && ((s.freeMode || s.watchSlidesProgress || s.watchSlidesVisibility) && (a.updateActiveIndex(), a.updateSlidesClasses()), s.freeMode && (0 === i.velocities.length && i.velocities.push({\n                position: n[a.isHorizontal() ? \"startX\" : \"startY\"],\n                time: i.touchStartTime\n              }), i.velocities.push({\n                position: n[a.isHorizontal() ? \"currentX\" : \"currentY\"],\n                time: x()\n              })), a.updateProgress(i.currentTranslate), a.setTranslate(i.currentTranslate));\n            }\n          }\n        }\n      }\n    } else i.startMoving && i.isScrolling && a.emit(\"touchMoveOpposite\", o);\n  }\n\n  function D(e) {\n    var t = this,\n        a = t.touchEventsData,\n        i = t.params,\n        s = t.touches,\n        r = t.rtlTranslate,\n        n = t.$wrapperEl,\n        l = t.slidesGrid,\n        o = t.snapGrid,\n        d = e;\n    if (d.originalEvent && (d = d.originalEvent), a.allowTouchCallbacks && t.emit(\"touchEnd\", d), a.allowTouchCallbacks = !1, !a.isTouched) return a.isMoved && i.grabCursor && t.setGrabCursor(!1), a.isMoved = !1, void (a.startMoving = !1);\n    i.grabCursor && a.isMoved && a.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);\n    var p,\n        u = x(),\n        c = u - a.touchStartTime;\n    if (t.allowClick && (t.updateClickedSlide(d), t.emit(\"tap click\", d), c < 300 && u - a.lastClickTime < 300 && t.emit(\"doubleTap doubleClick\", d)), a.lastClickTime = x(), E(function () {\n      t.destroyed || (t.allowClick = !0);\n    }), !a.isTouched || !a.isMoved || !t.swipeDirection || 0 === s.diff || a.currentTranslate === a.startTranslate) return a.isTouched = !1, a.isMoved = !1, void (a.startMoving = !1);\n    if (a.isTouched = !1, a.isMoved = !1, a.startMoving = !1, p = i.followFinger ? r ? t.translate : -t.translate : -a.currentTranslate, !i.cssMode) if (i.freeMode) {\n      if (p < -t.minTranslate()) return void t.slideTo(t.activeIndex);\n      if (p > -t.maxTranslate()) return void (t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1));\n\n      if (i.freeModeMomentum) {\n        if (a.velocities.length > 1) {\n          var h = a.velocities.pop(),\n              v = a.velocities.pop(),\n              f = h.position - v.position,\n              m = h.time - v.time;\n          t.velocity = f / m, t.velocity /= 2, Math.abs(t.velocity) < i.freeModeMinimumVelocity && (t.velocity = 0), (m > 150 || x() - h.time > 300) && (t.velocity = 0);\n        } else t.velocity = 0;\n\n        t.velocity *= i.freeModeMomentumVelocityRatio, a.velocities.length = 0;\n        var g = 1e3 * i.freeModeMomentumRatio,\n            y = t.velocity * g,\n            w = t.translate + y;\n        r && (w = -w);\n        var b,\n            T,\n            C = !1,\n            S = 20 * Math.abs(t.velocity) * i.freeModeMomentumBounceRatio;\n        if (w < t.maxTranslate()) i.freeModeMomentumBounce ? (w + t.maxTranslate() < -S && (w = t.maxTranslate() - S), b = t.maxTranslate(), C = !0, a.allowMomentumBounce = !0) : w = t.maxTranslate(), i.loop && i.centeredSlides && (T = !0);else if (w > t.minTranslate()) i.freeModeMomentumBounce ? (w - t.minTranslate() > S && (w = t.minTranslate() + S), b = t.minTranslate(), C = !0, a.allowMomentumBounce = !0) : w = t.minTranslate(), i.loop && i.centeredSlides && (T = !0);else if (i.freeModeSticky) {\n          for (var M, z = 0; z < o.length; z += 1) {\n            if (o[z] > -w) {\n              M = z;\n              break;\n            }\n          }\n\n          w = -(w = Math.abs(o[M] - w) < Math.abs(o[M - 1] - w) || \"next\" === t.swipeDirection ? o[M] : o[M - 1]);\n        }\n\n        if (T && t.once(\"transitionEnd\", function () {\n          t.loopFix();\n        }), 0 !== t.velocity) {\n          if (g = r ? Math.abs((-w - t.translate) / t.velocity) : Math.abs((w - t.translate) / t.velocity), i.freeModeSticky) {\n            var P = Math.abs((r ? -w : w) - t.translate),\n                k = t.slidesSizesGrid[t.activeIndex];\n            g = P < k ? i.speed : P < 2 * k ? 1.5 * i.speed : 2.5 * i.speed;\n          }\n        } else if (i.freeModeSticky) return void t.slideToClosest();\n\n        i.freeModeMomentumBounce && C ? (t.updateProgress(b), t.setTransition(g), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd(function () {\n          t && !t.destroyed && a.allowMomentumBounce && (t.emit(\"momentumBounce\"), t.setTransition(i.speed), setTimeout(function () {\n            t.setTranslate(b), n.transitionEnd(function () {\n              t && !t.destroyed && t.transitionEnd();\n            });\n          }, 0));\n        })) : t.velocity ? (t.updateProgress(w), t.setTransition(g), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd(function () {\n          t && !t.destroyed && t.transitionEnd();\n        }))) : t.updateProgress(w), t.updateActiveIndex(), t.updateSlidesClasses();\n      } else if (i.freeModeSticky) return void t.slideToClosest();\n\n      (!i.freeModeMomentum || c >= i.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses());\n    } else {\n      for (var L = 0, $ = t.slidesSizesGrid[0], I = 0; I < l.length; I += I < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {\n        var O = I < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;\n        void 0 !== l[I + O] ? p >= l[I] && p < l[I + O] && (L = I, $ = l[I + O] - l[I]) : p >= l[I] && (L = I, $ = l[l.length - 1] - l[l.length - 2]);\n      }\n\n      var A = (p - l[L]) / $,\n          D = L < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;\n\n      if (c > i.longSwipesMs) {\n        if (!i.longSwipes) return void t.slideTo(t.activeIndex);\n        \"next\" === t.swipeDirection && (A >= i.longSwipesRatio ? t.slideTo(L + D) : t.slideTo(L)), \"prev\" === t.swipeDirection && (A > 1 - i.longSwipesRatio ? t.slideTo(L + D) : t.slideTo(L));\n      } else {\n        if (!i.shortSwipes) return void t.slideTo(t.activeIndex);\n        t.navigation && (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl) ? d.target === t.navigation.nextEl ? t.slideTo(L + D) : t.slideTo(L) : (\"next\" === t.swipeDirection && t.slideTo(L + D), \"prev\" === t.swipeDirection && t.slideTo(L));\n      }\n    }\n  }\n\n  function G() {\n    var e = this,\n        t = e.params,\n        a = e.el;\n\n    if (!a || 0 !== a.offsetWidth) {\n      t.breakpoints && e.setBreakpoint();\n      var i = e.allowSlideNext,\n          s = e.allowSlidePrev,\n          r = e.snapGrid;\n      e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), (\"auto\" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = s, e.allowSlideNext = i, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow();\n    }\n  }\n\n  function N(e) {\n    var t = this;\n    t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()));\n  }\n\n  function B() {\n    var e = this,\n        t = e.wrapperEl,\n        a = e.rtlTranslate;\n    e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = a ? t.scrollWidth - t.offsetWidth - t.scrollLeft : -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();\n    var i = e.maxTranslate() - e.minTranslate();\n    (0 === i ? 0 : (e.translate - e.minTranslate()) / i) !== e.progress && e.updateProgress(a ? -e.translate : e.translate), e.emit(\"setTranslate\", e.translate, !1);\n  }\n\n  var H = !1;\n\n  function X() {}\n\n  var Y = {\n    init: !0,\n    direction: \"horizontal\",\n    touchEventsTarget: \"container\",\n    initialSlide: 0,\n    speed: 300,\n    cssMode: !1,\n    updateOnWindowResize: !0,\n    nested: !1,\n    width: null,\n    height: null,\n    preventInteractionOnTransition: !1,\n    userAgent: null,\n    url: null,\n    edgeSwipeDetection: !1,\n    edgeSwipeThreshold: 20,\n    freeMode: !1,\n    freeModeMomentum: !0,\n    freeModeMomentumRatio: 1,\n    freeModeMomentumBounce: !0,\n    freeModeMomentumBounceRatio: 1,\n    freeModeMomentumVelocityRatio: 1,\n    freeModeSticky: !1,\n    freeModeMinimumVelocity: .02,\n    autoHeight: !1,\n    setWrapperSize: !1,\n    virtualTranslate: !1,\n    effect: \"slide\",\n    breakpoints: void 0,\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerColumn: 1,\n    slidesPerColumnFill: \"column\",\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    centeredSlides: !1,\n    centeredSlidesBounds: !1,\n    slidesOffsetBefore: 0,\n    slidesOffsetAfter: 0,\n    normalizeSlideIndex: !0,\n    centerInsufficientSlides: !1,\n    watchOverflow: !1,\n    roundLengths: !1,\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: !0,\n    shortSwipes: !0,\n    longSwipes: !0,\n    longSwipesRatio: .5,\n    longSwipesMs: 300,\n    followFinger: !0,\n    allowTouchMove: !0,\n    threshold: 0,\n    touchMoveStopPropagation: !1,\n    touchStartPreventDefault: !0,\n    touchStartForcePreventDefault: !1,\n    touchReleaseOnEdges: !1,\n    uniqueNavElements: !0,\n    resistance: !0,\n    resistanceRatio: .85,\n    watchSlidesProgress: !1,\n    watchSlidesVisibility: !1,\n    grabCursor: !1,\n    preventClicks: !0,\n    preventClicksPropagation: !0,\n    slideToClickedSlide: !1,\n    preloadImages: !0,\n    updateOnImagesReady: !0,\n    loop: !1,\n    loopAdditionalSlides: 0,\n    loopedSlides: null,\n    loopFillGroupWithBlank: !1,\n    loopPreventsSlide: !0,\n    allowSlidePrev: !0,\n    allowSlideNext: !0,\n    swipeHandler: null,\n    noSwiping: !0,\n    noSwipingClass: \"swiper-no-swiping\",\n    noSwipingSelector: null,\n    passiveListeners: !0,\n    containerModifierClass: \"swiper-container-\",\n    slideClass: \"swiper-slide\",\n    slideBlankClass: \"swiper-slide-invisible-blank\",\n    slideActiveClass: \"swiper-slide-active\",\n    slideDuplicateActiveClass: \"swiper-slide-duplicate-active\",\n    slideVisibleClass: \"swiper-slide-visible\",\n    slideDuplicateClass: \"swiper-slide-duplicate\",\n    slideNextClass: \"swiper-slide-next\",\n    slideDuplicateNextClass: \"swiper-slide-duplicate-next\",\n    slidePrevClass: \"swiper-slide-prev\",\n    slideDuplicatePrevClass: \"swiper-slide-duplicate-prev\",\n    wrapperClass: \"swiper-wrapper\",\n    runCallbacksOnInit: !0,\n    _emitClasses: !1\n  },\n      V = {\n    modular: {\n      useParams: function useParams(e) {\n        var t = this;\n        t.modules && Object.keys(t.modules).forEach(function (a) {\n          var i = t.modules[a];\n          i.params && S(e, i.params);\n        });\n      },\n      useModules: function useModules(e) {\n        void 0 === e && (e = {});\n        var t = this;\n        t.modules && Object.keys(t.modules).forEach(function (a) {\n          var i = t.modules[a],\n              s = e[a] || {};\n          i.on && t.on && Object.keys(i.on).forEach(function (e) {\n            t.on(e, i.on[e]);\n          }), i.create && i.create.bind(t)(s);\n        });\n      }\n    },\n    eventsEmitter: {\n      on: function on(e, t, a) {\n        var i = this;\n        if (\"function\" != typeof t) return i;\n        var s = a ? \"unshift\" : \"push\";\n        return e.split(\" \").forEach(function (e) {\n          i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][s](t);\n        }), i;\n      },\n      once: function once(e, t, a) {\n        var i = this;\n        if (\"function\" != typeof t) return i;\n\n        function s() {\n          i.off(e, s), s.__emitterProxy && delete s.__emitterProxy;\n\n          for (var a = arguments.length, r = new Array(a), n = 0; n < a; n++) {\n            r[n] = arguments[n];\n          }\n\n          t.apply(i, r);\n        }\n\n        return s.__emitterProxy = t, i.on(e, s, a);\n      },\n      onAny: function onAny(e, t) {\n        var a = this;\n        if (\"function\" != typeof e) return a;\n        var i = t ? \"unshift\" : \"push\";\n        return a.eventsAnyListeners.indexOf(e) < 0 && a.eventsAnyListeners[i](e), a;\n      },\n      offAny: function offAny(e) {\n        var t = this;\n        if (!t.eventsAnyListeners) return t;\n        var a = t.eventsAnyListeners.indexOf(e);\n        return a >= 0 && t.eventsAnyListeners.splice(a, 1), t;\n      },\n      off: function off(e, t) {\n        var a = this;\n        return a.eventsListeners ? (e.split(\" \").forEach(function (e) {\n          void 0 === t ? a.eventsListeners[e] = [] : a.eventsListeners[e] && a.eventsListeners[e].forEach(function (i, s) {\n            (i === t || i.__emitterProxy && i.__emitterProxy === t) && a.eventsListeners[e].splice(s, 1);\n          });\n        }), a) : a;\n      },\n      emit: function emit() {\n        var e,\n            t,\n            a,\n            i = this;\n        if (!i.eventsListeners) return i;\n\n        for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) {\n          r[n] = arguments[n];\n        }\n\n        \"string\" == typeof r[0] || Array.isArray(r[0]) ? (e = r[0], t = r.slice(1, r.length), a = i) : (e = r[0].events, t = r[0].data, a = r[0].context || i), t.unshift(a);\n        var l = Array.isArray(e) ? e : e.split(\" \");\n        return l.forEach(function (e) {\n          i.eventsAnyListeners && i.eventsAnyListeners.length && i.eventsAnyListeners.forEach(function (i) {\n            i.apply(a, [e].concat(t));\n          }), i.eventsListeners && i.eventsListeners[e] && i.eventsListeners[e].forEach(function (e) {\n            e.apply(a, t);\n          });\n        }), i;\n      }\n    },\n    update: {\n      updateSize: function updateSize() {\n        var e,\n            t,\n            a = this,\n            i = a.$el;\n        e = void 0 !== a.params.width && null !== a.params.width ? a.params.width : i[0].clientWidth, t = void 0 !== a.params.height && null !== a.params.height ? a.params.height : i[0].clientHeight, 0 === e && a.isHorizontal() || 0 === t && a.isVertical() || (e = e - parseInt(i.css(\"padding-left\") || 0, 10) - parseInt(i.css(\"padding-right\") || 0, 10), t = t - parseInt(i.css(\"padding-top\") || 0, 10) - parseInt(i.css(\"padding-bottom\") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), S(a, {\n          width: e,\n          height: t,\n          size: a.isHorizontal() ? e : t\n        }));\n      },\n      updateSlides: function updateSlides() {\n        var e = this,\n            t = l(),\n            a = e.params,\n            i = e.$wrapperEl,\n            s = e.size,\n            r = e.rtlTranslate,\n            n = e.wrongRTL,\n            o = e.virtual && a.virtual.enabled,\n            d = o ? e.virtual.slides.length : e.slides.length,\n            p = i.children(\".\" + e.params.slideClass),\n            u = o ? e.virtual.slides.length : p.length,\n            c = [],\n            h = [],\n            v = [];\n\n        function f(e, t) {\n          return !a.cssMode || t !== p.length - 1;\n        }\n\n        var m = a.slidesOffsetBefore;\n        \"function\" == typeof m && (m = a.slidesOffsetBefore.call(e));\n        var g = a.slidesOffsetAfter;\n        \"function\" == typeof g && (g = a.slidesOffsetAfter.call(e));\n        var y = e.snapGrid.length,\n            w = e.slidesGrid.length,\n            b = a.spaceBetween,\n            E = -m,\n            x = 0,\n            T = 0;\n\n        if (void 0 !== s) {\n          var C, M;\n          \"string\" == typeof b && b.indexOf(\"%\") >= 0 && (b = parseFloat(b.replace(\"%\", \"\")) / 100 * s), e.virtualSize = -b, r ? p.css({\n            marginLeft: \"\",\n            marginTop: \"\"\n          }) : p.css({\n            marginRight: \"\",\n            marginBottom: \"\"\n          }), a.slidesPerColumn > 1 && (C = Math.floor(u / a.slidesPerColumn) === u / e.params.slidesPerColumn ? u : Math.ceil(u / a.slidesPerColumn) * a.slidesPerColumn, \"auto\" !== a.slidesPerView && \"row\" === a.slidesPerColumnFill && (C = Math.max(C, a.slidesPerView * a.slidesPerColumn)));\n\n          for (var z, P = a.slidesPerColumn, k = C / P, L = Math.floor(u / a.slidesPerColumn), $ = 0; $ < u; $ += 1) {\n            M = 0;\n            var I = p.eq($);\n\n            if (a.slidesPerColumn > 1) {\n              var O = void 0,\n                  A = void 0,\n                  D = void 0;\n\n              if (\"row\" === a.slidesPerColumnFill && a.slidesPerGroup > 1) {\n                var G = Math.floor($ / (a.slidesPerGroup * a.slidesPerColumn)),\n                    N = $ - a.slidesPerColumn * a.slidesPerGroup * G,\n                    B = 0 === G ? a.slidesPerGroup : Math.min(Math.ceil((u - G * P * a.slidesPerGroup) / P), a.slidesPerGroup);\n                O = (A = N - (D = Math.floor(N / B)) * B + G * a.slidesPerGroup) + D * C / P, I.css({\n                  \"-webkit-box-ordinal-group\": O,\n                  \"-moz-box-ordinal-group\": O,\n                  \"-ms-flex-order\": O,\n                  \"-webkit-order\": O,\n                  order: O\n                });\n              } else \"column\" === a.slidesPerColumnFill ? (D = $ - (A = Math.floor($ / P)) * P, (A > L || A === L && D === P - 1) && (D += 1) >= P && (D = 0, A += 1)) : A = $ - (D = Math.floor($ / k)) * k;\n\n              I.css(\"margin-\" + (e.isHorizontal() ? \"top\" : \"left\"), 0 !== D && a.spaceBetween && a.spaceBetween + \"px\");\n            }\n\n            if (\"none\" !== I.css(\"display\")) {\n              if (\"auto\" === a.slidesPerView) {\n                var H = t.getComputedStyle(I[0], null),\n                    X = I[0].style.transform,\n                    Y = I[0].style.webkitTransform;\n                if (X && (I[0].style.transform = \"none\"), Y && (I[0].style.webkitTransform = \"none\"), a.roundLengths) M = e.isHorizontal() ? I.outerWidth(!0) : I.outerHeight(!0);else if (e.isHorizontal()) {\n                  var V = parseFloat(H.getPropertyValue(\"width\") || 0),\n                      F = parseFloat(H.getPropertyValue(\"padding-left\") || 0),\n                      R = parseFloat(H.getPropertyValue(\"padding-right\") || 0),\n                      W = parseFloat(H.getPropertyValue(\"margin-left\") || 0),\n                      q = parseFloat(H.getPropertyValue(\"margin-right\") || 0),\n                      j = H.getPropertyValue(\"box-sizing\");\n                  if (j && \"border-box\" === j) M = V + W + q;else {\n                    var _ = I[0],\n                        U = _.clientWidth;\n                    M = V + F + R + W + q + (_.offsetWidth - U);\n                  }\n                } else {\n                  var K = parseFloat(H.getPropertyValue(\"height\") || 0),\n                      Z = parseFloat(H.getPropertyValue(\"padding-top\") || 0),\n                      J = parseFloat(H.getPropertyValue(\"padding-bottom\") || 0),\n                      Q = parseFloat(H.getPropertyValue(\"margin-top\") || 0),\n                      ee = parseFloat(H.getPropertyValue(\"margin-bottom\") || 0),\n                      te = H.getPropertyValue(\"box-sizing\");\n                  if (te && \"border-box\" === te) M = K + Q + ee;else {\n                    var ae = I[0],\n                        ie = ae.clientHeight;\n                    M = K + Z + J + Q + ee + (ae.offsetHeight - ie);\n                  }\n                }\n                X && (I[0].style.transform = X), Y && (I[0].style.webkitTransform = Y), a.roundLengths && (M = Math.floor(M));\n              } else M = (s - (a.slidesPerView - 1) * b) / a.slidesPerView, a.roundLengths && (M = Math.floor(M)), p[$] && (e.isHorizontal() ? p[$].style.width = M + \"px\" : p[$].style.height = M + \"px\");\n\n              p[$] && (p[$].swiperSlideSize = M), v.push(M), a.centeredSlides ? (E = E + M / 2 + x / 2 + b, 0 === x && 0 !== $ && (E = E - s / 2 - b), 0 === $ && (E = E - s / 2 - b), Math.abs(E) < .001 && (E = 0), a.roundLengths && (E = Math.floor(E)), T % a.slidesPerGroup == 0 && c.push(E), h.push(E)) : (a.roundLengths && (E = Math.floor(E)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && c.push(E), h.push(E), E = E + M + b), e.virtualSize += M + b, x = M, T += 1;\n            }\n          }\n\n          if (e.virtualSize = Math.max(e.virtualSize, s) + g, r && n && (\"slide\" === a.effect || \"coverflow\" === a.effect) && i.css({\n            width: e.virtualSize + a.spaceBetween + \"px\"\n          }), a.setWrapperSize && (e.isHorizontal() ? i.css({\n            width: e.virtualSize + a.spaceBetween + \"px\"\n          }) : i.css({\n            height: e.virtualSize + a.spaceBetween + \"px\"\n          })), a.slidesPerColumn > 1 && (e.virtualSize = (M + a.spaceBetween) * C, e.virtualSize = Math.ceil(e.virtualSize / a.slidesPerColumn) - a.spaceBetween, e.isHorizontal() ? i.css({\n            width: e.virtualSize + a.spaceBetween + \"px\"\n          }) : i.css({\n            height: e.virtualSize + a.spaceBetween + \"px\"\n          }), a.centeredSlides)) {\n            z = [];\n\n            for (var se = 0; se < c.length; se += 1) {\n              var re = c[se];\n              a.roundLengths && (re = Math.floor(re)), c[se] < e.virtualSize + c[0] && z.push(re);\n            }\n\n            c = z;\n          }\n\n          if (!a.centeredSlides) {\n            z = [];\n\n            for (var ne = 0; ne < c.length; ne += 1) {\n              var le = c[ne];\n              a.roundLengths && (le = Math.floor(le)), c[ne] <= e.virtualSize - s && z.push(le);\n            }\n\n            c = z, Math.floor(e.virtualSize - s) - Math.floor(c[c.length - 1]) > 1 && c.push(e.virtualSize - s);\n          }\n\n          if (0 === c.length && (c = [0]), 0 !== a.spaceBetween && (e.isHorizontal() ? r ? p.filter(f).css({\n            marginLeft: b + \"px\"\n          }) : p.filter(f).css({\n            marginRight: b + \"px\"\n          }) : p.filter(f).css({\n            marginBottom: b + \"px\"\n          })), a.centeredSlides && a.centeredSlidesBounds) {\n            var oe = 0;\n            v.forEach(function (e) {\n              oe += e + (a.spaceBetween ? a.spaceBetween : 0);\n            });\n            var de = (oe -= a.spaceBetween) - s;\n            c = c.map(function (e) {\n              return e < 0 ? -m : e > de ? de + g : e;\n            });\n          }\n\n          if (a.centerInsufficientSlides) {\n            var pe = 0;\n\n            if (v.forEach(function (e) {\n              pe += e + (a.spaceBetween ? a.spaceBetween : 0);\n            }), (pe -= a.spaceBetween) < s) {\n              var ue = (s - pe) / 2;\n              c.forEach(function (e, t) {\n                c[t] = e - ue;\n              }), h.forEach(function (e, t) {\n                h[t] = e + ue;\n              });\n            }\n          }\n\n          S(e, {\n            slides: p,\n            snapGrid: c,\n            slidesGrid: h,\n            slidesSizesGrid: v\n          }), u !== d && e.emit(\"slidesLengthChange\"), c.length !== y && (e.params.watchOverflow && e.checkOverflow(), e.emit(\"snapGridLengthChange\")), h.length !== w && e.emit(\"slidesGridLengthChange\"), (a.watchSlidesProgress || a.watchSlidesVisibility) && e.updateSlidesOffset();\n        }\n      },\n      updateAutoHeight: function updateAutoHeight(e) {\n        var t,\n            a = this,\n            i = [],\n            s = 0;\n        if (\"number\" == typeof e ? a.setTransition(e) : !0 === e && a.setTransition(a.params.speed), \"auto\" !== a.params.slidesPerView && a.params.slidesPerView > 1) {\n          if (a.params.centeredSlides) a.visibleSlides.each(function (e) {\n            i.push(e);\n          });else for (t = 0; t < Math.ceil(a.params.slidesPerView); t += 1) {\n            var r = a.activeIndex + t;\n            if (r > a.slides.length) break;\n            i.push(a.slides.eq(r)[0]);\n          }\n        } else i.push(a.slides.eq(a.activeIndex)[0]);\n\n        for (t = 0; t < i.length; t += 1) {\n          if (void 0 !== i[t]) {\n            var n = i[t].offsetHeight;\n            s = n > s ? n : s;\n          }\n        }\n\n        s && a.$wrapperEl.css(\"height\", s + \"px\");\n      },\n      updateSlidesOffset: function updateSlidesOffset() {\n        for (var e = this.slides, t = 0; t < e.length; t += 1) {\n          e[t].swiperSlideOffset = this.isHorizontal() ? e[t].offsetLeft : e[t].offsetTop;\n        }\n      },\n      updateSlidesProgress: function updateSlidesProgress(e) {\n        void 0 === e && (e = this && this.translate || 0);\n        var t = this,\n            a = t.params,\n            i = t.slides,\n            s = t.rtlTranslate;\n\n        if (0 !== i.length) {\n          void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset();\n          var r = -e;\n          s && (r = e), i.removeClass(a.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];\n\n          for (var n = 0; n < i.length; n += 1) {\n            var l = i[n],\n                o = (r + (a.centeredSlides ? t.minTranslate() : 0) - l.swiperSlideOffset) / (l.swiperSlideSize + a.spaceBetween);\n\n            if (a.watchSlidesVisibility || a.centeredSlides && a.autoHeight) {\n              var d = -(r - l.swiperSlideOffset),\n                  p = d + t.slidesSizesGrid[n];\n              (d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(n), i.eq(n).addClass(a.slideVisibleClass));\n            }\n\n            l.progress = s ? -o : o;\n          }\n\n          t.visibleSlides = m(t.visibleSlides);\n        }\n      },\n      updateProgress: function updateProgress(e) {\n        var t = this;\n\n        if (void 0 === e) {\n          var a = t.rtlTranslate ? -1 : 1;\n          e = t && t.translate && t.translate * a || 0;\n        }\n\n        var i = t.params,\n            s = t.maxTranslate() - t.minTranslate(),\n            r = t.progress,\n            n = t.isBeginning,\n            l = t.isEnd,\n            o = n,\n            d = l;\n        0 === s ? (r = 0, n = !0, l = !0) : (n = (r = (e - t.minTranslate()) / s) <= 0, l = r >= 1), S(t, {\n          progress: r,\n          isBeginning: n,\n          isEnd: l\n        }), (i.watchSlidesProgress || i.watchSlidesVisibility || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), n && !o && t.emit(\"reachBeginning toEdge\"), l && !d && t.emit(\"reachEnd toEdge\"), (o && !n || d && !l) && t.emit(\"fromEdge\"), t.emit(\"progress\", r);\n      },\n      updateSlidesClasses: function updateSlidesClasses() {\n        var e,\n            t = this,\n            a = t.slides,\n            i = t.params,\n            s = t.$wrapperEl,\n            r = t.activeIndex,\n            n = t.realIndex,\n            l = t.virtual && i.virtual.enabled;\n        a.removeClass(i.slideActiveClass + \" \" + i.slideNextClass + \" \" + i.slidePrevClass + \" \" + i.slideDuplicateActiveClass + \" \" + i.slideDuplicateNextClass + \" \" + i.slideDuplicatePrevClass), (e = l ? t.$wrapperEl.find(\".\" + i.slideClass + '[data-swiper-slide-index=\"' + r + '\"]') : a.eq(r)).addClass(i.slideActiveClass), i.loop && (e.hasClass(i.slideDuplicateClass) ? s.children(\".\" + i.slideClass + \":not(.\" + i.slideDuplicateClass + ')[data-swiper-slide-index=\"' + n + '\"]').addClass(i.slideDuplicateActiveClass) : s.children(\".\" + i.slideClass + \".\" + i.slideDuplicateClass + '[data-swiper-slide-index=\"' + n + '\"]').addClass(i.slideDuplicateActiveClass));\n        var o = e.nextAll(\".\" + i.slideClass).eq(0).addClass(i.slideNextClass);\n        i.loop && 0 === o.length && (o = a.eq(0)).addClass(i.slideNextClass);\n        var d = e.prevAll(\".\" + i.slideClass).eq(0).addClass(i.slidePrevClass);\n        i.loop && 0 === d.length && (d = a.eq(-1)).addClass(i.slidePrevClass), i.loop && (o.hasClass(i.slideDuplicateClass) ? s.children(\".\" + i.slideClass + \":not(.\" + i.slideDuplicateClass + ')[data-swiper-slide-index=\"' + o.attr(\"data-swiper-slide-index\") + '\"]').addClass(i.slideDuplicateNextClass) : s.children(\".\" + i.slideClass + \".\" + i.slideDuplicateClass + '[data-swiper-slide-index=\"' + o.attr(\"data-swiper-slide-index\") + '\"]').addClass(i.slideDuplicateNextClass), d.hasClass(i.slideDuplicateClass) ? s.children(\".\" + i.slideClass + \":not(.\" + i.slideDuplicateClass + ')[data-swiper-slide-index=\"' + d.attr(\"data-swiper-slide-index\") + '\"]').addClass(i.slideDuplicatePrevClass) : s.children(\".\" + i.slideClass + \".\" + i.slideDuplicateClass + '[data-swiper-slide-index=\"' + d.attr(\"data-swiper-slide-index\") + '\"]').addClass(i.slideDuplicatePrevClass)), t.emitSlidesClasses();\n      },\n      updateActiveIndex: function updateActiveIndex(e) {\n        var t,\n            a = this,\n            i = a.rtlTranslate ? a.translate : -a.translate,\n            s = a.slidesGrid,\n            r = a.snapGrid,\n            n = a.params,\n            l = a.activeIndex,\n            o = a.realIndex,\n            d = a.snapIndex,\n            p = e;\n\n        if (void 0 === p) {\n          for (var u = 0; u < s.length; u += 1) {\n            void 0 !== s[u + 1] ? i >= s[u] && i < s[u + 1] - (s[u + 1] - s[u]) / 2 ? p = u : i >= s[u] && i < s[u + 1] && (p = u + 1) : i >= s[u] && (p = u);\n          }\n\n          n.normalizeSlideIndex && (p < 0 || void 0 === p) && (p = 0);\n        }\n\n        if (r.indexOf(i) >= 0) t = r.indexOf(i);else {\n          var c = Math.min(n.slidesPerGroupSkip, p);\n          t = c + Math.floor((p - c) / n.slidesPerGroup);\n        }\n\n        if (t >= r.length && (t = r.length - 1), p !== l) {\n          var h = parseInt(a.slides.eq(p).attr(\"data-swiper-slide-index\") || p, 10);\n          S(a, {\n            snapIndex: t,\n            realIndex: h,\n            previousIndex: l,\n            activeIndex: p\n          }), a.emit(\"activeIndexChange\"), a.emit(\"snapIndexChange\"), o !== h && a.emit(\"realIndexChange\"), (a.initialized || a.params.runCallbacksOnInit) && a.emit(\"slideChange\");\n        } else t !== d && (a.snapIndex = t, a.emit(\"snapIndexChange\"));\n      },\n      updateClickedSlide: function updateClickedSlide(e) {\n        var t = this,\n            a = t.params,\n            i = m(e.target).closest(\".\" + a.slideClass)[0],\n            s = !1;\n        if (i) for (var r = 0; r < t.slides.length; r += 1) {\n          t.slides[r] === i && (s = !0);\n        }\n        if (!i || !s) return t.clickedSlide = void 0, void (t.clickedIndex = void 0);\n        t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(m(i).attr(\"data-swiper-slide-index\"), 10) : t.clickedIndex = m(i).index(), a.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide();\n      }\n    },\n    translate: {\n      getTranslate: function getTranslate(e) {\n        void 0 === e && (e = this.isHorizontal() ? \"x\" : \"y\");\n        var t = this,\n            a = t.params,\n            i = t.rtlTranslate,\n            s = t.translate,\n            r = t.$wrapperEl;\n        if (a.virtualTranslate) return i ? -s : s;\n        if (a.cssMode) return s;\n        var n = T(r[0], e);\n        return i && (n = -n), n || 0;\n      },\n      setTranslate: function setTranslate(e, t) {\n        var a = this,\n            i = a.rtlTranslate,\n            s = a.params,\n            r = a.$wrapperEl,\n            n = a.wrapperEl,\n            l = a.progress,\n            o = 0,\n            d = 0;\n        a.isHorizontal() ? o = i ? -e : e : d = e, s.roundLengths && (o = Math.floor(o), d = Math.floor(d)), s.cssMode ? n[a.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = a.isHorizontal() ? -o : -d : s.virtualTranslate || r.transform(\"translate3d(\" + o + \"px, \" + d + \"px, 0px)\"), a.previousTranslate = a.translate, a.translate = a.isHorizontal() ? o : d;\n        var p = a.maxTranslate() - a.minTranslate();\n        (0 === p ? 0 : (e - a.minTranslate()) / p) !== l && a.updateProgress(e), a.emit(\"setTranslate\", a.translate, t);\n      },\n      minTranslate: function minTranslate() {\n        return -this.snapGrid[0];\n      },\n      maxTranslate: function maxTranslate() {\n        return -this.snapGrid[this.snapGrid.length - 1];\n      },\n      translateTo: function translateTo(e, t, a, i, s) {\n        void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0), void 0 === i && (i = !0);\n        var r = this,\n            n = r.params,\n            l = r.wrapperEl;\n        if (r.animating && n.preventInteractionOnTransition) return !1;\n        var o,\n            d = r.minTranslate(),\n            p = r.maxTranslate();\n\n        if (o = i && e > d ? d : i && e < p ? p : e, r.updateProgress(o), n.cssMode) {\n          var u,\n              c = r.isHorizontal();\n          if (0 === t) l[c ? \"scrollLeft\" : \"scrollTop\"] = -o;else if (l.scrollTo) l.scrollTo(((u = {})[c ? \"left\" : \"top\"] = -o, u.behavior = \"smooth\", u));else l[c ? \"scrollLeft\" : \"scrollTop\"] = -o;\n          return !0;\n        }\n\n        return 0 === t ? (r.setTransition(0), r.setTranslate(o), a && (r.emit(\"beforeTransitionStart\", t, s), r.emit(\"transitionEnd\"))) : (r.setTransition(t), r.setTranslate(o), a && (r.emit(\"beforeTransitionStart\", t, s), r.emit(\"transitionStart\")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) {\n          r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener(\"transitionend\", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, a && r.emit(\"transitionEnd\"));\n        }), r.$wrapperEl[0].addEventListener(\"transitionend\", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", r.onTranslateToWrapperTransitionEnd))), !0;\n      }\n    },\n    transition: {\n      setTransition: function setTransition(e, t) {\n        var a = this;\n        a.params.cssMode || a.$wrapperEl.transition(e), a.emit(\"setTransition\", e, t);\n      },\n      transitionStart: function transitionStart(e, t) {\n        void 0 === e && (e = !0);\n        var a = this,\n            i = a.activeIndex,\n            s = a.params,\n            r = a.previousIndex;\n\n        if (!s.cssMode) {\n          s.autoHeight && a.updateAutoHeight();\n          var n = t;\n\n          if (n || (n = i > r ? \"next\" : i < r ? \"prev\" : \"reset\"), a.emit(\"transitionStart\"), e && i !== r) {\n            if (\"reset\" === n) return void a.emit(\"slideResetTransitionStart\");\n            a.emit(\"slideChangeTransitionStart\"), \"next\" === n ? a.emit(\"slideNextTransitionStart\") : a.emit(\"slidePrevTransitionStart\");\n          }\n        }\n      },\n      transitionEnd: function transitionEnd(e, t) {\n        void 0 === e && (e = !0);\n        var a = this,\n            i = a.activeIndex,\n            s = a.previousIndex,\n            r = a.params;\n\n        if (a.animating = !1, !r.cssMode) {\n          a.setTransition(0);\n          var n = t;\n\n          if (n || (n = i > s ? \"next\" : i < s ? \"prev\" : \"reset\"), a.emit(\"transitionEnd\"), e && i !== s) {\n            if (\"reset\" === n) return void a.emit(\"slideResetTransitionEnd\");\n            a.emit(\"slideChangeTransitionEnd\"), \"next\" === n ? a.emit(\"slideNextTransitionEnd\") : a.emit(\"slidePrevTransitionEnd\");\n          }\n        }\n      }\n    },\n    slide: {\n      slideTo: function slideTo(e, t, a, i) {\n        if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0), \"number\" != typeof e && \"string\" != typeof e) throw new Error(\"The 'index' argument cannot have type other than 'number' or 'string'. [\" + _typeof(e) + \"] given.\");\n\n        if (\"string\" == typeof e) {\n          var s = parseInt(e, 10);\n          if (!isFinite(s)) throw new Error(\"The passed-in 'index' (string) couldn't be converted to 'number'. [\" + e + \"] given.\");\n          e = s;\n        }\n\n        var r = this,\n            n = e;\n        n < 0 && (n = 0);\n        var l = r.params,\n            o = r.snapGrid,\n            d = r.slidesGrid,\n            p = r.previousIndex,\n            u = r.activeIndex,\n            c = r.rtlTranslate,\n            h = r.wrapperEl;\n        if (r.animating && l.preventInteractionOnTransition) return !1;\n        var v = Math.min(r.params.slidesPerGroupSkip, n),\n            f = v + Math.floor((n - v) / r.params.slidesPerGroup);\n        f >= o.length && (f = o.length - 1), (u || l.initialSlide || 0) === (p || 0) && a && r.emit(\"beforeSlideChangeStart\");\n        var m,\n            g = -o[f];\n        if (r.updateProgress(g), l.normalizeSlideIndex) for (var y = 0; y < d.length; y += 1) {\n          -Math.floor(100 * g) >= Math.floor(100 * d[y]) && (n = y);\n        }\n\n        if (r.initialized && n !== u) {\n          if (!r.allowSlideNext && g < r.translate && g < r.minTranslate()) return !1;\n          if (!r.allowSlidePrev && g > r.translate && g > r.maxTranslate() && (u || 0) !== n) return !1;\n        }\n\n        if (m = n > u ? \"next\" : n < u ? \"prev\" : \"reset\", c && -g === r.translate || !c && g === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), \"slide\" !== l.effect && r.setTranslate(g), \"reset\" !== m && (r.transitionStart(a, m), r.transitionEnd(a, m)), !1;\n\n        if (l.cssMode) {\n          var w,\n              b = r.isHorizontal(),\n              E = -g;\n          if (c && (E = h.scrollWidth - h.offsetWidth - E), 0 === t) h[b ? \"scrollLeft\" : \"scrollTop\"] = E;else if (h.scrollTo) h.scrollTo(((w = {})[b ? \"left\" : \"top\"] = E, w.behavior = \"smooth\", w));else h[b ? \"scrollLeft\" : \"scrollTop\"] = E;\n          return !0;\n        }\n\n        return 0 === t ? (r.setTransition(0), r.setTranslate(g), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit(\"beforeTransitionStart\", t, i), r.transitionStart(a, m), r.transitionEnd(a, m)) : (r.setTransition(t), r.setTranslate(g), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit(\"beforeTransitionStart\", t, i), r.transitionStart(a, m), r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {\n          r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener(\"transitionend\", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(a, m));\n        }), r.$wrapperEl[0].addEventListener(\"transitionend\", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", r.onSlideToWrapperTransitionEnd))), !0;\n      },\n      slideToLoop: function slideToLoop(e, t, a, i) {\n        void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0);\n        var s = this,\n            r = e;\n        return s.params.loop && (r += s.loopedSlides), s.slideTo(r, t, a, i);\n      },\n      slideNext: function slideNext(e, t, a) {\n        void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);\n        var i = this,\n            s = i.params,\n            r = i.animating,\n            n = i.activeIndex < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup;\n\n        if (s.loop) {\n          if (r && s.loopPreventsSlide) return !1;\n          i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft;\n        }\n\n        return i.slideTo(i.activeIndex + n, e, t, a);\n      },\n      slidePrev: function slidePrev(e, t, a) {\n        void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);\n        var i = this,\n            s = i.params,\n            r = i.animating,\n            n = i.snapGrid,\n            l = i.slidesGrid,\n            o = i.rtlTranslate;\n\n        if (s.loop) {\n          if (r && s.loopPreventsSlide) return !1;\n          i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft;\n        }\n\n        function d(e) {\n          return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);\n        }\n\n        var p,\n            u = d(o ? i.translate : -i.translate),\n            c = n.map(function (e) {\n          return d(e);\n        }),\n            h = (n[c.indexOf(u)], n[c.indexOf(u) - 1]);\n        return void 0 === h && s.cssMode && n.forEach(function (e) {\n          !h && u >= e && (h = e);\n        }), void 0 !== h && (p = l.indexOf(h)) < 0 && (p = i.activeIndex - 1), i.slideTo(p, e, t, a);\n      },\n      slideReset: function slideReset(e, t, a) {\n        return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, a);\n      },\n      slideToClosest: function slideToClosest(e, t, a, i) {\n        void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === i && (i = .5);\n        var s = this,\n            r = s.activeIndex,\n            n = Math.min(s.params.slidesPerGroupSkip, r),\n            l = n + Math.floor((r - n) / s.params.slidesPerGroup),\n            o = s.rtlTranslate ? s.translate : -s.translate;\n\n        if (o >= s.snapGrid[l]) {\n          var d = s.snapGrid[l];\n          o - d > (s.snapGrid[l + 1] - d) * i && (r += s.params.slidesPerGroup);\n        } else {\n          var p = s.snapGrid[l - 1];\n          o - p <= (s.snapGrid[l] - p) * i && (r -= s.params.slidesPerGroup);\n        }\n\n        return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, e, t, a);\n      },\n      slideToClickedSlide: function slideToClickedSlide() {\n        var e,\n            t = this,\n            a = t.params,\n            i = t.$wrapperEl,\n            s = \"auto\" === a.slidesPerView ? t.slidesPerViewDynamic() : a.slidesPerView,\n            r = t.clickedIndex;\n\n        if (a.loop) {\n          if (t.animating) return;\n          e = parseInt(m(t.clickedSlide).attr(\"data-swiper-slide-index\"), 10), a.centeredSlides ? r < t.loopedSlides - s / 2 || r > t.slides.length - t.loopedSlides + s / 2 ? (t.loopFix(), r = i.children(\".\" + a.slideClass + '[data-swiper-slide-index=\"' + e + '\"]:not(.' + a.slideDuplicateClass + \")\").eq(0).index(), E(function () {\n            t.slideTo(r);\n          })) : t.slideTo(r) : r > t.slides.length - s ? (t.loopFix(), r = i.children(\".\" + a.slideClass + '[data-swiper-slide-index=\"' + e + '\"]:not(.' + a.slideDuplicateClass + \")\").eq(0).index(), E(function () {\n            t.slideTo(r);\n          })) : t.slideTo(r);\n        } else t.slideTo(r);\n      }\n    },\n    loop: {\n      loopCreate: function loopCreate() {\n        var e = this,\n            t = r(),\n            a = e.params,\n            i = e.$wrapperEl;\n        i.children(\".\" + a.slideClass + \".\" + a.slideDuplicateClass).remove();\n        var s = i.children(\".\" + a.slideClass);\n\n        if (a.loopFillGroupWithBlank) {\n          var n = a.slidesPerGroup - s.length % a.slidesPerGroup;\n\n          if (n !== a.slidesPerGroup) {\n            for (var l = 0; l < n; l += 1) {\n              var o = m(t.createElement(\"div\")).addClass(a.slideClass + \" \" + a.slideBlankClass);\n              i.append(o);\n            }\n\n            s = i.children(\".\" + a.slideClass);\n          }\n        }\n\n        \"auto\" !== a.slidesPerView || a.loopedSlides || (a.loopedSlides = s.length), e.loopedSlides = Math.ceil(parseFloat(a.loopedSlides || a.slidesPerView, 10)), e.loopedSlides += a.loopAdditionalSlides, e.loopedSlides > s.length && (e.loopedSlides = s.length);\n        var d = [],\n            p = [];\n        s.each(function (t, a) {\n          var i = m(t);\n          a < e.loopedSlides && p.push(t), a < s.length && a >= s.length - e.loopedSlides && d.push(t), i.attr(\"data-swiper-slide-index\", a);\n        });\n\n        for (var u = 0; u < p.length; u += 1) {\n          i.append(m(p[u].cloneNode(!0)).addClass(a.slideDuplicateClass));\n        }\n\n        for (var c = d.length - 1; c >= 0; c -= 1) {\n          i.prepend(m(d[c].cloneNode(!0)).addClass(a.slideDuplicateClass));\n        }\n      },\n      loopFix: function loopFix() {\n        var e = this;\n        e.emit(\"beforeLoopFix\");\n        var t,\n            a = e.activeIndex,\n            i = e.slides,\n            s = e.loopedSlides,\n            r = e.allowSlidePrev,\n            n = e.allowSlideNext,\n            l = e.snapGrid,\n            o = e.rtlTranslate;\n        e.allowSlidePrev = !0, e.allowSlideNext = !0;\n        var d = -l[a] - e.getTranslate();\n        if (a < s) t = i.length - 3 * s + a, t += s, e.slideTo(t, 0, !1, !0) && 0 !== d && e.setTranslate((o ? -e.translate : e.translate) - d);else if (a >= i.length - s) {\n          t = -i.length + a + s, t += s, e.slideTo(t, 0, !1, !0) && 0 !== d && e.setTranslate((o ? -e.translate : e.translate) - d);\n        }\n        e.allowSlidePrev = r, e.allowSlideNext = n, e.emit(\"loopFix\");\n      },\n      loopDestroy: function loopDestroy() {\n        var e = this,\n            t = e.$wrapperEl,\n            a = e.params,\n            i = e.slides;\n        t.children(\".\" + a.slideClass + \".\" + a.slideDuplicateClass + \",.\" + a.slideClass + \".\" + a.slideBlankClass).remove(), i.removeAttr(\"data-swiper-slide-index\");\n      }\n    },\n    grabCursor: {\n      setGrabCursor: function setGrabCursor(e) {\n        var t = this;\n\n        if (!(t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)) {\n          var a = t.el;\n          a.style.cursor = \"move\", a.style.cursor = e ? \"-webkit-grabbing\" : \"-webkit-grab\", a.style.cursor = e ? \"-moz-grabbin\" : \"-moz-grab\", a.style.cursor = e ? \"grabbing\" : \"grab\";\n        }\n      },\n      unsetGrabCursor: function unsetGrabCursor() {\n        var e = this;\n        e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.el.style.cursor = \"\");\n      }\n    },\n    manipulation: {\n      appendSlide: function appendSlide(e) {\n        var t = this,\n            a = t.$wrapperEl,\n            i = t.params;\n        if (i.loop && t.loopDestroy(), \"object\" == _typeof(e) && \"length\" in e) for (var s = 0; s < e.length; s += 1) {\n          e[s] && a.append(e[s]);\n        } else a.append(e);\n        i.loop && t.loopCreate(), i.observer && t.support.observer || t.update();\n      },\n      prependSlide: function prependSlide(e) {\n        var t = this,\n            a = t.params,\n            i = t.$wrapperEl,\n            s = t.activeIndex;\n        a.loop && t.loopDestroy();\n        var r = s + 1;\n\n        if (\"object\" == _typeof(e) && \"length\" in e) {\n          for (var n = 0; n < e.length; n += 1) {\n            e[n] && i.prepend(e[n]);\n          }\n\n          r = s + e.length;\n        } else i.prepend(e);\n\n        a.loop && t.loopCreate(), a.observer && t.support.observer || t.update(), t.slideTo(r, 0, !1);\n      },\n      addSlide: function addSlide(e, t) {\n        var a = this,\n            i = a.$wrapperEl,\n            s = a.params,\n            r = a.activeIndex;\n        s.loop && (r -= a.loopedSlides, a.loopDestroy(), a.slides = i.children(\".\" + s.slideClass));\n        var n = a.slides.length;\n        if (e <= 0) a.prependSlide(t);else if (e >= n) a.appendSlide(t);else {\n          for (var l = r > e ? r + 1 : r, o = [], d = n - 1; d >= e; d -= 1) {\n            var p = a.slides.eq(d);\n            p.remove(), o.unshift(p);\n          }\n\n          if (\"object\" == _typeof(t) && \"length\" in t) {\n            for (var u = 0; u < t.length; u += 1) {\n              t[u] && i.append(t[u]);\n            }\n\n            l = r > e ? r + t.length : r;\n          } else i.append(t);\n\n          for (var c = 0; c < o.length; c += 1) {\n            i.append(o[c]);\n          }\n\n          s.loop && a.loopCreate(), s.observer && a.support.observer || a.update(), s.loop ? a.slideTo(l + a.loopedSlides, 0, !1) : a.slideTo(l, 0, !1);\n        }\n      },\n      removeSlide: function removeSlide(e) {\n        var t = this,\n            a = t.params,\n            i = t.$wrapperEl,\n            s = t.activeIndex;\n        a.loop && (s -= t.loopedSlides, t.loopDestroy(), t.slides = i.children(\".\" + a.slideClass));\n        var r,\n            n = s;\n\n        if (\"object\" == _typeof(e) && \"length\" in e) {\n          for (var l = 0; l < e.length; l += 1) {\n            r = e[l], t.slides[r] && t.slides.eq(r).remove(), r < n && (n -= 1);\n          }\n\n          n = Math.max(n, 0);\n        } else r = e, t.slides[r] && t.slides.eq(r).remove(), r < n && (n -= 1), n = Math.max(n, 0);\n\n        a.loop && t.loopCreate(), a.observer && t.support.observer || t.update(), a.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1);\n      },\n      removeAllSlides: function removeAllSlides() {\n        for (var e = [], t = 0; t < this.slides.length; t += 1) {\n          e.push(t);\n        }\n\n        this.removeSlide(e);\n      }\n    },\n    events: {\n      attachEvents: function attachEvents() {\n        var e = this,\n            t = r(),\n            a = e.params,\n            i = e.touchEvents,\n            s = e.el,\n            n = e.wrapperEl,\n            l = e.device,\n            o = e.support;\n        e.onTouchStart = O.bind(e), e.onTouchMove = A.bind(e), e.onTouchEnd = D.bind(e), a.cssMode && (e.onScroll = B.bind(e)), e.onClick = N.bind(e);\n        var d = !!a.nested;\n        if (!o.touch && o.pointerEvents) s.addEventListener(i.start, e.onTouchStart, !1), t.addEventListener(i.move, e.onTouchMove, d), t.addEventListener(i.end, e.onTouchEnd, !1);else {\n          if (o.touch) {\n            var p = !(\"touchstart\" !== i.start || !o.passiveListener || !a.passiveListeners) && {\n              passive: !0,\n              capture: !1\n            };\n            s.addEventListener(i.start, e.onTouchStart, p), s.addEventListener(i.move, e.onTouchMove, o.passiveListener ? {\n              passive: !1,\n              capture: d\n            } : d), s.addEventListener(i.end, e.onTouchEnd, p), i.cancel && s.addEventListener(i.cancel, e.onTouchEnd, p), H || (t.addEventListener(\"touchstart\", X), H = !0);\n          }\n\n          (a.simulateTouch && !l.ios && !l.android || a.simulateTouch && !o.touch && l.ios) && (s.addEventListener(\"mousedown\", e.onTouchStart, !1), t.addEventListener(\"mousemove\", e.onTouchMove, d), t.addEventListener(\"mouseup\", e.onTouchEnd, !1));\n        }\n        (a.preventClicks || a.preventClicksPropagation) && s.addEventListener(\"click\", e.onClick, !0), a.cssMode && n.addEventListener(\"scroll\", e.onScroll), a.updateOnWindowResize ? e.on(l.ios || l.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", G, !0) : e.on(\"observerUpdate\", G, !0);\n      },\n      detachEvents: function detachEvents() {\n        var e = this,\n            t = r(),\n            a = e.params,\n            i = e.touchEvents,\n            s = e.el,\n            n = e.wrapperEl,\n            l = e.device,\n            o = e.support,\n            d = !!a.nested;\n        if (!o.touch && o.pointerEvents) s.removeEventListener(i.start, e.onTouchStart, !1), t.removeEventListener(i.move, e.onTouchMove, d), t.removeEventListener(i.end, e.onTouchEnd, !1);else {\n          if (o.touch) {\n            var p = !(\"onTouchStart\" !== i.start || !o.passiveListener || !a.passiveListeners) && {\n              passive: !0,\n              capture: !1\n            };\n            s.removeEventListener(i.start, e.onTouchStart, p), s.removeEventListener(i.move, e.onTouchMove, d), s.removeEventListener(i.end, e.onTouchEnd, p), i.cancel && s.removeEventListener(i.cancel, e.onTouchEnd, p);\n          }\n\n          (a.simulateTouch && !l.ios && !l.android || a.simulateTouch && !o.touch && l.ios) && (s.removeEventListener(\"mousedown\", e.onTouchStart, !1), t.removeEventListener(\"mousemove\", e.onTouchMove, d), t.removeEventListener(\"mouseup\", e.onTouchEnd, !1));\n        }\n        (a.preventClicks || a.preventClicksPropagation) && s.removeEventListener(\"click\", e.onClick, !0), a.cssMode && n.removeEventListener(\"scroll\", e.onScroll), e.off(l.ios || l.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", G);\n      }\n    },\n    breakpoints: {\n      setBreakpoint: function setBreakpoint() {\n        var e = this,\n            t = e.activeIndex,\n            a = e.initialized,\n            i = e.loopedSlides,\n            s = void 0 === i ? 0 : i,\n            r = e.params,\n            n = e.$el,\n            l = r.breakpoints;\n\n        if (l && (!l || 0 !== Object.keys(l).length)) {\n          var o = e.getBreakpoint(l);\n\n          if (o && e.currentBreakpoint !== o) {\n            var d = o in l ? l[o] : void 0;\n            d && [\"slidesPerView\", \"spaceBetween\", \"slidesPerGroup\", \"slidesPerGroupSkip\", \"slidesPerColumn\"].forEach(function (e) {\n              var t = d[e];\n              void 0 !== t && (d[e] = \"slidesPerView\" !== e || \"AUTO\" !== t && \"auto\" !== t ? \"slidesPerView\" === e ? parseFloat(t) : parseInt(t, 10) : \"auto\");\n            });\n            var p = d || e.originalParams,\n                u = r.slidesPerColumn > 1,\n                c = p.slidesPerColumn > 1;\n            u && !c ? (n.removeClass(r.containerModifierClass + \"multirow \" + r.containerModifierClass + \"multirow-column\"), e.emitContainerClasses()) : !u && c && (n.addClass(r.containerModifierClass + \"multirow\"), \"column\" === p.slidesPerColumnFill && n.addClass(r.containerModifierClass + \"multirow-column\"), e.emitContainerClasses());\n            var h = p.direction && p.direction !== r.direction,\n                v = r.loop && (p.slidesPerView !== r.slidesPerView || h);\n            h && a && e.changeDirection(), S(e.params, p), S(e, {\n              allowTouchMove: e.params.allowTouchMove,\n              allowSlideNext: e.params.allowSlideNext,\n              allowSlidePrev: e.params.allowSlidePrev\n            }), e.currentBreakpoint = o, e.emit(\"_beforeBreakpoint\", p), v && a && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit(\"breakpoint\", p);\n          }\n        }\n      },\n      getBreakpoint: function getBreakpoint(e) {\n        var t = l();\n\n        if (e) {\n          var a = !1,\n              i = Object.keys(e).map(function (e) {\n            if (\"string\" == typeof e && 0 === e.indexOf(\"@\")) {\n              var a = parseFloat(e.substr(1));\n              return {\n                value: t.innerHeight * a,\n                point: e\n              };\n            }\n\n            return {\n              value: e,\n              point: e\n            };\n          });\n          i.sort(function (e, t) {\n            return parseInt(e.value, 10) - parseInt(t.value, 10);\n          });\n\n          for (var s = 0; s < i.length; s += 1) {\n            var r = i[s],\n                n = r.point;\n            r.value <= t.innerWidth && (a = n);\n          }\n\n          return a || \"max\";\n        }\n      }\n    },\n    checkOverflow: {\n      checkOverflow: function checkOverflow() {\n        var e = this,\n            t = e.params,\n            a = e.isLocked,\n            i = e.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (e.slides.length - 1) + e.slides[0].offsetWidth * e.slides.length;\n        t.slidesOffsetBefore && t.slidesOffsetAfter && i ? e.isLocked = i <= e.size : e.isLocked = 1 === e.snapGrid.length, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, a !== e.isLocked && e.emit(e.isLocked ? \"lock\" : \"unlock\"), a && a !== e.isLocked && (e.isEnd = !1, e.navigation && e.navigation.update());\n      }\n    },\n    classes: {\n      addClasses: function addClasses() {\n        var e = this,\n            t = e.classNames,\n            a = e.params,\n            i = e.rtl,\n            s = e.$el,\n            r = e.device,\n            n = [];\n        n.push(\"initialized\"), n.push(a.direction), a.freeMode && n.push(\"free-mode\"), a.autoHeight && n.push(\"autoheight\"), i && n.push(\"rtl\"), a.slidesPerColumn > 1 && (n.push(\"multirow\"), \"column\" === a.slidesPerColumnFill && n.push(\"multirow-column\")), r.android && n.push(\"android\"), r.ios && n.push(\"ios\"), a.cssMode && n.push(\"css-mode\"), n.forEach(function (e) {\n          t.push(a.containerModifierClass + e);\n        }), s.addClass(t.join(\" \")), e.emitContainerClasses();\n      },\n      removeClasses: function removeClasses() {\n        var e = this,\n            t = e.$el,\n            a = e.classNames;\n        t.removeClass(a.join(\" \")), e.emitContainerClasses();\n      }\n    },\n    images: {\n      loadImage: function loadImage(e, t, a, i, s, r) {\n        var n,\n            o = l();\n\n        function d() {\n          r && r();\n        }\n\n        m(e).parent(\"picture\")[0] || e.complete && s ? d() : t ? ((n = new o.Image()).onload = d, n.onerror = d, i && (n.sizes = i), a && (n.srcset = a), t && (n.src = t)) : d();\n      },\n      preloadImages: function preloadImages() {\n        var e = this;\n\n        function t() {\n          null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit(\"imagesReady\")));\n        }\n\n        e.imagesToLoad = e.$el.find(\"img\");\n\n        for (var a = 0; a < e.imagesToLoad.length; a += 1) {\n          var i = e.imagesToLoad[a];\n          e.loadImage(i, i.currentSrc || i.getAttribute(\"src\"), i.srcset || i.getAttribute(\"srcset\"), i.sizes || i.getAttribute(\"sizes\"), !0, t);\n        }\n      }\n    }\n  },\n      F = {},\n      R = function () {\n    function t() {\n      for (var e, a, i = arguments.length, s = new Array(i), r = 0; r < i; r++) {\n        s[r] = arguments[r];\n      }\n\n      1 === s.length && s[0].constructor && s[0].constructor === Object ? a = s[0] : (e = s[0], a = s[1]), a || (a = {}), a = S({}, a), e && !a.el && (a.el = e);\n      var n = this;\n      n.support = z(), n.device = P({\n        userAgent: a.userAgent\n      }), n.browser = k(), n.eventsListeners = {}, n.eventsAnyListeners = [], void 0 === n.modules && (n.modules = {}), Object.keys(n.modules).forEach(function (e) {\n        var t = n.modules[e];\n\n        if (t.params) {\n          var i = Object.keys(t.params)[0],\n              s = t.params[i];\n          if (\"object\" != _typeof(s) || null === s) return;\n          if (!(i in a) || !(\"enabled\" in s)) return;\n          !0 === a[i] && (a[i] = {\n            enabled: !0\n          }), \"object\" != _typeof(a[i]) || \"enabled\" in a[i] || (a[i].enabled = !0), a[i] || (a[i] = {\n            enabled: !1\n          });\n        }\n      });\n      var l = S({}, Y);\n      n.useParams(l), n.params = S({}, l, F, a), n.originalParams = S({}, n.params), n.passedParams = S({}, a), n.params && n.params.on && Object.keys(n.params.on).forEach(function (e) {\n        n.on(e, n.params.on[e]);\n      }), n.params && n.params.onAny && n.onAny(n.params.onAny), n.$ = m;\n      var o = m(n.params.el);\n\n      if (e = o[0]) {\n        if (o.length > 1) {\n          var d = [];\n          return o.each(function (e) {\n            var i = S({}, a, {\n              el: e\n            });\n            d.push(new t(i));\n          }), d;\n        }\n\n        var p, u, c;\n        return e.swiper = n, e && e.shadowRoot && e.shadowRoot.querySelector ? (p = m(e.shadowRoot.querySelector(\".\" + n.params.wrapperClass))).children = function (e) {\n          return o.children(e);\n        } : p = o.children(\".\" + n.params.wrapperClass), S(n, {\n          $el: o,\n          el: e,\n          $wrapperEl: p,\n          wrapperEl: p[0],\n          classNames: [],\n          slides: m(),\n          slidesGrid: [],\n          snapGrid: [],\n          slidesSizesGrid: [],\n          isHorizontal: function isHorizontal() {\n            return \"horizontal\" === n.params.direction;\n          },\n          isVertical: function isVertical() {\n            return \"vertical\" === n.params.direction;\n          },\n          rtl: \"rtl\" === e.dir.toLowerCase() || \"rtl\" === o.css(\"direction\"),\n          rtlTranslate: \"horizontal\" === n.params.direction && (\"rtl\" === e.dir.toLowerCase() || \"rtl\" === o.css(\"direction\")),\n          wrongRTL: \"-webkit-box\" === p.css(\"display\"),\n          activeIndex: 0,\n          realIndex: 0,\n          isBeginning: !0,\n          isEnd: !1,\n          translate: 0,\n          previousTranslate: 0,\n          progress: 0,\n          velocity: 0,\n          animating: !1,\n          allowSlideNext: n.params.allowSlideNext,\n          allowSlidePrev: n.params.allowSlidePrev,\n          touchEvents: (u = [\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"], c = [\"mousedown\", \"mousemove\", \"mouseup\"], n.support.pointerEvents && (c = [\"pointerdown\", \"pointermove\", \"pointerup\"]), n.touchEventsTouch = {\n            start: u[0],\n            move: u[1],\n            end: u[2],\n            cancel: u[3]\n          }, n.touchEventsDesktop = {\n            start: c[0],\n            move: c[1],\n            end: c[2]\n          }, n.support.touch || !n.params.simulateTouch ? n.touchEventsTouch : n.touchEventsDesktop),\n          touchEventsData: {\n            isTouched: void 0,\n            isMoved: void 0,\n            allowTouchCallbacks: void 0,\n            touchStartTime: void 0,\n            isScrolling: void 0,\n            currentTranslate: void 0,\n            startTranslate: void 0,\n            allowThresholdMove: void 0,\n            formElements: \"input, select, option, textarea, button, video, label\",\n            lastClickTime: x(),\n            clickTimeout: void 0,\n            velocities: [],\n            allowMomentumBounce: void 0,\n            isTouchEvent: void 0,\n            startMoving: void 0\n          },\n          allowClick: !0,\n          allowTouchMove: n.params.allowTouchMove,\n          touches: {\n            startX: 0,\n            startY: 0,\n            currentX: 0,\n            currentY: 0,\n            diff: 0\n          },\n          imagesToLoad: [],\n          imagesLoaded: 0\n        }), n.useModules(), n.emit(\"_swiper\"), n.params.init && n.init(), n;\n      }\n    }\n\n    var a,\n        i,\n        s,\n        r = t.prototype;\n    return r.emitContainerClasses = function () {\n      var e = this;\n\n      if (e.params._emitClasses && e.el) {\n        var t = e.el.className.split(\" \").filter(function (t) {\n          return 0 === t.indexOf(\"swiper-container\") || 0 === t.indexOf(e.params.containerModifierClass);\n        });\n        e.emit(\"_containerClasses\", t.join(\" \"));\n      }\n    }, r.getSlideClasses = function (e) {\n      var t = this;\n      return e.className.split(\" \").filter(function (e) {\n        return 0 === e.indexOf(\"swiper-slide\") || 0 === e.indexOf(t.params.slideClass);\n      }).join(\" \");\n    }, r.emitSlidesClasses = function () {\n      var e = this;\n      e.params._emitClasses && e.el && e.slides.each(function (t) {\n        var a = e.getSlideClasses(t);\n        e.emit(\"_slideClass\", t, a);\n      });\n    }, r.slidesPerViewDynamic = function () {\n      var e = this,\n          t = e.params,\n          a = e.slides,\n          i = e.slidesGrid,\n          s = e.size,\n          r = e.activeIndex,\n          n = 1;\n\n      if (t.centeredSlides) {\n        for (var l, o = a[r].swiperSlideSize, d = r + 1; d < a.length; d += 1) {\n          a[d] && !l && (n += 1, (o += a[d].swiperSlideSize) > s && (l = !0));\n        }\n\n        for (var p = r - 1; p >= 0; p -= 1) {\n          a[p] && !l && (n += 1, (o += a[p].swiperSlideSize) > s && (l = !0));\n        }\n      } else for (var u = r + 1; u < a.length; u += 1) {\n        i[u] - i[r] < s && (n += 1);\n      }\n\n      return n;\n    }, r.update = function () {\n      var e = this;\n\n      if (e && !e.destroyed) {\n        var t = e.snapGrid,\n            a = e.params;\n        a.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (i(), e.params.autoHeight && e.updateAutoHeight()) : ((\"auto\" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0)) || i(), a.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit(\"update\");\n      }\n\n      function i() {\n        var t = e.rtlTranslate ? -1 * e.translate : e.translate,\n            a = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());\n        e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses();\n      }\n    }, r.changeDirection = function (e, t) {\n      void 0 === t && (t = !0);\n      var a = this,\n          i = a.params.direction;\n      return e || (e = \"horizontal\" === i ? \"vertical\" : \"horizontal\"), e === i || \"horizontal\" !== e && \"vertical\" !== e || (a.$el.removeClass(\"\" + a.params.containerModifierClass + i).addClass(\"\" + a.params.containerModifierClass + e), a.emitContainerClasses(), a.params.direction = e, a.slides.each(function (t) {\n        \"vertical\" === e ? t.style.width = \"\" : t.style.height = \"\";\n      }), a.emit(\"changeDirection\"), t && a.update()), a;\n    }, r.init = function () {\n      var e = this;\n      e.initialized || (e.emit(\"beforeInit\"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit(\"init\"), e.emit(\"afterInit\"));\n    }, r.destroy = function (e, t) {\n      void 0 === e && (e = !0), void 0 === t && (t = !0);\n      var a,\n          i = this,\n          s = i.params,\n          r = i.$el,\n          n = i.$wrapperEl,\n          l = i.slides;\n      return void 0 === i.params || i.destroyed || (i.emit(\"beforeDestroy\"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), r.removeAttr(\"style\"), n.removeAttr(\"style\"), l && l.length && l.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(\" \")).removeAttr(\"style\").removeAttr(\"data-swiper-slide-index\")), i.emit(\"destroy\"), Object.keys(i.eventsListeners).forEach(function (e) {\n        i.off(e);\n      }), !1 !== e && (i.$el[0].swiper = null, a = i, Object.keys(a).forEach(function (e) {\n        try {\n          a[e] = null;\n        } catch (e) {}\n\n        try {\n          delete a[e];\n        } catch (e) {}\n      })), i.destroyed = !0), null;\n    }, t.extendDefaults = function (e) {\n      S(F, e);\n    }, t.installModule = function (e) {\n      t.prototype.modules || (t.prototype.modules = {});\n      var a = e.name || Object.keys(t.prototype.modules).length + \"_\" + x();\n      t.prototype.modules[a] = e;\n    }, t.use = function (e) {\n      return Array.isArray(e) ? (e.forEach(function (e) {\n        return t.installModule(e);\n      }), t) : (t.installModule(e), t);\n    }, a = t, s = [{\n      key: \"extendedDefaults\",\n      get: function get() {\n        return F;\n      }\n    }, {\n      key: \"defaults\",\n      get: function get() {\n        return Y;\n      }\n    }], (i = null) && e(a.prototype, i), s && e(a, s), t;\n  }();\n\n  Object.keys(V).forEach(function (e) {\n    Object.keys(V[e]).forEach(function (t) {\n      R.prototype[t] = V[e][t];\n    });\n  }), R.use([L, I]);\n  var W = {\n    update: function update(e) {\n      var t = this,\n          a = t.params,\n          i = a.slidesPerView,\n          s = a.slidesPerGroup,\n          r = a.centeredSlides,\n          n = t.params.virtual,\n          l = n.addSlidesBefore,\n          o = n.addSlidesAfter,\n          d = t.virtual,\n          p = d.from,\n          u = d.to,\n          c = d.slides,\n          h = d.slidesGrid,\n          v = d.renderSlide,\n          f = d.offset;\n      t.updateActiveIndex();\n      var m,\n          g,\n          y,\n          w = t.activeIndex || 0;\n      m = t.rtlTranslate ? \"right\" : t.isHorizontal() ? \"left\" : \"top\", r ? (g = Math.floor(i / 2) + s + o, y = Math.floor(i / 2) + s + l) : (g = i + (s - 1) + o, y = s + l);\n      var b = Math.max((w || 0) - y, 0),\n          E = Math.min((w || 0) + g, c.length - 1),\n          x = (t.slidesGrid[b] || 0) - (t.slidesGrid[0] || 0);\n\n      function T() {\n        t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load();\n      }\n\n      if (S(t.virtual, {\n        from: b,\n        to: E,\n        offset: x,\n        slidesGrid: t.slidesGrid\n      }), p === b && u === E && !e) return t.slidesGrid !== h && x !== f && t.slides.css(m, x + \"px\"), void t.updateProgress();\n      if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, {\n        offset: x,\n        from: b,\n        to: E,\n        slides: function () {\n          for (var e = [], t = b; t <= E; t += 1) {\n            e.push(c[t]);\n          }\n\n          return e;\n        }()\n      }), void (t.params.virtual.renderExternalUpdate && T());\n      var C = [],\n          M = [];\n      if (e) t.$wrapperEl.find(\".\" + t.params.slideClass).remove();else for (var z = p; z <= u; z += 1) {\n        (z < b || z > E) && t.$wrapperEl.find(\".\" + t.params.slideClass + '[data-swiper-slide-index=\"' + z + '\"]').remove();\n      }\n\n      for (var P = 0; P < c.length; P += 1) {\n        P >= b && P <= E && (void 0 === u || e ? M.push(P) : (P > u && M.push(P), P < p && C.push(P)));\n      }\n\n      M.forEach(function (e) {\n        t.$wrapperEl.append(v(c[e], e));\n      }), C.sort(function (e, t) {\n        return t - e;\n      }).forEach(function (e) {\n        t.$wrapperEl.prepend(v(c[e], e));\n      }), t.$wrapperEl.children(\".swiper-slide\").css(m, x + \"px\"), T();\n    },\n    renderSlide: function renderSlide(e, t) {\n      var a = this,\n          i = a.params.virtual;\n      if (i.cache && a.virtual.cache[t]) return a.virtual.cache[t];\n      var s = i.renderSlide ? m(i.renderSlide.call(a, e, t)) : m('<div class=\"' + a.params.slideClass + '\" data-swiper-slide-index=\"' + t + '\">' + e + \"</div>\");\n      return s.attr(\"data-swiper-slide-index\") || s.attr(\"data-swiper-slide-index\", t), i.cache && (a.virtual.cache[t] = s), s;\n    },\n    appendSlide: function appendSlide(e) {\n      var t = this;\n      if (\"object\" == _typeof(e) && \"length\" in e) for (var a = 0; a < e.length; a += 1) {\n        e[a] && t.virtual.slides.push(e[a]);\n      } else t.virtual.slides.push(e);\n      t.virtual.update(!0);\n    },\n    prependSlide: function prependSlide(e) {\n      var t = this,\n          a = t.activeIndex,\n          i = a + 1,\n          s = 1;\n\n      if (Array.isArray(e)) {\n        for (var r = 0; r < e.length; r += 1) {\n          e[r] && t.virtual.slides.unshift(e[r]);\n        }\n\n        i = a + e.length, s = e.length;\n      } else t.virtual.slides.unshift(e);\n\n      if (t.params.virtual.cache) {\n        var n = t.virtual.cache,\n            l = {};\n        Object.keys(n).forEach(function (e) {\n          var t = n[e],\n              a = t.attr(\"data-swiper-slide-index\");\n          a && t.attr(\"data-swiper-slide-index\", parseInt(a, 10) + 1), l[parseInt(e, 10) + s] = t;\n        }), t.virtual.cache = l;\n      }\n\n      t.virtual.update(!0), t.slideTo(i, 0);\n    },\n    removeSlide: function removeSlide(e) {\n      var t = this;\n\n      if (null != e) {\n        var a = t.activeIndex;\n        if (Array.isArray(e)) for (var i = e.length - 1; i >= 0; i -= 1) {\n          t.virtual.slides.splice(e[i], 1), t.params.virtual.cache && delete t.virtual.cache[e[i]], e[i] < a && (a -= 1), a = Math.max(a, 0);\n        } else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < a && (a -= 1), a = Math.max(a, 0);\n        t.virtual.update(!0), t.slideTo(a, 0);\n      }\n    },\n    removeAllSlides: function removeAllSlides() {\n      var e = this;\n      e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), e.virtual.update(!0), e.slideTo(0, 0);\n    }\n  },\n      q = {\n    name: \"virtual\",\n    params: {\n      virtual: {\n        enabled: !1,\n        slides: [],\n        cache: !0,\n        renderSlide: null,\n        renderExternal: null,\n        renderExternalUpdate: !0,\n        addSlidesBefore: 0,\n        addSlidesAfter: 0\n      }\n    },\n    create: function create() {\n      M(this, {\n        virtual: t({}, W, {\n          slides: this.params.virtual.slides,\n          cache: {}\n        })\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        if (e.params.virtual.enabled) {\n          e.classNames.push(e.params.containerModifierClass + \"virtual\");\n          var t = {\n            watchSlidesProgress: !0\n          };\n          S(e.params, t), S(e.originalParams, t), e.params.initialSlide || e.virtual.update();\n        }\n      },\n      setTranslate: function setTranslate(e) {\n        e.params.virtual.enabled && e.virtual.update();\n      }\n    }\n  },\n      j = {\n    handle: function handle(e) {\n      var t = this,\n          a = l(),\n          i = r(),\n          s = t.rtlTranslate,\n          n = e;\n      n.originalEvent && (n = n.originalEvent);\n      var o = n.keyCode || n.charCode,\n          d = t.params.keyboard.pageUpDown,\n          p = d && 33 === o,\n          u = d && 34 === o,\n          c = 37 === o,\n          h = 39 === o,\n          v = 38 === o,\n          f = 40 === o;\n      if (!t.allowSlideNext && (t.isHorizontal() && h || t.isVertical() && f || u)) return !1;\n      if (!t.allowSlidePrev && (t.isHorizontal() && c || t.isVertical() && v || p)) return !1;\n\n      if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || i.activeElement && i.activeElement.nodeName && (\"input\" === i.activeElement.nodeName.toLowerCase() || \"textarea\" === i.activeElement.nodeName.toLowerCase()))) {\n        if (t.params.keyboard.onlyInViewport && (p || u || c || h || v || f)) {\n          var m = !1;\n          if (t.$el.parents(\".\" + t.params.slideClass).length > 0 && 0 === t.$el.parents(\".\" + t.params.slideActiveClass).length) return;\n          var g = a.innerWidth,\n              y = a.innerHeight,\n              w = t.$el.offset();\n          s && (w.left -= t.$el[0].scrollLeft);\n\n          for (var b = [[w.left, w.top], [w.left + t.width, w.top], [w.left, w.top + t.height], [w.left + t.width, w.top + t.height]], E = 0; E < b.length; E += 1) {\n            var x = b[E];\n\n            if (x[0] >= 0 && x[0] <= g && x[1] >= 0 && x[1] <= y) {\n              if (0 === x[0] && 0 === x[1]) continue;\n              m = !0;\n            }\n          }\n\n          if (!m) return;\n        }\n\n        t.isHorizontal() ? ((p || u || c || h) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((u || h) && !s || (p || c) && s) && t.slideNext(), ((p || c) && !s || (u || h) && s) && t.slidePrev()) : ((p || u || v || f) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (u || f) && t.slideNext(), (p || v) && t.slidePrev()), t.emit(\"keyPress\", o);\n      }\n    },\n    enable: function enable() {\n      var e = this,\n          t = r();\n      e.keyboard.enabled || (m(t).on(\"keydown\", e.keyboard.handle), e.keyboard.enabled = !0);\n    },\n    disable: function disable() {\n      var e = this,\n          t = r();\n      e.keyboard.enabled && (m(t).off(\"keydown\", e.keyboard.handle), e.keyboard.enabled = !1);\n    }\n  },\n      _ = {\n    name: \"keyboard\",\n    params: {\n      keyboard: {\n        enabled: !1,\n        onlyInViewport: !0,\n        pageUpDown: !0\n      }\n    },\n    create: function create() {\n      M(this, {\n        keyboard: t({\n          enabled: !1\n        }, j)\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.params.keyboard.enabled && e.keyboard.enable();\n      },\n      destroy: function destroy(e) {\n        e.keyboard.enabled && e.keyboard.disable();\n      }\n    }\n  };\n  var U = {\n    lastScrollTime: x(),\n    lastEventBeforeSnap: void 0,\n    recentWheelEvents: [],\n    event: function event() {\n      return l().navigator.userAgent.indexOf(\"firefox\") > -1 ? \"DOMMouseScroll\" : function () {\n        var e = r(),\n            t = \"onwheel\",\n            a = (t in e);\n\n        if (!a) {\n          var i = e.createElement(\"div\");\n          i.setAttribute(t, \"return;\"), a = \"function\" == typeof i.onwheel;\n        }\n\n        return !a && e.implementation && e.implementation.hasFeature && !0 !== e.implementation.hasFeature(\"\", \"\") && (a = e.implementation.hasFeature(\"Events.wheel\", \"3.0\")), a;\n      }() ? \"wheel\" : \"mousewheel\";\n    },\n    normalize: function normalize(e) {\n      var t = 0,\n          a = 0,\n          i = 0,\n          s = 0;\n      return \"detail\" in e && (a = e.detail), \"wheelDelta\" in e && (a = -e.wheelDelta / 120), \"wheelDeltaY\" in e && (a = -e.wheelDeltaY / 120), \"wheelDeltaX\" in e && (t = -e.wheelDeltaX / 120), \"axis\" in e && e.axis === e.HORIZONTAL_AXIS && (t = a, a = 0), i = 10 * t, s = 10 * a, \"deltaY\" in e && (s = e.deltaY), \"deltaX\" in e && (i = e.deltaX), e.shiftKey && !i && (i = s, s = 0), (i || s) && e.deltaMode && (1 === e.deltaMode ? (i *= 40, s *= 40) : (i *= 800, s *= 800)), i && !t && (t = i < 1 ? -1 : 1), s && !a && (a = s < 1 ? -1 : 1), {\n        spinX: t,\n        spinY: a,\n        pixelX: i,\n        pixelY: s\n      };\n    },\n    handleMouseEnter: function handleMouseEnter() {\n      this.mouseEntered = !0;\n    },\n    handleMouseLeave: function handleMouseLeave() {\n      this.mouseEntered = !1;\n    },\n    handle: function handle(e) {\n      var t = e,\n          a = this,\n          i = a.params.mousewheel;\n      a.params.cssMode && t.preventDefault();\n      var s = a.$el;\n      if (\"container\" !== a.params.mousewheel.eventsTarget && (s = m(a.params.mousewheel.eventsTarget)), !a.mouseEntered && !s[0].contains(t.target) && !i.releaseOnEdges) return !0;\n      t.originalEvent && (t = t.originalEvent);\n      var r = 0,\n          n = a.rtlTranslate ? -1 : 1,\n          l = U.normalize(t);\n      if (i.forceToAxis) {\n        if (a.isHorizontal()) {\n          if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0;\n          r = -l.pixelX * n;\n        } else {\n          if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0;\n          r = -l.pixelY;\n        }\n      } else r = Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * n : -l.pixelY;\n      if (0 === r) return !0;\n      i.invert && (r = -r);\n      var o = a.getTranslate() + r * i.sensitivity;\n\n      if (o >= a.minTranslate() && (o = a.minTranslate()), o <= a.maxTranslate() && (o = a.maxTranslate()), (!!a.params.loop || !(o === a.minTranslate() || o === a.maxTranslate())) && a.params.nested && t.stopPropagation(), a.params.freeMode) {\n        var d = {\n          time: x(),\n          delta: Math.abs(r),\n          direction: Math.sign(r)\n        },\n            p = a.mousewheel.lastEventBeforeSnap,\n            u = p && d.time < p.time + 500 && d.delta <= p.delta && d.direction === p.direction;\n\n        if (!u) {\n          a.mousewheel.lastEventBeforeSnap = void 0, a.params.loop && a.loopFix();\n          var c = a.getTranslate() + r * i.sensitivity,\n              h = a.isBeginning,\n              v = a.isEnd;\n\n          if (c >= a.minTranslate() && (c = a.minTranslate()), c <= a.maxTranslate() && (c = a.maxTranslate()), a.setTransition(0), a.setTranslate(c), a.updateProgress(), a.updateActiveIndex(), a.updateSlidesClasses(), (!h && a.isBeginning || !v && a.isEnd) && a.updateSlidesClasses(), a.params.freeModeSticky) {\n            clearTimeout(a.mousewheel.timeout), a.mousewheel.timeout = void 0;\n            var f = a.mousewheel.recentWheelEvents;\n            f.length >= 15 && f.shift();\n            var g = f.length ? f[f.length - 1] : void 0,\n                y = f[0];\n            if (f.push(d), g && (d.delta > g.delta || d.direction !== g.direction)) f.splice(0);else if (f.length >= 15 && d.time - y.time < 500 && y.delta - d.delta >= 1 && d.delta <= 6) {\n              var w = r > 0 ? .8 : .2;\n              a.mousewheel.lastEventBeforeSnap = d, f.splice(0), a.mousewheel.timeout = E(function () {\n                a.slideToClosest(a.params.speed, !0, void 0, w);\n              }, 0);\n            }\n            a.mousewheel.timeout || (a.mousewheel.timeout = E(function () {\n              a.mousewheel.lastEventBeforeSnap = d, f.splice(0), a.slideToClosest(a.params.speed, !0, void 0, .5);\n            }, 500));\n          }\n\n          if (u || a.emit(\"scroll\", t), a.params.autoplay && a.params.autoplayDisableOnInteraction && a.autoplay.stop(), c === a.minTranslate() || c === a.maxTranslate()) return !0;\n        }\n      } else {\n        var b = {\n          time: x(),\n          delta: Math.abs(r),\n          direction: Math.sign(r),\n          raw: e\n        },\n            T = a.mousewheel.recentWheelEvents;\n        T.length >= 2 && T.shift();\n        var C = T.length ? T[T.length - 1] : void 0;\n        if (T.push(b), C ? (b.direction !== C.direction || b.delta > C.delta || b.time > C.time + 150) && a.mousewheel.animateSlider(b) : a.mousewheel.animateSlider(b), a.mousewheel.releaseScroll(b)) return !0;\n      }\n\n      return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1;\n    },\n    animateSlider: function animateSlider(e) {\n      var t = this,\n          a = l();\n      return !(this.params.mousewheel.thresholdDelta && e.delta < this.params.mousewheel.thresholdDelta) && !(this.params.mousewheel.thresholdTime && x() - t.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) && (e.delta >= 6 && x() - t.mousewheel.lastScrollTime < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), t.emit(\"scroll\", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), t.emit(\"scroll\", e.raw)), t.mousewheel.lastScrollTime = new a.Date().getTime(), !1));\n    },\n    releaseScroll: function releaseScroll(e) {\n      var t = this,\n          a = t.params.mousewheel;\n\n      if (e.direction < 0) {\n        if (t.isEnd && !t.params.loop && a.releaseOnEdges) return !0;\n      } else if (t.isBeginning && !t.params.loop && a.releaseOnEdges) return !0;\n\n      return !1;\n    },\n    enable: function enable() {\n      var e = this,\n          t = U.event();\n      if (e.params.cssMode) return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0;\n      if (!t) return !1;\n      if (e.mousewheel.enabled) return !1;\n      var a = e.$el;\n      return \"container\" !== e.params.mousewheel.eventsTarget && (a = m(e.params.mousewheel.eventsTarget)), a.on(\"mouseenter\", e.mousewheel.handleMouseEnter), a.on(\"mouseleave\", e.mousewheel.handleMouseLeave), a.on(t, e.mousewheel.handle), e.mousewheel.enabled = !0, !0;\n    },\n    disable: function disable() {\n      var e = this,\n          t = U.event();\n      if (e.params.cssMode) return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0;\n      if (!t) return !1;\n      if (!e.mousewheel.enabled) return !1;\n      var a = e.$el;\n      return \"container\" !== e.params.mousewheel.eventsTarget && (a = m(e.params.mousewheel.eventsTarget)), a.off(t, e.mousewheel.handle), e.mousewheel.enabled = !1, !0;\n    }\n  },\n      K = {\n    update: function update() {\n      var e = this,\n          t = e.params.navigation;\n\n      if (!e.params.loop) {\n        var a = e.navigation,\n            i = a.$nextEl,\n            s = a.$prevEl;\n        s && s.length > 0 && (e.isBeginning ? s.addClass(t.disabledClass) : s.removeClass(t.disabledClass), s[e.params.watchOverflow && e.isLocked ? \"addClass\" : \"removeClass\"](t.lockClass)), i && i.length > 0 && (e.isEnd ? i.addClass(t.disabledClass) : i.removeClass(t.disabledClass), i[e.params.watchOverflow && e.isLocked ? \"addClass\" : \"removeClass\"](t.lockClass));\n      }\n    },\n    onPrevClick: function onPrevClick(e) {\n      var t = this;\n      e.preventDefault(), t.isBeginning && !t.params.loop || t.slidePrev();\n    },\n    onNextClick: function onNextClick(e) {\n      var t = this;\n      e.preventDefault(), t.isEnd && !t.params.loop || t.slideNext();\n    },\n    init: function init() {\n      var e,\n          t,\n          a = this,\n          i = a.params.navigation;\n      (i.nextEl || i.prevEl) && (i.nextEl && (e = m(i.nextEl), a.params.uniqueNavElements && \"string\" == typeof i.nextEl && e.length > 1 && 1 === a.$el.find(i.nextEl).length && (e = a.$el.find(i.nextEl))), i.prevEl && (t = m(i.prevEl), a.params.uniqueNavElements && \"string\" == typeof i.prevEl && t.length > 1 && 1 === a.$el.find(i.prevEl).length && (t = a.$el.find(i.prevEl))), e && e.length > 0 && e.on(\"click\", a.navigation.onNextClick), t && t.length > 0 && t.on(\"click\", a.navigation.onPrevClick), S(a.navigation, {\n        $nextEl: e,\n        nextEl: e && e[0],\n        $prevEl: t,\n        prevEl: t && t[0]\n      }));\n    },\n    destroy: function destroy() {\n      var e = this,\n          t = e.navigation,\n          a = t.$nextEl,\n          i = t.$prevEl;\n      a && a.length && (a.off(\"click\", e.navigation.onNextClick), a.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off(\"click\", e.navigation.onPrevClick), i.removeClass(e.params.navigation.disabledClass));\n    }\n  },\n      Z = {\n    update: function update() {\n      var e = this,\n          t = e.rtl,\n          a = e.params.pagination;\n\n      if (a.el && e.pagination.el && e.pagination.$el && 0 !== e.pagination.$el.length) {\n        var i,\n            s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,\n            r = e.pagination.$el,\n            n = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;\n\n        if (e.params.loop ? ((i = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup)) > s - 1 - 2 * e.loopedSlides && (i -= s - 2 * e.loopedSlides), i > n - 1 && (i -= n), i < 0 && \"bullets\" !== e.params.paginationType && (i = n + i)) : i = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, \"bullets\" === a.type && e.pagination.bullets && e.pagination.bullets.length > 0) {\n          var l,\n              o,\n              d,\n              p = e.pagination.bullets;\n          if (a.dynamicBullets && (e.pagination.bulletSize = p.eq(0)[e.isHorizontal() ? \"outerWidth\" : \"outerHeight\"](!0), r.css(e.isHorizontal() ? \"width\" : \"height\", e.pagination.bulletSize * (a.dynamicMainBullets + 4) + \"px\"), a.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += i - e.previousIndex, e.pagination.dynamicBulletIndex > a.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = a.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), l = i - e.pagination.dynamicBulletIndex, d = ((o = l + (Math.min(p.length, a.dynamicMainBullets) - 1)) + l) / 2), p.removeClass(a.bulletActiveClass + \" \" + a.bulletActiveClass + \"-next \" + a.bulletActiveClass + \"-next-next \" + a.bulletActiveClass + \"-prev \" + a.bulletActiveClass + \"-prev-prev \" + a.bulletActiveClass + \"-main\"), r.length > 1) p.each(function (e) {\n            var t = m(e),\n                s = t.index();\n            s === i && t.addClass(a.bulletActiveClass), a.dynamicBullets && (s >= l && s <= o && t.addClass(a.bulletActiveClass + \"-main\"), s === l && t.prev().addClass(a.bulletActiveClass + \"-prev\").prev().addClass(a.bulletActiveClass + \"-prev-prev\"), s === o && t.next().addClass(a.bulletActiveClass + \"-next\").next().addClass(a.bulletActiveClass + \"-next-next\"));\n          });else {\n            var u = p.eq(i),\n                c = u.index();\n\n            if (u.addClass(a.bulletActiveClass), a.dynamicBullets) {\n              for (var h = p.eq(l), v = p.eq(o), f = l; f <= o; f += 1) {\n                p.eq(f).addClass(a.bulletActiveClass + \"-main\");\n              }\n\n              if (e.params.loop) {\n                if (c >= p.length - a.dynamicMainBullets) {\n                  for (var g = a.dynamicMainBullets; g >= 0; g -= 1) {\n                    p.eq(p.length - g).addClass(a.bulletActiveClass + \"-main\");\n                  }\n\n                  p.eq(p.length - a.dynamicMainBullets - 1).addClass(a.bulletActiveClass + \"-prev\");\n                } else h.prev().addClass(a.bulletActiveClass + \"-prev\").prev().addClass(a.bulletActiveClass + \"-prev-prev\"), v.next().addClass(a.bulletActiveClass + \"-next\").next().addClass(a.bulletActiveClass + \"-next-next\");\n              } else h.prev().addClass(a.bulletActiveClass + \"-prev\").prev().addClass(a.bulletActiveClass + \"-prev-prev\"), v.next().addClass(a.bulletActiveClass + \"-next\").next().addClass(a.bulletActiveClass + \"-next-next\");\n            }\n          }\n\n          if (a.dynamicBullets) {\n            var y = Math.min(p.length, a.dynamicMainBullets + 4),\n                w = (e.pagination.bulletSize * y - e.pagination.bulletSize) / 2 - d * e.pagination.bulletSize,\n                b = t ? \"right\" : \"left\";\n            p.css(e.isHorizontal() ? b : \"top\", w + \"px\");\n          }\n        }\n\n        if (\"fraction\" === a.type && (r.find(\".\" + a.currentClass).text(a.formatFractionCurrent(i + 1)), r.find(\".\" + a.totalClass).text(a.formatFractionTotal(n))), \"progressbar\" === a.type) {\n          var E;\n          E = a.progressbarOpposite ? e.isHorizontal() ? \"vertical\" : \"horizontal\" : e.isHorizontal() ? \"horizontal\" : \"vertical\";\n          var x = (i + 1) / n,\n              T = 1,\n              C = 1;\n          \"horizontal\" === E ? T = x : C = x, r.find(\".\" + a.progressbarFillClass).transform(\"translate3d(0,0,0) scaleX(\" + T + \") scaleY(\" + C + \")\").transition(e.params.speed);\n        }\n\n        \"custom\" === a.type && a.renderCustom ? (r.html(a.renderCustom(e, i + 1, n)), e.emit(\"paginationRender\", r[0])) : e.emit(\"paginationUpdate\", r[0]), r[e.params.watchOverflow && e.isLocked ? \"addClass\" : \"removeClass\"](a.lockClass);\n      }\n    },\n    render: function render() {\n      var e = this,\n          t = e.params.pagination;\n\n      if (t.el && e.pagination.el && e.pagination.$el && 0 !== e.pagination.$el.length) {\n        var a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,\n            i = e.pagination.$el,\n            s = \"\";\n\n        if (\"bullets\" === t.type) {\n          for (var r = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length, n = 0; n < r; n += 1) {\n            t.renderBullet ? s += t.renderBullet.call(e, n, t.bulletClass) : s += \"<\" + t.bulletElement + ' class=\"' + t.bulletClass + '\"></' + t.bulletElement + \">\";\n          }\n\n          i.html(s), e.pagination.bullets = i.find(\".\" + t.bulletClass.replace(/ /g, \".\"));\n        }\n\n        \"fraction\" === t.type && (s = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : '<span class=\"' + t.currentClass + '\"></span> / <span class=\"' + t.totalClass + '\"></span>', i.html(s)), \"progressbar\" === t.type && (s = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : '<span class=\"' + t.progressbarFillClass + '\"></span>', i.html(s)), \"custom\" !== t.type && e.emit(\"paginationRender\", e.pagination.$el[0]);\n      }\n    },\n    init: function init() {\n      var e = this,\n          t = e.params.pagination;\n\n      if (t.el) {\n        var a = m(t.el);\n        0 !== a.length && (e.params.uniqueNavElements && \"string\" == typeof t.el && a.length > 1 && (a = e.$el.find(t.el)), \"bullets\" === t.type && t.clickable && a.addClass(t.clickableClass), a.addClass(t.modifierClass + t.type), \"bullets\" === t.type && t.dynamicBullets && (a.addClass(\"\" + t.modifierClass + t.type + \"-dynamic\"), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), \"progressbar\" === t.type && t.progressbarOpposite && a.addClass(t.progressbarOppositeClass), t.clickable && a.on(\"click\", \".\" + t.bulletClass.replace(/ /g, \".\"), function (t) {\n          t.preventDefault();\n          var a = m(this).index() * e.params.slidesPerGroup;\n          e.params.loop && (a += e.loopedSlides), e.slideTo(a);\n        }), S(e.pagination, {\n          $el: a,\n          el: a[0]\n        }));\n      }\n    },\n    destroy: function destroy() {\n      var e = this,\n          t = e.params.pagination;\n\n      if (t.el && e.pagination.el && e.pagination.$el && 0 !== e.pagination.$el.length) {\n        var a = e.pagination.$el;\n        a.removeClass(t.hiddenClass), a.removeClass(t.modifierClass + t.type), e.pagination.bullets && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && a.off(\"click\", \".\" + t.bulletClass.replace(/ /g, \".\"));\n      }\n    }\n  },\n      J = {\n    setTranslate: function setTranslate() {\n      var e = this;\n\n      if (e.params.scrollbar.el && e.scrollbar.el) {\n        var t = e.scrollbar,\n            a = e.rtlTranslate,\n            i = e.progress,\n            s = t.dragSize,\n            r = t.trackSize,\n            n = t.$dragEl,\n            l = t.$el,\n            o = e.params.scrollbar,\n            d = s,\n            p = (r - s) * i;\n        a ? (p = -p) > 0 ? (d = s - p, p = 0) : -p + s > r && (d = r + p) : p < 0 ? (d = s + p, p = 0) : p + s > r && (d = r - p), e.isHorizontal() ? (n.transform(\"translate3d(\" + p + \"px, 0, 0)\"), n[0].style.width = d + \"px\") : (n.transform(\"translate3d(0px, \" + p + \"px, 0)\"), n[0].style.height = d + \"px\"), o.hide && (clearTimeout(e.scrollbar.timeout), l[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(function () {\n          l[0].style.opacity = 0, l.transition(400);\n        }, 1e3));\n      }\n    },\n    setTransition: function setTransition(e) {\n      var t = this;\n      t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e);\n    },\n    updateSize: function updateSize() {\n      var e = this;\n\n      if (e.params.scrollbar.el && e.scrollbar.el) {\n        var t = e.scrollbar,\n            a = t.$dragEl,\n            i = t.$el;\n        a[0].style.width = \"\", a[0].style.height = \"\";\n        var s,\n            r = e.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight,\n            n = e.size / e.virtualSize,\n            l = n * (r / e.size);\n        s = \"auto\" === e.params.scrollbar.dragSize ? r * n : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? a[0].style.width = s + \"px\" : a[0].style.height = s + \"px\", i[0].style.display = n >= 1 ? \"none\" : \"\", e.params.scrollbar.hide && (i[0].style.opacity = 0), S(t, {\n          trackSize: r,\n          divider: n,\n          moveDivider: l,\n          dragSize: s\n        }), t.$el[e.params.watchOverflow && e.isLocked ? \"addClass\" : \"removeClass\"](e.params.scrollbar.lockClass);\n      }\n    },\n    getPointerPosition: function getPointerPosition(e) {\n      return this.isHorizontal() ? \"touchstart\" === e.type || \"touchmove\" === e.type ? e.targetTouches[0].clientX : e.clientX : \"touchstart\" === e.type || \"touchmove\" === e.type ? e.targetTouches[0].clientY : e.clientY;\n    },\n    setDragPosition: function setDragPosition(e) {\n      var t,\n          a = this,\n          i = a.scrollbar,\n          s = a.rtlTranslate,\n          r = i.$el,\n          n = i.dragSize,\n          l = i.trackSize,\n          o = i.dragStartPos;\n      t = (i.getPointerPosition(e) - r.offset()[a.isHorizontal() ? \"left\" : \"top\"] - (null !== o ? o : n / 2)) / (l - n), t = Math.max(Math.min(t, 1), 0), s && (t = 1 - t);\n      var d = a.minTranslate() + (a.maxTranslate() - a.minTranslate()) * t;\n      a.updateProgress(d), a.setTranslate(d), a.updateActiveIndex(), a.updateSlidesClasses();\n    },\n    onDragStart: function onDragStart(e) {\n      var t = this,\n          a = t.params.scrollbar,\n          i = t.scrollbar,\n          s = t.$wrapperEl,\n          r = i.$el,\n          n = i.$dragEl;\n      t.scrollbar.isTouched = !0, t.scrollbar.dragStartPos = e.target === n[0] || e.target === n ? i.getPointerPosition(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? \"left\" : \"top\"] : null, e.preventDefault(), e.stopPropagation(), s.transition(100), n.transition(100), i.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), r.transition(0), a.hide && r.css(\"opacity\", 1), t.params.cssMode && t.$wrapperEl.css(\"scroll-snap-type\", \"none\"), t.emit(\"scrollbarDragStart\", e);\n    },\n    onDragMove: function onDragMove(e) {\n      var t = this,\n          a = t.scrollbar,\n          i = t.$wrapperEl,\n          s = a.$el,\n          r = a.$dragEl;\n      t.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, a.setDragPosition(e), i.transition(0), s.transition(0), r.transition(0), t.emit(\"scrollbarDragMove\", e));\n    },\n    onDragEnd: function onDragEnd(e) {\n      var t = this,\n          a = t.params.scrollbar,\n          i = t.scrollbar,\n          s = t.$wrapperEl,\n          r = i.$el;\n      t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, t.params.cssMode && (t.$wrapperEl.css(\"scroll-snap-type\", \"\"), s.transition(\"\")), a.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = E(function () {\n        r.css(\"opacity\", 0), r.transition(400);\n      }, 1e3)), t.emit(\"scrollbarDragEnd\", e), a.snapOnRelease && t.slideToClosest());\n    },\n    enableDraggable: function enableDraggable() {\n      var e = this;\n\n      if (e.params.scrollbar.el) {\n        var t = r(),\n            a = e.scrollbar,\n            i = e.touchEventsTouch,\n            s = e.touchEventsDesktop,\n            n = e.params,\n            l = e.support,\n            o = a.$el[0],\n            d = !(!l.passiveListener || !n.passiveListeners) && {\n          passive: !1,\n          capture: !1\n        },\n            p = !(!l.passiveListener || !n.passiveListeners) && {\n          passive: !0,\n          capture: !1\n        };\n        l.touch ? (o.addEventListener(i.start, e.scrollbar.onDragStart, d), o.addEventListener(i.move, e.scrollbar.onDragMove, d), o.addEventListener(i.end, e.scrollbar.onDragEnd, p)) : (o.addEventListener(s.start, e.scrollbar.onDragStart, d), t.addEventListener(s.move, e.scrollbar.onDragMove, d), t.addEventListener(s.end, e.scrollbar.onDragEnd, p));\n      }\n    },\n    disableDraggable: function disableDraggable() {\n      var e = this;\n\n      if (e.params.scrollbar.el) {\n        var t = r(),\n            a = e.scrollbar,\n            i = e.touchEventsTouch,\n            s = e.touchEventsDesktop,\n            n = e.params,\n            l = e.support,\n            o = a.$el[0],\n            d = !(!l.passiveListener || !n.passiveListeners) && {\n          passive: !1,\n          capture: !1\n        },\n            p = !(!l.passiveListener || !n.passiveListeners) && {\n          passive: !0,\n          capture: !1\n        };\n        l.touch ? (o.removeEventListener(i.start, e.scrollbar.onDragStart, d), o.removeEventListener(i.move, e.scrollbar.onDragMove, d), o.removeEventListener(i.end, e.scrollbar.onDragEnd, p)) : (o.removeEventListener(s.start, e.scrollbar.onDragStart, d), t.removeEventListener(s.move, e.scrollbar.onDragMove, d), t.removeEventListener(s.end, e.scrollbar.onDragEnd, p));\n      }\n    },\n    init: function init() {\n      var e = this;\n\n      if (e.params.scrollbar.el) {\n        var t = e.scrollbar,\n            a = e.$el,\n            i = e.params.scrollbar,\n            s = m(i.el);\n        e.params.uniqueNavElements && \"string\" == typeof i.el && s.length > 1 && 1 === a.find(i.el).length && (s = a.find(i.el));\n        var r = s.find(\".\" + e.params.scrollbar.dragClass);\n        0 === r.length && (r = m('<div class=\"' + e.params.scrollbar.dragClass + '\"></div>'), s.append(r)), S(t, {\n          $el: s,\n          el: s[0],\n          $dragEl: r,\n          dragEl: r[0]\n        }), i.draggable && t.enableDraggable();\n      }\n    },\n    destroy: function destroy() {\n      this.scrollbar.disableDraggable();\n    }\n  },\n      Q = {\n    setTransform: function setTransform(e, t) {\n      var a = this.rtl,\n          i = m(e),\n          s = a ? -1 : 1,\n          r = i.attr(\"data-swiper-parallax\") || \"0\",\n          n = i.attr(\"data-swiper-parallax-x\"),\n          l = i.attr(\"data-swiper-parallax-y\"),\n          o = i.attr(\"data-swiper-parallax-scale\"),\n          d = i.attr(\"data-swiper-parallax-opacity\");\n\n      if (n || l ? (n = n || \"0\", l = l || \"0\") : this.isHorizontal() ? (n = r, l = \"0\") : (l = r, n = \"0\"), n = n.indexOf(\"%\") >= 0 ? parseInt(n, 10) * t * s + \"%\" : n * t * s + \"px\", l = l.indexOf(\"%\") >= 0 ? parseInt(l, 10) * t + \"%\" : l * t + \"px\", null != d) {\n        var p = d - (d - 1) * (1 - Math.abs(t));\n        i[0].style.opacity = p;\n      }\n\n      if (null == o) i.transform(\"translate3d(\" + n + \", \" + l + \", 0px)\");else {\n        var u = o - (o - 1) * (1 - Math.abs(t));\n        i.transform(\"translate3d(\" + n + \", \" + l + \", 0px) scale(\" + u + \")\");\n      }\n    },\n    setTranslate: function setTranslate() {\n      var e = this,\n          t = e.$el,\n          a = e.slides,\n          i = e.progress,\n          s = e.snapGrid;\n      t.children(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each(function (t) {\n        e.parallax.setTransform(t, i);\n      }), a.each(function (t, a) {\n        var r = t.progress;\n        e.params.slidesPerGroup > 1 && \"auto\" !== e.params.slidesPerView && (r += Math.ceil(a / 2) - i * (s.length - 1)), r = Math.min(Math.max(r, -1), 1), m(t).find(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each(function (t) {\n          e.parallax.setTransform(t, r);\n        });\n      });\n    },\n    setTransition: function setTransition(e) {\n      void 0 === e && (e = this.params.speed);\n      this.$el.find(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each(function (t) {\n        var a = m(t),\n            i = parseInt(a.attr(\"data-swiper-parallax-duration\"), 10) || e;\n        0 === e && (i = 0), a.transition(i);\n      });\n    }\n  },\n      ee = {\n    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {\n      if (e.targetTouches.length < 2) return 1;\n      var t = e.targetTouches[0].pageX,\n          a = e.targetTouches[0].pageY,\n          i = e.targetTouches[1].pageX,\n          s = e.targetTouches[1].pageY;\n      return Math.sqrt(Math.pow(i - t, 2) + Math.pow(s - a, 2));\n    },\n    onGestureStart: function onGestureStart(e) {\n      var t = this,\n          a = t.support,\n          i = t.params.zoom,\n          s = t.zoom,\n          r = s.gesture;\n\n      if (s.fakeGestureTouched = !1, s.fakeGestureMoved = !1, !a.gestures) {\n        if (\"touchstart\" !== e.type || \"touchstart\" === e.type && e.targetTouches.length < 2) return;\n        s.fakeGestureTouched = !0, r.scaleStart = ee.getDistanceBetweenTouches(e);\n      }\n\n      r.$slideEl && r.$slideEl.length || (r.$slideEl = m(e.target).closest(\".\" + t.params.slideClass), 0 === r.$slideEl.length && (r.$slideEl = t.slides.eq(t.activeIndex)), r.$imageEl = r.$slideEl.find(\"img, svg, canvas, picture, .swiper-zoom-target\"), r.$imageWrapEl = r.$imageEl.parent(\".\" + i.containerClass), r.maxRatio = r.$imageWrapEl.attr(\"data-swiper-zoom\") || i.maxRatio, 0 !== r.$imageWrapEl.length) ? (r.$imageEl && r.$imageEl.transition(0), t.zoom.isScaling = !0) : r.$imageEl = void 0;\n    },\n    onGestureChange: function onGestureChange(e) {\n      var t = this,\n          a = t.support,\n          i = t.params.zoom,\n          s = t.zoom,\n          r = s.gesture;\n\n      if (!a.gestures) {\n        if (\"touchmove\" !== e.type || \"touchmove\" === e.type && e.targetTouches.length < 2) return;\n        s.fakeGestureMoved = !0, r.scaleMove = ee.getDistanceBetweenTouches(e);\n      }\n\n      r.$imageEl && 0 !== r.$imageEl.length ? (a.gestures ? s.scale = e.scale * s.currentScale : s.scale = r.scaleMove / r.scaleStart * s.currentScale, s.scale > r.maxRatio && (s.scale = r.maxRatio - 1 + Math.pow(s.scale - r.maxRatio + 1, .5)), s.scale < i.minRatio && (s.scale = i.minRatio + 1 - Math.pow(i.minRatio - s.scale + 1, .5)), r.$imageEl.transform(\"translate3d(0,0,0) scale(\" + s.scale + \")\")) : \"gesturechange\" === e.type && s.onGestureStart(e);\n    },\n    onGestureEnd: function onGestureEnd(e) {\n      var t = this,\n          a = t.device,\n          i = t.support,\n          s = t.params.zoom,\n          r = t.zoom,\n          n = r.gesture;\n\n      if (!i.gestures) {\n        if (!r.fakeGestureTouched || !r.fakeGestureMoved) return;\n        if (\"touchend\" !== e.type || \"touchend\" === e.type && e.changedTouches.length < 2 && !a.android) return;\n        r.fakeGestureTouched = !1, r.fakeGestureMoved = !1;\n      }\n\n      n.$imageEl && 0 !== n.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, n.maxRatio), s.minRatio), n.$imageEl.transition(t.params.speed).transform(\"translate3d(0,0,0) scale(\" + r.scale + \")\"), r.currentScale = r.scale, r.isScaling = !1, 1 === r.scale && (n.$slideEl = void 0));\n    },\n    onTouchStart: function onTouchStart(e) {\n      var t = this.device,\n          a = this.zoom,\n          i = a.gesture,\n          s = a.image;\n      i.$imageEl && 0 !== i.$imageEl.length && (s.isTouched || (t.android && e.cancelable && e.preventDefault(), s.isTouched = !0, s.touchesStart.x = \"touchstart\" === e.type ? e.targetTouches[0].pageX : e.pageX, s.touchesStart.y = \"touchstart\" === e.type ? e.targetTouches[0].pageY : e.pageY));\n    },\n    onTouchMove: function onTouchMove(e) {\n      var t = this,\n          a = t.zoom,\n          i = a.gesture,\n          s = a.image,\n          r = a.velocity;\n\n      if (i.$imageEl && 0 !== i.$imageEl.length && (t.allowClick = !1, s.isTouched && i.$slideEl)) {\n        s.isMoved || (s.width = i.$imageEl[0].offsetWidth, s.height = i.$imageEl[0].offsetHeight, s.startX = T(i.$imageWrapEl[0], \"x\") || 0, s.startY = T(i.$imageWrapEl[0], \"y\") || 0, i.slideWidth = i.$slideEl[0].offsetWidth, i.slideHeight = i.$slideEl[0].offsetHeight, i.$imageWrapEl.transition(0), t.rtl && (s.startX = -s.startX, s.startY = -s.startY));\n        var n = s.width * a.scale,\n            l = s.height * a.scale;\n\n        if (!(n < i.slideWidth && l < i.slideHeight)) {\n          if (s.minX = Math.min(i.slideWidth / 2 - n / 2, 0), s.maxX = -s.minX, s.minY = Math.min(i.slideHeight / 2 - l / 2, 0), s.maxY = -s.minY, s.touchesCurrent.x = \"touchmove\" === e.type ? e.targetTouches[0].pageX : e.pageX, s.touchesCurrent.y = \"touchmove\" === e.type ? e.targetTouches[0].pageY : e.pageY, !s.isMoved && !a.isScaling) {\n            if (t.isHorizontal() && (Math.floor(s.minX) === Math.floor(s.startX) && s.touchesCurrent.x < s.touchesStart.x || Math.floor(s.maxX) === Math.floor(s.startX) && s.touchesCurrent.x > s.touchesStart.x)) return void (s.isTouched = !1);\n            if (!t.isHorizontal() && (Math.floor(s.minY) === Math.floor(s.startY) && s.touchesCurrent.y < s.touchesStart.y || Math.floor(s.maxY) === Math.floor(s.startY) && s.touchesCurrent.y > s.touchesStart.y)) return void (s.isTouched = !1);\n          }\n\n          e.cancelable && e.preventDefault(), e.stopPropagation(), s.isMoved = !0, s.currentX = s.touchesCurrent.x - s.touchesStart.x + s.startX, s.currentY = s.touchesCurrent.y - s.touchesStart.y + s.startY, s.currentX < s.minX && (s.currentX = s.minX + 1 - Math.pow(s.minX - s.currentX + 1, .8)), s.currentX > s.maxX && (s.currentX = s.maxX - 1 + Math.pow(s.currentX - s.maxX + 1, .8)), s.currentY < s.minY && (s.currentY = s.minY + 1 - Math.pow(s.minY - s.currentY + 1, .8)), s.currentY > s.maxY && (s.currentY = s.maxY - 1 + Math.pow(s.currentY - s.maxY + 1, .8)), r.prevPositionX || (r.prevPositionX = s.touchesCurrent.x), r.prevPositionY || (r.prevPositionY = s.touchesCurrent.y), r.prevTime || (r.prevTime = Date.now()), r.x = (s.touchesCurrent.x - r.prevPositionX) / (Date.now() - r.prevTime) / 2, r.y = (s.touchesCurrent.y - r.prevPositionY) / (Date.now() - r.prevTime) / 2, Math.abs(s.touchesCurrent.x - r.prevPositionX) < 2 && (r.x = 0), Math.abs(s.touchesCurrent.y - r.prevPositionY) < 2 && (r.y = 0), r.prevPositionX = s.touchesCurrent.x, r.prevPositionY = s.touchesCurrent.y, r.prevTime = Date.now(), i.$imageWrapEl.transform(\"translate3d(\" + s.currentX + \"px, \" + s.currentY + \"px,0)\");\n        }\n      }\n    },\n    onTouchEnd: function onTouchEnd() {\n      var e = this.zoom,\n          t = e.gesture,\n          a = e.image,\n          i = e.velocity;\n\n      if (t.$imageEl && 0 !== t.$imageEl.length) {\n        if (!a.isTouched || !a.isMoved) return a.isTouched = !1, void (a.isMoved = !1);\n        a.isTouched = !1, a.isMoved = !1;\n        var s = 300,\n            r = 300,\n            n = i.x * s,\n            l = a.currentX + n,\n            o = i.y * r,\n            d = a.currentY + o;\n        0 !== i.x && (s = Math.abs((l - a.currentX) / i.x)), 0 !== i.y && (r = Math.abs((d - a.currentY) / i.y));\n        var p = Math.max(s, r);\n        a.currentX = l, a.currentY = d;\n        var u = a.width * e.scale,\n            c = a.height * e.scale;\n        a.minX = Math.min(t.slideWidth / 2 - u / 2, 0), a.maxX = -a.minX, a.minY = Math.min(t.slideHeight / 2 - c / 2, 0), a.maxY = -a.minY, a.currentX = Math.max(Math.min(a.currentX, a.maxX), a.minX), a.currentY = Math.max(Math.min(a.currentY, a.maxY), a.minY), t.$imageWrapEl.transition(p).transform(\"translate3d(\" + a.currentX + \"px, \" + a.currentY + \"px,0)\");\n      }\n    },\n    onTransitionEnd: function onTransitionEnd() {\n      var e = this,\n          t = e.zoom,\n          a = t.gesture;\n      a.$slideEl && e.previousIndex !== e.activeIndex && (a.$imageEl && a.$imageEl.transform(\"translate3d(0,0,0) scale(1)\"), a.$imageWrapEl && a.$imageWrapEl.transform(\"translate3d(0,0,0)\"), t.scale = 1, t.currentScale = 1, a.$slideEl = void 0, a.$imageEl = void 0, a.$imageWrapEl = void 0);\n    },\n    toggle: function toggle(e) {\n      var t = this.zoom;\n      t.scale && 1 !== t.scale ? t.out() : t[\"in\"](e);\n    },\n    \"in\": function _in(e) {\n      var t,\n          a,\n          i,\n          s,\n          r,\n          n,\n          l,\n          o,\n          d,\n          p,\n          u,\n          c,\n          h,\n          v,\n          f,\n          m,\n          g = this,\n          y = g.zoom,\n          w = g.params.zoom,\n          b = y.gesture,\n          E = y.image;\n      (b.$slideEl || (g.params.virtual && g.params.virtual.enabled && g.virtual ? b.$slideEl = g.$wrapperEl.children(\".\" + g.params.slideActiveClass) : b.$slideEl = g.slides.eq(g.activeIndex), b.$imageEl = b.$slideEl.find(\"img, svg, canvas, picture, .swiper-zoom-target\"), b.$imageWrapEl = b.$imageEl.parent(\".\" + w.containerClass)), b.$imageEl && 0 !== b.$imageEl.length) && (b.$slideEl.addClass(\"\" + w.zoomedSlideClass), void 0 === E.touchesStart.x && e ? (t = \"touchend\" === e.type ? e.changedTouches[0].pageX : e.pageX, a = \"touchend\" === e.type ? e.changedTouches[0].pageY : e.pageY) : (t = E.touchesStart.x, a = E.touchesStart.y), y.scale = b.$imageWrapEl.attr(\"data-swiper-zoom\") || w.maxRatio, y.currentScale = b.$imageWrapEl.attr(\"data-swiper-zoom\") || w.maxRatio, e ? (f = b.$slideEl[0].offsetWidth, m = b.$slideEl[0].offsetHeight, i = b.$slideEl.offset().left + f / 2 - t, s = b.$slideEl.offset().top + m / 2 - a, l = b.$imageEl[0].offsetWidth, o = b.$imageEl[0].offsetHeight, d = l * y.scale, p = o * y.scale, h = -(u = Math.min(f / 2 - d / 2, 0)), v = -(c = Math.min(m / 2 - p / 2, 0)), (r = i * y.scale) < u && (r = u), r > h && (r = h), (n = s * y.scale) < c && (n = c), n > v && (n = v)) : (r = 0, n = 0), b.$imageWrapEl.transition(300).transform(\"translate3d(\" + r + \"px, \" + n + \"px,0)\"), b.$imageEl.transition(300).transform(\"translate3d(0,0,0) scale(\" + y.scale + \")\"));\n    },\n    out: function out() {\n      var e = this,\n          t = e.zoom,\n          a = e.params.zoom,\n          i = t.gesture;\n      i.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? i.$slideEl = e.$wrapperEl.children(\".\" + e.params.slideActiveClass) : i.$slideEl = e.slides.eq(e.activeIndex), i.$imageEl = i.$slideEl.find(\"img, svg, canvas, picture, .swiper-zoom-target\"), i.$imageWrapEl = i.$imageEl.parent(\".\" + a.containerClass)), i.$imageEl && 0 !== i.$imageEl.length && (t.scale = 1, t.currentScale = 1, i.$imageWrapEl.transition(300).transform(\"translate3d(0,0,0)\"), i.$imageEl.transition(300).transform(\"translate3d(0,0,0) scale(1)\"), i.$slideEl.removeClass(\"\" + a.zoomedSlideClass), i.$slideEl = void 0);\n    },\n    toggleGestures: function toggleGestures(e) {\n      var t = this,\n          a = t.zoom,\n          i = a.slideSelector,\n          s = a.passiveListener;\n      t.$wrapperEl[e](\"gesturestart\", i, a.onGestureStart, s), t.$wrapperEl[e](\"gesturechange\", i, a.onGestureChange, s), t.$wrapperEl[e](\"gestureend\", i, a.onGestureEnd, s);\n    },\n    enableGestures: function enableGestures() {\n      this.zoom.gesturesEnabled || (this.zoom.gesturesEnabled = !0, this.zoom.toggleGestures(\"on\"));\n    },\n    disableGestures: function disableGestures() {\n      this.zoom.gesturesEnabled && (this.zoom.gesturesEnabled = !1, this.zoom.toggleGestures(\"off\"));\n    },\n    enable: function enable() {\n      var e = this,\n          t = e.support,\n          a = e.zoom;\n\n      if (!a.enabled) {\n        a.enabled = !0;\n        var i = !(\"touchstart\" !== e.touchEvents.start || !t.passiveListener || !e.params.passiveListeners) && {\n          passive: !0,\n          capture: !1\n        },\n            s = !t.passiveListener || {\n          passive: !1,\n          capture: !0\n        },\n            r = \".\" + e.params.slideClass;\n        e.zoom.passiveListener = i, e.zoom.slideSelector = r, t.gestures ? (e.$wrapperEl.on(e.touchEvents.start, e.zoom.enableGestures, i), e.$wrapperEl.on(e.touchEvents.end, e.zoom.disableGestures, i)) : \"touchstart\" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, r, a.onGestureStart, i), e.$wrapperEl.on(e.touchEvents.move, r, a.onGestureChange, s), e.$wrapperEl.on(e.touchEvents.end, r, a.onGestureEnd, i), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, r, a.onGestureEnd, i)), e.$wrapperEl.on(e.touchEvents.move, \".\" + e.params.zoom.containerClass, a.onTouchMove, s);\n      }\n    },\n    disable: function disable() {\n      var e = this,\n          t = e.zoom;\n\n      if (t.enabled) {\n        var a = e.support;\n        e.zoom.enabled = !1;\n        var i = !(\"touchstart\" !== e.touchEvents.start || !a.passiveListener || !e.params.passiveListeners) && {\n          passive: !0,\n          capture: !1\n        },\n            s = !a.passiveListener || {\n          passive: !1,\n          capture: !0\n        },\n            r = \".\" + e.params.slideClass;\n        a.gestures ? (e.$wrapperEl.off(e.touchEvents.start, e.zoom.enableGestures, i), e.$wrapperEl.off(e.touchEvents.end, e.zoom.disableGestures, i)) : \"touchstart\" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, r, t.onGestureStart, i), e.$wrapperEl.off(e.touchEvents.move, r, t.onGestureChange, s), e.$wrapperEl.off(e.touchEvents.end, r, t.onGestureEnd, i), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, r, t.onGestureEnd, i)), e.$wrapperEl.off(e.touchEvents.move, \".\" + e.params.zoom.containerClass, t.onTouchMove, s);\n      }\n    }\n  },\n      te = {\n    loadInSlide: function loadInSlide(e, t) {\n      void 0 === t && (t = !0);\n      var a = this,\n          i = a.params.lazy;\n\n      if (void 0 !== e && 0 !== a.slides.length) {\n        var s = a.virtual && a.params.virtual.enabled ? a.$wrapperEl.children(\".\" + a.params.slideClass + '[data-swiper-slide-index=\"' + e + '\"]') : a.slides.eq(e),\n            r = s.find(\".\" + i.elementClass + \":not(.\" + i.loadedClass + \"):not(.\" + i.loadingClass + \")\");\n        !s.hasClass(i.elementClass) || s.hasClass(i.loadedClass) || s.hasClass(i.loadingClass) || r.push(s[0]), 0 !== r.length && r.each(function (e) {\n          var r = m(e);\n          r.addClass(i.loadingClass);\n          var n = r.attr(\"data-background\"),\n              l = r.attr(\"data-src\"),\n              o = r.attr(\"data-srcset\"),\n              d = r.attr(\"data-sizes\"),\n              p = r.parent(\"picture\");\n          a.loadImage(r[0], l || n, o, d, !1, function () {\n            if (null != a && a && (!a || a.params) && !a.destroyed) {\n              if (n ? (r.css(\"background-image\", 'url(\"' + n + '\")'), r.removeAttr(\"data-background\")) : (o && (r.attr(\"srcset\", o), r.removeAttr(\"data-srcset\")), d && (r.attr(\"sizes\", d), r.removeAttr(\"data-sizes\")), p.length && p.children(\"source\").each(function (e) {\n                var t = m(e);\n                t.attr(\"data-srcset\") && (t.attr(\"srcset\", t.attr(\"data-srcset\")), t.removeAttr(\"data-srcset\"));\n              }), l && (r.attr(\"src\", l), r.removeAttr(\"data-src\"))), r.addClass(i.loadedClass).removeClass(i.loadingClass), s.find(\".\" + i.preloaderClass).remove(), a.params.loop && t) {\n                var e = s.attr(\"data-swiper-slide-index\");\n\n                if (s.hasClass(a.params.slideDuplicateClass)) {\n                  var u = a.$wrapperEl.children('[data-swiper-slide-index=\"' + e + '\"]:not(.' + a.params.slideDuplicateClass + \")\");\n                  a.lazy.loadInSlide(u.index(), !1);\n                } else {\n                  var c = a.$wrapperEl.children(\".\" + a.params.slideDuplicateClass + '[data-swiper-slide-index=\"' + e + '\"]');\n                  a.lazy.loadInSlide(c.index(), !1);\n                }\n              }\n\n              a.emit(\"lazyImageReady\", s[0], r[0]), a.params.autoHeight && a.updateAutoHeight();\n            }\n          }), a.emit(\"lazyImageLoad\", s[0], r[0]);\n        });\n      }\n    },\n    load: function load() {\n      var e = this,\n          t = e.$wrapperEl,\n          a = e.params,\n          i = e.slides,\n          s = e.activeIndex,\n          r = e.virtual && a.virtual.enabled,\n          n = a.lazy,\n          l = a.slidesPerView;\n\n      function o(e) {\n        if (r) {\n          if (t.children(\".\" + a.slideClass + '[data-swiper-slide-index=\"' + e + '\"]').length) return !0;\n        } else if (i[e]) return !0;\n\n        return !1;\n      }\n\n      function d(e) {\n        return r ? m(e).attr(\"data-swiper-slide-index\") : m(e).index();\n      }\n\n      if (\"auto\" === l && (l = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility) t.children(\".\" + a.slideVisibleClass).each(function (t) {\n        var a = r ? m(t).attr(\"data-swiper-slide-index\") : m(t).index();\n        e.lazy.loadInSlide(a);\n      });else if (l > 1) for (var p = s; p < s + l; p += 1) {\n        o(p) && e.lazy.loadInSlide(p);\n      } else e.lazy.loadInSlide(s);\n      if (n.loadPrevNext) if (l > 1 || n.loadPrevNextAmount && n.loadPrevNextAmount > 1) {\n        for (var u = n.loadPrevNextAmount, c = l, h = Math.min(s + c + Math.max(u, c), i.length), v = Math.max(s - Math.max(c, u), 0), f = s + l; f < h; f += 1) {\n          o(f) && e.lazy.loadInSlide(f);\n        }\n\n        for (var g = v; g < s; g += 1) {\n          o(g) && e.lazy.loadInSlide(g);\n        }\n      } else {\n        var y = t.children(\".\" + a.slideNextClass);\n        y.length > 0 && e.lazy.loadInSlide(d(y));\n        var w = t.children(\".\" + a.slidePrevClass);\n        w.length > 0 && e.lazy.loadInSlide(d(w));\n      }\n    },\n    checkInViewOnLoad: function checkInViewOnLoad() {\n      var e = l(),\n          t = this;\n\n      if (t && !t.destroyed) {\n        var a = t.params.lazy.scrollingElement ? m(t.params.lazy.scrollingElement) : m(e),\n            i = a[0] === e,\n            s = i ? e.innerWidth : a[0].offsetWidth,\n            r = i ? e.innerHeight : a[0].offsetHeight,\n            n = t.$el.offset(),\n            o = !1;\n        t.rtlTranslate && (n.left -= t.$el[0].scrollLeft);\n\n        for (var d = [[n.left, n.top], [n.left + t.width, n.top], [n.left, n.top + t.height], [n.left + t.width, n.top + t.height]], p = 0; p < d.length; p += 1) {\n          var u = d[p];\n\n          if (u[0] >= 0 && u[0] <= s && u[1] >= 0 && u[1] <= r) {\n            if (0 === u[0] && 0 === u[1]) continue;\n            o = !0;\n          }\n        }\n\n        o ? (t.lazy.load(), a.off(\"scroll\", t.lazy.checkInViewOnLoad)) : t.lazy.scrollHandlerAttached || (t.lazy.scrollHandlerAttached = !0, a.on(\"scroll\", t.lazy.checkInViewOnLoad));\n      }\n    }\n  },\n      ae = {\n    LinearSpline: function LinearSpline(e, t) {\n      var a,\n          i,\n          s,\n          r,\n          n,\n          l = function l(e, t) {\n        for (i = -1, a = e.length; a - i > 1;) {\n          e[s = a + i >> 1] <= t ? i = s : a = s;\n        }\n\n        return a;\n      };\n\n      return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {\n        return e ? (n = l(this.x, e), r = n - 1, (e - this.x[r]) * (this.y[n] - this.y[r]) / (this.x[n] - this.x[r]) + this.y[r]) : 0;\n      }, this;\n    },\n    getInterpolateFunction: function getInterpolateFunction(e) {\n      var t = this;\n      t.controller.spline || (t.controller.spline = t.params.loop ? new ae.LinearSpline(t.slidesGrid, e.slidesGrid) : new ae.LinearSpline(t.snapGrid, e.snapGrid));\n    },\n    setTranslate: function setTranslate(e, t) {\n      var a,\n          i,\n          s = this,\n          r = s.controller.control,\n          n = s.constructor;\n\n      function l(e) {\n        var t = s.rtlTranslate ? -s.translate : s.translate;\n        \"slide\" === s.params.controller.by && (s.controller.getInterpolateFunction(e), i = -s.controller.spline.interpolate(-t)), i && \"container\" !== s.params.controller.by || (a = (e.maxTranslate() - e.minTranslate()) / (s.maxTranslate() - s.minTranslate()), i = (t - s.minTranslate()) * a + e.minTranslate()), s.params.controller.inverse && (i = e.maxTranslate() - i), e.updateProgress(i), e.setTranslate(i, s), e.updateActiveIndex(), e.updateSlidesClasses();\n      }\n\n      if (Array.isArray(r)) for (var o = 0; o < r.length; o += 1) {\n        r[o] !== t && r[o] instanceof n && l(r[o]);\n      } else r instanceof n && t !== r && l(r);\n    },\n    setTransition: function setTransition(e, t) {\n      var a,\n          i = this,\n          s = i.constructor,\n          r = i.controller.control;\n\n      function n(t) {\n        t.setTransition(e, i), 0 !== e && (t.transitionStart(), t.params.autoHeight && E(function () {\n          t.updateAutoHeight();\n        }), t.$wrapperEl.transitionEnd(function () {\n          r && (t.params.loop && \"slide\" === i.params.controller.by && t.loopFix(), t.transitionEnd());\n        }));\n      }\n\n      if (Array.isArray(r)) for (a = 0; a < r.length; a += 1) {\n        r[a] !== t && r[a] instanceof s && n(r[a]);\n      } else r instanceof s && t !== r && n(r);\n    }\n  },\n      ie = {\n    getRandomNumber: function getRandomNumber(e) {\n      void 0 === e && (e = 16);\n      return \"x\".repeat(e).replace(/x/g, function () {\n        return Math.round(16 * Math.random()).toString(16);\n      });\n    },\n    makeElFocusable: function makeElFocusable(e) {\n      return e.attr(\"tabIndex\", \"0\"), e;\n    },\n    makeElNotFocusable: function makeElNotFocusable(e) {\n      return e.attr(\"tabIndex\", \"-1\"), e;\n    },\n    addElRole: function addElRole(e, t) {\n      return e.attr(\"role\", t), e;\n    },\n    addElRoleDescription: function addElRoleDescription(e, t) {\n      return e.attr(\"aria-role-description\", t), e;\n    },\n    addElControls: function addElControls(e, t) {\n      return e.attr(\"aria-controls\", t), e;\n    },\n    addElLabel: function addElLabel(e, t) {\n      return e.attr(\"aria-label\", t), e;\n    },\n    addElId: function addElId(e, t) {\n      return e.attr(\"id\", t), e;\n    },\n    addElLive: function addElLive(e, t) {\n      return e.attr(\"aria-live\", t), e;\n    },\n    disableEl: function disableEl(e) {\n      return e.attr(\"aria-disabled\", !0), e;\n    },\n    enableEl: function enableEl(e) {\n      return e.attr(\"aria-disabled\", !1), e;\n    },\n    onEnterKey: function onEnterKey(e) {\n      var t = this,\n          a = t.params.a11y;\n\n      if (13 === e.keyCode) {\n        var i = m(e.target);\n        t.navigation && t.navigation.$nextEl && i.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(a.lastSlideMessage) : t.a11y.notify(a.nextSlideMessage)), t.navigation && t.navigation.$prevEl && i.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(a.firstSlideMessage) : t.a11y.notify(a.prevSlideMessage)), t.pagination && i.is(\".\" + t.params.pagination.bulletClass.replace(/ /g, \".\")) && i[0].click();\n      }\n    },\n    notify: function notify(e) {\n      var t = this.a11y.liveRegion;\n      0 !== t.length && (t.html(\"\"), t.html(e));\n    },\n    updateNavigation: function updateNavigation() {\n      var e = this;\n\n      if (!e.params.loop && e.navigation) {\n        var t = e.navigation,\n            a = t.$nextEl,\n            i = t.$prevEl;\n        i && i.length > 0 && (e.isBeginning ? (e.a11y.disableEl(i), e.a11y.makeElNotFocusable(i)) : (e.a11y.enableEl(i), e.a11y.makeElFocusable(i))), a && a.length > 0 && (e.isEnd ? (e.a11y.disableEl(a), e.a11y.makeElNotFocusable(a)) : (e.a11y.enableEl(a), e.a11y.makeElFocusable(a)));\n      }\n    },\n    updatePagination: function updatePagination() {\n      var e = this,\n          t = e.params.a11y;\n      e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each(function (a) {\n        var i = m(a);\n        e.a11y.makeElFocusable(i), e.params.pagination.renderBullet || (e.a11y.addElRole(i, \"button\"), e.a11y.addElLabel(i, t.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, i.index() + 1)));\n      });\n    },\n    init: function init() {\n      var e = this,\n          t = e.params.a11y;\n      e.$el.append(e.a11y.liveRegion);\n      var a = e.$el;\n      t.containerRoleDescriptionMessage && e.a11y.addElRoleDescription(a, t.containerRoleDescriptionMessage), t.containerMessage && e.a11y.addElLabel(a, t.containerMessage);\n      var i,\n          s,\n          r,\n          n = e.$wrapperEl,\n          l = n.attr(\"id\") || \"swiper-wrapper-\" + e.a11y.getRandomNumber(16);\n      e.a11y.addElId(n, l), i = e.params.autoplay && e.params.autoplay.enabled ? \"off\" : \"polite\", e.a11y.addElLive(n, i), t.itemRoleDescriptionMessage && e.a11y.addElRoleDescription(m(e.slides), t.itemRoleDescriptionMessage), e.a11y.addElRole(m(e.slides), \"group\"), e.slides.each(function (t) {\n        var a = m(t);\n        e.a11y.addElLabel(a, a.index() + 1 + \" / \" + e.slides.length);\n      }), e.navigation && e.navigation.$nextEl && (s = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (r = e.navigation.$prevEl), s && s.length && (e.a11y.makeElFocusable(s), \"BUTTON\" !== s[0].tagName && (e.a11y.addElRole(s, \"button\"), s.on(\"keydown\", e.a11y.onEnterKey)), e.a11y.addElLabel(s, t.nextSlideMessage), e.a11y.addElControls(s, l)), r && r.length && (e.a11y.makeElFocusable(r), \"BUTTON\" !== r[0].tagName && (e.a11y.addElRole(r, \"button\"), r.on(\"keydown\", e.a11y.onEnterKey)), e.a11y.addElLabel(r, t.prevSlideMessage), e.a11y.addElControls(r, l)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on(\"keydown\", \".\" + e.params.pagination.bulletClass.replace(/ /g, \".\"), e.a11y.onEnterKey);\n    },\n    destroy: function destroy() {\n      var e,\n          t,\n          a = this;\n      a.a11y.liveRegion && a.a11y.liveRegion.length > 0 && a.a11y.liveRegion.remove(), a.navigation && a.navigation.$nextEl && (e = a.navigation.$nextEl), a.navigation && a.navigation.$prevEl && (t = a.navigation.$prevEl), e && e.off(\"keydown\", a.a11y.onEnterKey), t && t.off(\"keydown\", a.a11y.onEnterKey), a.pagination && a.params.pagination.clickable && a.pagination.bullets && a.pagination.bullets.length && a.pagination.$el.off(\"keydown\", \".\" + a.params.pagination.bulletClass.replace(/ /g, \".\"), a.a11y.onEnterKey);\n    }\n  },\n      se = {\n    init: function init() {\n      var e = this,\n          t = l();\n\n      if (e.params.history) {\n        if (!t.history || !t.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0);\n        var a = e.history;\n        a.initialized = !0, a.paths = se.getPathValues(e.params.url), (a.paths.key || a.paths.value) && (a.scrollToSlide(0, a.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || t.addEventListener(\"popstate\", e.history.setHistoryPopState));\n      }\n    },\n    destroy: function destroy() {\n      var e = l();\n      this.params.history.replaceState || e.removeEventListener(\"popstate\", this.history.setHistoryPopState);\n    },\n    setHistoryPopState: function setHistoryPopState() {\n      var e = this;\n      e.history.paths = se.getPathValues(e.params.url), e.history.scrollToSlide(e.params.speed, e.history.paths.value, !1);\n    },\n    getPathValues: function getPathValues(e) {\n      var t = l(),\n          a = (e ? new URL(e) : t.location).pathname.slice(1).split(\"/\").filter(function (e) {\n        return \"\" !== e;\n      }),\n          i = a.length;\n      return {\n        key: a[i - 2],\n        value: a[i - 1]\n      };\n    },\n    setHistory: function setHistory(e, t) {\n      var a = this,\n          i = l();\n\n      if (a.history.initialized && a.params.history.enabled) {\n        var s;\n        s = a.params.url ? new URL(a.params.url) : i.location;\n        var r = a.slides.eq(t),\n            n = se.slugify(r.attr(\"data-history\"));\n        s.pathname.includes(e) || (n = e + \"/\" + n);\n        var o = i.history.state;\n        o && o.value === n || (a.params.history.replaceState ? i.history.replaceState({\n          value: n\n        }, null, n) : i.history.pushState({\n          value: n\n        }, null, n));\n      }\n    },\n    slugify: function slugify(e) {\n      return e.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n    },\n    scrollToSlide: function scrollToSlide(e, t, a) {\n      var i = this;\n      if (t) for (var s = 0, r = i.slides.length; s < r; s += 1) {\n        var n = i.slides.eq(s);\n\n        if (se.slugify(n.attr(\"data-history\")) === t && !n.hasClass(i.params.slideDuplicateClass)) {\n          var l = n.index();\n          i.slideTo(l, e, a);\n        }\n      } else i.slideTo(0, e, a);\n    }\n  },\n      re = {\n    onHashCange: function onHashCange() {\n      var e = this,\n          t = r();\n      e.emit(\"hashChange\");\n      var a = t.location.hash.replace(\"#\", \"\");\n\n      if (a !== e.slides.eq(e.activeIndex).attr(\"data-hash\")) {\n        var i = e.$wrapperEl.children(\".\" + e.params.slideClass + '[data-hash=\"' + a + '\"]').index();\n        if (void 0 === i) return;\n        e.slideTo(i);\n      }\n    },\n    setHash: function setHash() {\n      var e = this,\n          t = l(),\n          a = r();\n      if (e.hashNavigation.initialized && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && t.history && t.history.replaceState) t.history.replaceState(null, null, \"#\" + e.slides.eq(e.activeIndex).attr(\"data-hash\") || 0), e.emit(\"hashSet\");else {\n        var i = e.slides.eq(e.activeIndex),\n            s = i.attr(\"data-hash\") || i.attr(\"data-history\");\n        a.location.hash = s || \"\", e.emit(\"hashSet\");\n      }\n    },\n    init: function init() {\n      var e = this,\n          t = r(),\n          a = l();\n\n      if (!(!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled)) {\n        e.hashNavigation.initialized = !0;\n        var i = t.location.hash.replace(\"#\", \"\");\n        if (i) for (var s = 0, n = e.slides.length; s < n; s += 1) {\n          var o = e.slides.eq(s);\n\n          if ((o.attr(\"data-hash\") || o.attr(\"data-history\")) === i && !o.hasClass(e.params.slideDuplicateClass)) {\n            var d = o.index();\n            e.slideTo(d, 0, e.params.runCallbacksOnInit, !0);\n          }\n        }\n        e.params.hashNavigation.watchState && m(a).on(\"hashchange\", e.hashNavigation.onHashCange);\n      }\n    },\n    destroy: function destroy() {\n      var e = l();\n      this.params.hashNavigation.watchState && m(e).off(\"hashchange\", this.hashNavigation.onHashCange);\n    }\n  },\n      ne = {\n    run: function run() {\n      var e = this,\n          t = e.slides.eq(e.activeIndex),\n          a = e.params.autoplay.delay;\n      t.attr(\"data-swiper-autoplay\") && (a = t.attr(\"data-swiper-autoplay\") || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = E(function () {\n        var t;\n        e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), e.emit(\"autoplay\")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit(\"autoplay\")) : (t = e.slidePrev(e.params.speed, !0, !0), e.emit(\"autoplay\")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), e.emit(\"autoplay\")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (t = e.slideTo(0, e.params.speed, !0, !0), e.emit(\"autoplay\")) : (t = e.slideNext(e.params.speed, !0, !0), e.emit(\"autoplay\")), (e.params.cssMode && e.autoplay.running || !1 === t) && e.autoplay.run();\n      }, a);\n    },\n    start: function start() {\n      var e = this;\n      return void 0 === e.autoplay.timeout && !e.autoplay.running && (e.autoplay.running = !0, e.emit(\"autoplayStart\"), e.autoplay.run(), !0);\n    },\n    stop: function stop() {\n      var e = this;\n      return !!e.autoplay.running && void 0 !== e.autoplay.timeout && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit(\"autoplayStop\"), !0);\n    },\n    pause: function pause(e) {\n      var t = this;\n      t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, 0 !== e && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener(\"transitionend\", t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\", t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run())));\n    },\n    onVisibilityChange: function onVisibilityChange() {\n      var e = this,\n          t = r();\n      \"hidden\" === t.visibilityState && e.autoplay.running && e.autoplay.pause(), \"visible\" === t.visibilityState && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1);\n    },\n    onTransitionEnd: function onTransitionEnd(e) {\n      var t = this;\n      t && !t.destroyed && t.$wrapperEl && e.target === t.$wrapperEl[0] && (t.$wrapperEl[0].removeEventListener(\"transitionend\", t.autoplay.onTransitionEnd), t.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\", t.autoplay.onTransitionEnd), t.autoplay.paused = !1, t.autoplay.running ? t.autoplay.run() : t.autoplay.stop());\n    }\n  },\n      le = {\n    setTranslate: function setTranslate() {\n      for (var e = this, t = e.slides, a = 0; a < t.length; a += 1) {\n        var i = e.slides.eq(a),\n            s = -i[0].swiperSlideOffset;\n        e.params.virtualTranslate || (s -= e.translate);\n        var r = 0;\n        e.isHorizontal() || (r = s, s = 0);\n        var n = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(i[0].progress), 0) : 1 + Math.min(Math.max(i[0].progress, -1), 0);\n        i.css({\n          opacity: n\n        }).transform(\"translate3d(\" + s + \"px, \" + r + \"px, 0px)\");\n      }\n    },\n    setTransition: function setTransition(e) {\n      var t = this,\n          a = t.slides,\n          i = t.$wrapperEl;\n\n      if (a.transition(e), t.params.virtualTranslate && 0 !== e) {\n        var s = !1;\n        a.transitionEnd(function () {\n          if (!s && t && !t.destroyed) {\n            s = !0, t.animating = !1;\n\n            for (var e = [\"webkitTransitionEnd\", \"transitionend\"], a = 0; a < e.length; a += 1) {\n              i.trigger(e[a]);\n            }\n          }\n        });\n      }\n    }\n  },\n      oe = {\n    setTranslate: function setTranslate() {\n      var e,\n          t = this,\n          a = t.$el,\n          i = t.$wrapperEl,\n          s = t.slides,\n          r = t.width,\n          n = t.height,\n          l = t.rtlTranslate,\n          o = t.size,\n          d = t.browser,\n          p = t.params.cubeEffect,\n          u = t.isHorizontal(),\n          c = t.virtual && t.params.virtual.enabled,\n          h = 0;\n      p.shadow && (u ? (0 === (e = i.find(\".swiper-cube-shadow\")).length && (e = m('<div class=\"swiper-cube-shadow\"></div>'), i.append(e)), e.css({\n        height: r + \"px\"\n      })) : 0 === (e = a.find(\".swiper-cube-shadow\")).length && (e = m('<div class=\"swiper-cube-shadow\"></div>'), a.append(e)));\n\n      for (var v = 0; v < s.length; v += 1) {\n        var f = s.eq(v),\n            g = v;\n        c && (g = parseInt(f.attr(\"data-swiper-slide-index\"), 10));\n        var y = 90 * g,\n            w = Math.floor(y / 360);\n        l && (y = -y, w = Math.floor(-y / 360));\n        var b = Math.max(Math.min(f[0].progress, 1), -1),\n            E = 0,\n            x = 0,\n            T = 0;\n        g % 4 == 0 ? (E = 4 * -w * o, T = 0) : (g - 1) % 4 == 0 ? (E = 0, T = 4 * -w * o) : (g - 2) % 4 == 0 ? (E = o + 4 * w * o, T = o) : (g - 3) % 4 == 0 && (E = -o, T = 3 * o + 4 * o * w), l && (E = -E), u || (x = E, E = 0);\n        var C = \"rotateX(\" + (u ? 0 : -y) + \"deg) rotateY(\" + (u ? y : 0) + \"deg) translate3d(\" + E + \"px, \" + x + \"px, \" + T + \"px)\";\n\n        if (b <= 1 && b > -1 && (h = 90 * g + 90 * b, l && (h = 90 * -g - 90 * b)), f.transform(C), p.slideShadows) {\n          var S = u ? f.find(\".swiper-slide-shadow-left\") : f.find(\".swiper-slide-shadow-top\"),\n              M = u ? f.find(\".swiper-slide-shadow-right\") : f.find(\".swiper-slide-shadow-bottom\");\n          0 === S.length && (S = m('<div class=\"swiper-slide-shadow-' + (u ? \"left\" : \"top\") + '\"></div>'), f.append(S)), 0 === M.length && (M = m('<div class=\"swiper-slide-shadow-' + (u ? \"right\" : \"bottom\") + '\"></div>'), f.append(M)), S.length && (S[0].style.opacity = Math.max(-b, 0)), M.length && (M[0].style.opacity = Math.max(b, 0));\n        }\n      }\n\n      if (i.css({\n        \"-webkit-transform-origin\": \"50% 50% -\" + o / 2 + \"px\",\n        \"-moz-transform-origin\": \"50% 50% -\" + o / 2 + \"px\",\n        \"-ms-transform-origin\": \"50% 50% -\" + o / 2 + \"px\",\n        \"transform-origin\": \"50% 50% -\" + o / 2 + \"px\"\n      }), p.shadow) if (u) e.transform(\"translate3d(0px, \" + (r / 2 + p.shadowOffset) + \"px, \" + -r / 2 + \"px) rotateX(90deg) rotateZ(0deg) scale(\" + p.shadowScale + \")\");else {\n        var z = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90),\n            P = 1.5 - (Math.sin(2 * z * Math.PI / 360) / 2 + Math.cos(2 * z * Math.PI / 360) / 2),\n            k = p.shadowScale,\n            L = p.shadowScale / P,\n            $ = p.shadowOffset;\n        e.transform(\"scale3d(\" + k + \", 1, \" + L + \") translate3d(0px, \" + (n / 2 + $) + \"px, \" + -n / 2 / L + \"px) rotateX(-90deg)\");\n      }\n      var I = d.isSafari || d.isWebView ? -o / 2 : 0;\n      i.transform(\"translate3d(0px,0,\" + I + \"px) rotateX(\" + (t.isHorizontal() ? 0 : h) + \"deg) rotateY(\" + (t.isHorizontal() ? -h : 0) + \"deg)\");\n    },\n    setTransition: function setTransition(e) {\n      var t = this,\n          a = t.$el;\n      t.slides.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && a.find(\".swiper-cube-shadow\").transition(e);\n    }\n  },\n      de = {\n    setTranslate: function setTranslate() {\n      for (var e = this, t = e.slides, a = e.rtlTranslate, i = 0; i < t.length; i += 1) {\n        var s = t.eq(i),\n            r = s[0].progress;\n        e.params.flipEffect.limitRotation && (r = Math.max(Math.min(s[0].progress, 1), -1));\n        var n = -180 * r,\n            l = 0,\n            o = -s[0].swiperSlideOffset,\n            d = 0;\n\n        if (e.isHorizontal() ? a && (n = -n) : (d = o, o = 0, l = -n, n = 0), s[0].style.zIndex = -Math.abs(Math.round(r)) + t.length, e.params.flipEffect.slideShadows) {\n          var p = e.isHorizontal() ? s.find(\".swiper-slide-shadow-left\") : s.find(\".swiper-slide-shadow-top\"),\n              u = e.isHorizontal() ? s.find(\".swiper-slide-shadow-right\") : s.find(\".swiper-slide-shadow-bottom\");\n          0 === p.length && (p = m('<div class=\"swiper-slide-shadow-' + (e.isHorizontal() ? \"left\" : \"top\") + '\"></div>'), s.append(p)), 0 === u.length && (u = m('<div class=\"swiper-slide-shadow-' + (e.isHorizontal() ? \"right\" : \"bottom\") + '\"></div>'), s.append(u)), p.length && (p[0].style.opacity = Math.max(-r, 0)), u.length && (u[0].style.opacity = Math.max(r, 0));\n        }\n\n        s.transform(\"translate3d(\" + o + \"px, \" + d + \"px, 0px) rotateX(\" + l + \"deg) rotateY(\" + n + \"deg)\");\n      }\n    },\n    setTransition: function setTransition(e) {\n      var t = this,\n          a = t.slides,\n          i = t.activeIndex,\n          s = t.$wrapperEl;\n\n      if (a.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e), t.params.virtualTranslate && 0 !== e) {\n        var r = !1;\n        a.eq(i).transitionEnd(function () {\n          if (!r && t && !t.destroyed) {\n            r = !0, t.animating = !1;\n\n            for (var e = [\"webkitTransitionEnd\", \"transitionend\"], a = 0; a < e.length; a += 1) {\n              s.trigger(e[a]);\n            }\n          }\n        });\n      }\n    }\n  },\n      pe = {\n    setTranslate: function setTranslate() {\n      for (var e = this, t = e.width, a = e.height, i = e.slides, s = e.slidesSizesGrid, r = e.params.coverflowEffect, n = e.isHorizontal(), l = e.translate, o = n ? t / 2 - l : a / 2 - l, d = n ? r.rotate : -r.rotate, p = r.depth, u = 0, c = i.length; u < c; u += 1) {\n        var h = i.eq(u),\n            v = s[u],\n            f = (o - h[0].swiperSlideOffset - v / 2) / v * r.modifier,\n            g = n ? d * f : 0,\n            y = n ? 0 : d * f,\n            w = -p * Math.abs(f),\n            b = r.stretch;\n        \"string\" == typeof b && -1 !== b.indexOf(\"%\") && (b = parseFloat(r.stretch) / 100 * v);\n        var E = n ? 0 : b * f,\n            x = n ? b * f : 0,\n            T = 1 - (1 - r.scale) * Math.abs(f);\n        Math.abs(x) < .001 && (x = 0), Math.abs(E) < .001 && (E = 0), Math.abs(w) < .001 && (w = 0), Math.abs(g) < .001 && (g = 0), Math.abs(y) < .001 && (y = 0), Math.abs(T) < .001 && (T = 0);\n        var C = \"translate3d(\" + x + \"px,\" + E + \"px,\" + w + \"px)  rotateX(\" + y + \"deg) rotateY(\" + g + \"deg) scale(\" + T + \")\";\n\n        if (h.transform(C), h[0].style.zIndex = 1 - Math.abs(Math.round(f)), r.slideShadows) {\n          var S = n ? h.find(\".swiper-slide-shadow-left\") : h.find(\".swiper-slide-shadow-top\"),\n              M = n ? h.find(\".swiper-slide-shadow-right\") : h.find(\".swiper-slide-shadow-bottom\");\n          0 === S.length && (S = m('<div class=\"swiper-slide-shadow-' + (n ? \"left\" : \"top\") + '\"></div>'), h.append(S)), 0 === M.length && (M = m('<div class=\"swiper-slide-shadow-' + (n ? \"right\" : \"bottom\") + '\"></div>'), h.append(M)), S.length && (S[0].style.opacity = f > 0 ? f : 0), M.length && (M[0].style.opacity = -f > 0 ? -f : 0);\n        }\n      }\n    },\n    setTransition: function setTransition(e) {\n      this.slides.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e);\n    }\n  },\n      ue = {\n    init: function init() {\n      var e = this,\n          t = e.params.thumbs;\n      if (e.thumbs.initialized) return !1;\n      e.thumbs.initialized = !0;\n      var a = e.constructor;\n      return t.swiper instanceof a ? (e.thumbs.swiper = t.swiper, S(e.thumbs.swiper.originalParams, {\n        watchSlidesProgress: !0,\n        slideToClickedSlide: !1\n      }), S(e.thumbs.swiper.params, {\n        watchSlidesProgress: !0,\n        slideToClickedSlide: !1\n      })) : C(t.swiper) && (e.thumbs.swiper = new a(S({}, t.swiper, {\n        watchSlidesVisibility: !0,\n        watchSlidesProgress: !0,\n        slideToClickedSlide: !1\n      })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on(\"tap\", e.thumbs.onThumbClick), !0;\n    },\n    onThumbClick: function onThumbClick() {\n      var e = this,\n          t = e.thumbs.swiper;\n\n      if (t) {\n        var a = t.clickedIndex,\n            i = t.clickedSlide;\n\n        if (!(i && m(i).hasClass(e.params.thumbs.slideThumbActiveClass) || null == a)) {\n          var s;\n\n          if (s = t.params.loop ? parseInt(m(t.clickedSlide).attr(\"data-swiper-slide-index\"), 10) : a, e.params.loop) {\n            var r = e.activeIndex;\n            e.slides.eq(r).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, r = e.activeIndex);\n            var n = e.slides.eq(r).prevAll('[data-swiper-slide-index=\"' + s + '\"]').eq(0).index(),\n                l = e.slides.eq(r).nextAll('[data-swiper-slide-index=\"' + s + '\"]').eq(0).index();\n            s = void 0 === n ? l : void 0 === l ? n : l - r < r - n ? l : n;\n          }\n\n          e.slideTo(s);\n        }\n      }\n    },\n    update: function update(e) {\n      var t = this,\n          a = t.thumbs.swiper;\n\n      if (a) {\n        var i = \"auto\" === a.params.slidesPerView ? a.slidesPerViewDynamic() : a.params.slidesPerView,\n            s = t.params.thumbs.autoScrollOffset,\n            r = s && !a.params.loop;\n\n        if (t.realIndex !== a.realIndex || r) {\n          var n,\n              l,\n              o = a.activeIndex;\n\n          if (a.params.loop) {\n            a.slides.eq(o).hasClass(a.params.slideDuplicateClass) && (a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft, o = a.activeIndex);\n            var d = a.slides.eq(o).prevAll('[data-swiper-slide-index=\"' + t.realIndex + '\"]').eq(0).index(),\n                p = a.slides.eq(o).nextAll('[data-swiper-slide-index=\"' + t.realIndex + '\"]').eq(0).index();\n            n = void 0 === d ? p : void 0 === p ? d : p - o == o - d ? o : p - o < o - d ? p : d, l = t.activeIndex > t.previousIndex ? \"next\" : \"prev\";\n          } else l = (n = t.realIndex) > t.previousIndex ? \"next\" : \"prev\";\n\n          r && (n += \"next\" === l ? s : -1 * s), a.visibleSlidesIndexes && a.visibleSlidesIndexes.indexOf(n) < 0 && (a.params.centeredSlides ? n = n > o ? n - Math.floor(i / 2) + 1 : n + Math.floor(i / 2) - 1 : n > o && (n = n - i + 1), a.slideTo(n, e ? 0 : void 0));\n        }\n\n        var u = 1,\n            c = t.params.thumbs.slideThumbActiveClass;\n        if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (u = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (u = 1), u = Math.floor(u), a.slides.removeClass(c), a.params.loop || a.params.virtual && a.params.virtual.enabled) for (var h = 0; h < u; h += 1) {\n          a.$wrapperEl.children('[data-swiper-slide-index=\"' + (t.realIndex + h) + '\"]').addClass(c);\n        } else for (var v = 0; v < u; v += 1) {\n          a.slides.eq(t.realIndex + v).addClass(c);\n        }\n      }\n    }\n  },\n      ce = [q, _, {\n    name: \"mousewheel\",\n    params: {\n      mousewheel: {\n        enabled: !1,\n        releaseOnEdges: !1,\n        invert: !1,\n        forceToAxis: !1,\n        sensitivity: 1,\n        eventsTarget: \"container\",\n        thresholdDelta: null,\n        thresholdTime: null\n      }\n    },\n    create: function create() {\n      M(this, {\n        mousewheel: {\n          enabled: !1,\n          lastScrollTime: x(),\n          lastEventBeforeSnap: void 0,\n          recentWheelEvents: [],\n          enable: U.enable,\n          disable: U.disable,\n          handle: U.handle,\n          handleMouseEnter: U.handleMouseEnter,\n          handleMouseLeave: U.handleMouseLeave,\n          animateSlider: U.animateSlider,\n          releaseScroll: U.releaseScroll\n        }\n      });\n    },\n    on: {\n      init: function init(e) {\n        !e.params.mousewheel.enabled && e.params.cssMode && e.mousewheel.disable(), e.params.mousewheel.enabled && e.mousewheel.enable();\n      },\n      destroy: function destroy(e) {\n        e.params.cssMode && e.mousewheel.enable(), e.mousewheel.enabled && e.mousewheel.disable();\n      }\n    }\n  }, {\n    name: \"navigation\",\n    params: {\n      navigation: {\n        nextEl: null,\n        prevEl: null,\n        hideOnClick: !1,\n        disabledClass: \"swiper-button-disabled\",\n        hiddenClass: \"swiper-button-hidden\",\n        lockClass: \"swiper-button-lock\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        navigation: t({}, K)\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.navigation.init(), e.navigation.update();\n      },\n      toEdge: function toEdge(e) {\n        e.navigation.update();\n      },\n      fromEdge: function fromEdge(e) {\n        e.navigation.update();\n      },\n      destroy: function destroy(e) {\n        e.navigation.destroy();\n      },\n      click: function click(e, t) {\n        var a,\n            i = e.navigation,\n            s = i.$nextEl,\n            r = i.$prevEl;\n        !e.params.navigation.hideOnClick || m(t.target).is(r) || m(t.target).is(s) || (s ? a = s.hasClass(e.params.navigation.hiddenClass) : r && (a = r.hasClass(e.params.navigation.hiddenClass)), !0 === a ? e.emit(\"navigationShow\") : e.emit(\"navigationHide\"), s && s.toggleClass(e.params.navigation.hiddenClass), r && r.toggleClass(e.params.navigation.hiddenClass));\n      }\n    }\n  }, {\n    name: \"pagination\",\n    params: {\n      pagination: {\n        el: null,\n        bulletElement: \"span\",\n        clickable: !1,\n        hideOnClick: !1,\n        renderBullet: null,\n        renderProgressbar: null,\n        renderFraction: null,\n        renderCustom: null,\n        progressbarOpposite: !1,\n        type: \"bullets\",\n        dynamicBullets: !1,\n        dynamicMainBullets: 1,\n        formatFractionCurrent: function formatFractionCurrent(e) {\n          return e;\n        },\n        formatFractionTotal: function formatFractionTotal(e) {\n          return e;\n        },\n        bulletClass: \"swiper-pagination-bullet\",\n        bulletActiveClass: \"swiper-pagination-bullet-active\",\n        modifierClass: \"swiper-pagination-\",\n        currentClass: \"swiper-pagination-current\",\n        totalClass: \"swiper-pagination-total\",\n        hiddenClass: \"swiper-pagination-hidden\",\n        progressbarFillClass: \"swiper-pagination-progressbar-fill\",\n        progressbarOppositeClass: \"swiper-pagination-progressbar-opposite\",\n        clickableClass: \"swiper-pagination-clickable\",\n        lockClass: \"swiper-pagination-lock\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        pagination: t({\n          dynamicBulletIndex: 0\n        }, Z)\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.pagination.init(), e.pagination.render(), e.pagination.update();\n      },\n      activeIndexChange: function activeIndexChange(e) {\n        (e.params.loop || void 0 === e.snapIndex) && e.pagination.update();\n      },\n      snapIndexChange: function snapIndexChange(e) {\n        e.params.loop || e.pagination.update();\n      },\n      slidesLengthChange: function slidesLengthChange(e) {\n        e.params.loop && (e.pagination.render(), e.pagination.update());\n      },\n      snapGridLengthChange: function snapGridLengthChange(e) {\n        e.params.loop || (e.pagination.render(), e.pagination.update());\n      },\n      destroy: function destroy(e) {\n        e.pagination.destroy();\n      },\n      click: function click(e, t) {\n        e.params.pagination.el && e.params.pagination.hideOnClick && e.pagination.$el.length > 0 && !m(t.target).hasClass(e.params.pagination.bulletClass) && (!0 === e.pagination.$el.hasClass(e.params.pagination.hiddenClass) ? e.emit(\"paginationShow\") : e.emit(\"paginationHide\"), e.pagination.$el.toggleClass(e.params.pagination.hiddenClass));\n      }\n    }\n  }, {\n    name: \"scrollbar\",\n    params: {\n      scrollbar: {\n        el: null,\n        dragSize: \"auto\",\n        hide: !1,\n        draggable: !1,\n        snapOnRelease: !0,\n        lockClass: \"swiper-scrollbar-lock\",\n        dragClass: \"swiper-scrollbar-drag\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        scrollbar: t({\n          isTouched: !1,\n          timeout: null,\n          dragTimeout: null\n        }, J)\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.scrollbar.init(), e.scrollbar.updateSize(), e.scrollbar.setTranslate();\n      },\n      update: function update(e) {\n        e.scrollbar.updateSize();\n      },\n      resize: function resize(e) {\n        e.scrollbar.updateSize();\n      },\n      observerUpdate: function observerUpdate(e) {\n        e.scrollbar.updateSize();\n      },\n      setTranslate: function setTranslate(e) {\n        e.scrollbar.setTranslate();\n      },\n      setTransition: function setTransition(e, t) {\n        e.scrollbar.setTransition(t);\n      },\n      destroy: function destroy(e) {\n        e.scrollbar.destroy();\n      }\n    }\n  }, {\n    name: \"parallax\",\n    params: {\n      parallax: {\n        enabled: !1\n      }\n    },\n    create: function create() {\n      M(this, {\n        parallax: t({}, Q)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0);\n      },\n      init: function init(e) {\n        e.params.parallax.enabled && e.parallax.setTranslate();\n      },\n      setTranslate: function setTranslate(e) {\n        e.params.parallax.enabled && e.parallax.setTranslate();\n      },\n      setTransition: function setTransition(e, t) {\n        e.params.parallax.enabled && e.parallax.setTransition(t);\n      }\n    }\n  }, {\n    name: \"zoom\",\n    params: {\n      zoom: {\n        enabled: !1,\n        maxRatio: 3,\n        minRatio: 1,\n        toggle: !0,\n        containerClass: \"swiper-zoom-container\",\n        zoomedSlideClass: \"swiper-slide-zoomed\"\n      }\n    },\n    create: function create() {\n      var e = this;\n      M(e, {\n        zoom: t({\n          enabled: !1,\n          scale: 1,\n          currentScale: 1,\n          isScaling: !1,\n          gesture: {\n            $slideEl: void 0,\n            slideWidth: void 0,\n            slideHeight: void 0,\n            $imageEl: void 0,\n            $imageWrapEl: void 0,\n            maxRatio: 3\n          },\n          image: {\n            isTouched: void 0,\n            isMoved: void 0,\n            currentX: void 0,\n            currentY: void 0,\n            minX: void 0,\n            minY: void 0,\n            maxX: void 0,\n            maxY: void 0,\n            width: void 0,\n            height: void 0,\n            startX: void 0,\n            startY: void 0,\n            touchesStart: {},\n            touchesCurrent: {}\n          },\n          velocity: {\n            x: void 0,\n            y: void 0,\n            prevPositionX: void 0,\n            prevPositionY: void 0,\n            prevTime: void 0\n          }\n        }, ee)\n      });\n      var a = 1;\n      Object.defineProperty(e.zoom, \"scale\", {\n        get: function get() {\n          return a;\n        },\n        set: function set(t) {\n          if (a !== t) {\n            var i = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0,\n                s = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0;\n            e.emit(\"zoomChange\", t, i, s);\n          }\n\n          a = t;\n        }\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.params.zoom.enabled && e.zoom.enable();\n      },\n      destroy: function destroy(e) {\n        e.zoom.disable();\n      },\n      touchStart: function touchStart(e, t) {\n        e.zoom.enabled && e.zoom.onTouchStart(t);\n      },\n      touchEnd: function touchEnd(e, t) {\n        e.zoom.enabled && e.zoom.onTouchEnd(t);\n      },\n      doubleTap: function doubleTap(e, t) {\n        e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && e.zoom.toggle(t);\n      },\n      transitionEnd: function transitionEnd(e) {\n        e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd();\n      },\n      slideChange: function slideChange(e) {\n        e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && e.zoom.onTransitionEnd();\n      }\n    }\n  }, {\n    name: \"lazy\",\n    params: {\n      lazy: {\n        checkInView: !1,\n        enabled: !1,\n        loadPrevNext: !1,\n        loadPrevNextAmount: 1,\n        loadOnTransitionStart: !1,\n        scrollingElement: \"\",\n        elementClass: \"swiper-lazy\",\n        loadingClass: \"swiper-lazy-loading\",\n        loadedClass: \"swiper-lazy-loaded\",\n        preloaderClass: \"swiper-lazy-preloader\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        lazy: t({\n          initialImageLoaded: !1\n        }, te)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1);\n      },\n      init: function init(e) {\n        e.params.lazy.enabled && !e.params.loop && 0 === e.params.initialSlide && (e.params.lazy.checkInView ? e.lazy.checkInViewOnLoad() : e.lazy.load());\n      },\n      scroll: function scroll(e) {\n        e.params.freeMode && !e.params.freeModeSticky && e.lazy.load();\n      },\n      resize: function resize(e) {\n        e.params.lazy.enabled && e.lazy.load();\n      },\n      scrollbarDragMove: function scrollbarDragMove(e) {\n        e.params.lazy.enabled && e.lazy.load();\n      },\n      transitionStart: function transitionStart(e) {\n        e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load();\n      },\n      transitionEnd: function transitionEnd(e) {\n        e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load();\n      },\n      slideChange: function slideChange(e) {\n        e.params.lazy.enabled && e.params.cssMode && e.lazy.load();\n      }\n    }\n  }, {\n    name: \"controller\",\n    params: {\n      controller: {\n        control: void 0,\n        inverse: !1,\n        by: \"slide\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        controller: t({\n          control: this.params.controller.control\n        }, ae)\n      });\n    },\n    on: {\n      update: function update(e) {\n        e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline);\n      },\n      resize: function resize(e) {\n        e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline);\n      },\n      observerUpdate: function observerUpdate(e) {\n        e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline);\n      },\n      setTranslate: function setTranslate(e, t, a) {\n        e.controller.control && e.controller.setTranslate(t, a);\n      },\n      setTransition: function setTransition(e, t, a) {\n        e.controller.control && e.controller.setTransition(t, a);\n      }\n    }\n  }, {\n    name: \"a11y\",\n    params: {\n      a11y: {\n        enabled: !0,\n        notificationClass: \"swiper-notification\",\n        prevSlideMessage: \"Previous slide\",\n        nextSlideMessage: \"Next slide\",\n        firstSlideMessage: \"This is the first slide\",\n        lastSlideMessage: \"This is the last slide\",\n        paginationBulletMessage: \"Go to slide {{index}}\",\n        containerMessage: null,\n        containerRoleDescriptionMessage: null,\n        itemRoleDescriptionMessage: null\n      }\n    },\n    create: function create() {\n      M(this, {\n        a11y: t({}, ie, {\n          liveRegion: m('<span class=\"' + this.params.a11y.notificationClass + '\" aria-live=\"assertive\" aria-atomic=\"true\"></span>')\n        })\n      });\n    },\n    on: {\n      afterInit: function afterInit(e) {\n        e.params.a11y.enabled && (e.a11y.init(), e.a11y.updateNavigation());\n      },\n      toEdge: function toEdge(e) {\n        e.params.a11y.enabled && e.a11y.updateNavigation();\n      },\n      fromEdge: function fromEdge(e) {\n        e.params.a11y.enabled && e.a11y.updateNavigation();\n      },\n      paginationUpdate: function paginationUpdate(e) {\n        e.params.a11y.enabled && e.a11y.updatePagination();\n      },\n      destroy: function destroy(e) {\n        e.params.a11y.enabled && e.a11y.destroy();\n      }\n    }\n  }, {\n    name: \"history\",\n    params: {\n      history: {\n        enabled: !1,\n        replaceState: !1,\n        key: \"slides\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        history: t({}, se)\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.params.history.enabled && e.history.init();\n      },\n      destroy: function destroy(e) {\n        e.params.history.enabled && e.history.destroy();\n      },\n      transitionEnd: function transitionEnd(e) {\n        e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex);\n      },\n      slideChange: function slideChange(e) {\n        e.history.initialized && e.params.cssMode && e.history.setHistory(e.params.history.key, e.activeIndex);\n      }\n    }\n  }, {\n    name: \"hash-navigation\",\n    params: {\n      hashNavigation: {\n        enabled: !1,\n        replaceState: !1,\n        watchState: !1\n      }\n    },\n    create: function create() {\n      M(this, {\n        hashNavigation: t({\n          initialized: !1\n        }, re)\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.params.hashNavigation.enabled && e.hashNavigation.init();\n      },\n      destroy: function destroy(e) {\n        e.params.hashNavigation.enabled && e.hashNavigation.destroy();\n      },\n      transitionEnd: function transitionEnd(e) {\n        e.hashNavigation.initialized && e.hashNavigation.setHash();\n      },\n      slideChange: function slideChange(e) {\n        e.hashNavigation.initialized && e.params.cssMode && e.hashNavigation.setHash();\n      }\n    }\n  }, {\n    name: \"autoplay\",\n    params: {\n      autoplay: {\n        enabled: !1,\n        delay: 3e3,\n        waitForTransition: !0,\n        disableOnInteraction: !0,\n        stopOnLastSlide: !1,\n        reverseDirection: !1\n      }\n    },\n    create: function create() {\n      M(this, {\n        autoplay: t({}, ne, {\n          running: !1,\n          paused: !1\n        })\n      });\n    },\n    on: {\n      init: function init(e) {\n        e.params.autoplay.enabled && (e.autoplay.start(), r().addEventListener(\"visibilitychange\", e.autoplay.onVisibilityChange));\n      },\n      beforeTransitionStart: function beforeTransitionStart(e, t, a) {\n        e.autoplay.running && (a || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(t) : e.autoplay.stop());\n      },\n      sliderFirstMove: function sliderFirstMove(e) {\n        e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause());\n      },\n      touchEnd: function touchEnd(e) {\n        e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && e.autoplay.run();\n      },\n      destroy: function destroy(e) {\n        e.autoplay.running && e.autoplay.stop(), r().removeEventListener(\"visibilitychange\", e.autoplay.onVisibilityChange);\n      }\n    }\n  }, {\n    name: \"effect-fade\",\n    params: {\n      fadeEffect: {\n        crossFade: !1\n      }\n    },\n    create: function create() {\n      M(this, {\n        fadeEffect: t({}, le)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        if (\"fade\" === e.params.effect) {\n          e.classNames.push(e.params.containerModifierClass + \"fade\");\n          var t = {\n            slidesPerView: 1,\n            slidesPerColumn: 1,\n            slidesPerGroup: 1,\n            watchSlidesProgress: !0,\n            spaceBetween: 0,\n            virtualTranslate: !0\n          };\n          S(e.params, t), S(e.originalParams, t);\n        }\n      },\n      setTranslate: function setTranslate(e) {\n        \"fade\" === e.params.effect && e.fadeEffect.setTranslate();\n      },\n      setTransition: function setTransition(e, t) {\n        \"fade\" === e.params.effect && e.fadeEffect.setTransition(t);\n      }\n    }\n  }, {\n    name: \"effect-cube\",\n    params: {\n      cubeEffect: {\n        slideShadows: !0,\n        shadow: !0,\n        shadowOffset: 20,\n        shadowScale: .94\n      }\n    },\n    create: function create() {\n      M(this, {\n        cubeEffect: t({}, oe)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        if (\"cube\" === e.params.effect) {\n          e.classNames.push(e.params.containerModifierClass + \"cube\"), e.classNames.push(e.params.containerModifierClass + \"3d\");\n          var t = {\n            slidesPerView: 1,\n            slidesPerColumn: 1,\n            slidesPerGroup: 1,\n            watchSlidesProgress: !0,\n            resistanceRatio: 0,\n            spaceBetween: 0,\n            centeredSlides: !1,\n            virtualTranslate: !0\n          };\n          S(e.params, t), S(e.originalParams, t);\n        }\n      },\n      setTranslate: function setTranslate(e) {\n        \"cube\" === e.params.effect && e.cubeEffect.setTranslate();\n      },\n      setTransition: function setTransition(e, t) {\n        \"cube\" === e.params.effect && e.cubeEffect.setTransition(t);\n      }\n    }\n  }, {\n    name: \"effect-flip\",\n    params: {\n      flipEffect: {\n        slideShadows: !0,\n        limitRotation: !0\n      }\n    },\n    create: function create() {\n      M(this, {\n        flipEffect: t({}, de)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        if (\"flip\" === e.params.effect) {\n          e.classNames.push(e.params.containerModifierClass + \"flip\"), e.classNames.push(e.params.containerModifierClass + \"3d\");\n          var t = {\n            slidesPerView: 1,\n            slidesPerColumn: 1,\n            slidesPerGroup: 1,\n            watchSlidesProgress: !0,\n            spaceBetween: 0,\n            virtualTranslate: !0\n          };\n          S(e.params, t), S(e.originalParams, t);\n        }\n      },\n      setTranslate: function setTranslate(e) {\n        \"flip\" === e.params.effect && e.flipEffect.setTranslate();\n      },\n      setTransition: function setTransition(e, t) {\n        \"flip\" === e.params.effect && e.flipEffect.setTransition(t);\n      }\n    }\n  }, {\n    name: \"effect-coverflow\",\n    params: {\n      coverflowEffect: {\n        rotate: 50,\n        stretch: 0,\n        depth: 100,\n        scale: 1,\n        modifier: 1,\n        slideShadows: !0\n      }\n    },\n    create: function create() {\n      M(this, {\n        coverflowEffect: t({}, pe)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        \"coverflow\" === e.params.effect && (e.classNames.push(e.params.containerModifierClass + \"coverflow\"), e.classNames.push(e.params.containerModifierClass + \"3d\"), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0);\n      },\n      setTranslate: function setTranslate(e) {\n        \"coverflow\" === e.params.effect && e.coverflowEffect.setTranslate();\n      },\n      setTransition: function setTransition(e, t) {\n        \"coverflow\" === e.params.effect && e.coverflowEffect.setTransition(t);\n      }\n    }\n  }, {\n    name: \"thumbs\",\n    params: {\n      thumbs: {\n        swiper: null,\n        multipleActiveThumbs: !0,\n        autoScrollOffset: 0,\n        slideThumbActiveClass: \"swiper-slide-thumb-active\",\n        thumbsContainerClass: \"swiper-container-thumbs\"\n      }\n    },\n    create: function create() {\n      M(this, {\n        thumbs: t({\n          swiper: null,\n          initialized: !1\n        }, ue)\n      });\n    },\n    on: {\n      beforeInit: function beforeInit(e) {\n        var t = e.params.thumbs;\n        t && t.swiper && (e.thumbs.init(), e.thumbs.update(!0));\n      },\n      slideChange: function slideChange(e) {\n        e.thumbs.swiper && e.thumbs.update();\n      },\n      update: function update(e) {\n        e.thumbs.swiper && e.thumbs.update();\n      },\n      resize: function resize(e) {\n        e.thumbs.swiper && e.thumbs.update();\n      },\n      observerUpdate: function observerUpdate(e) {\n        e.thumbs.swiper && e.thumbs.update();\n      },\n      setTransition: function setTransition(e, t) {\n        var a = e.thumbs.swiper;\n        a && a.setTransition(t);\n      },\n      beforeDestroy: function beforeDestroy(e) {\n        var t = e.thumbs.swiper;\n        t && e.thumbs.swiperCreated && t && t.destroy();\n      }\n    }\n  }];\n  return R.use(ce), R;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc3dpcGVyLm1pbi5qcz9kMWQ3Il0sIm5hbWVzIjpbImUiLCJ0IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImEiLCJsZW5ndGgiLCJpIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsImNvbnN0cnVjdG9yIiwia2V5cyIsImZvckVhY2giLCJzIiwiYm9keSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJub2RlTmFtZSIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImNyZWF0ZUVsZW1lbnQiLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJzdHlsZSIsInNldEF0dHJpYnV0ZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY3JlYXRlRWxlbWVudE5TIiwiaW1wb3J0Tm9kZSIsImxvY2F0aW9uIiwiaGFzaCIsImhvc3QiLCJob3N0bmFtZSIsImhyZWYiLCJvcmlnaW4iLCJwYXRobmFtZSIsInByb3RvY29sIiwic2VhcmNoIiwiciIsImRvY3VtZW50IiwibiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJwdXNoU3RhdGUiLCJnbyIsImJhY2siLCJDdXN0b21FdmVudCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiSW1hZ2UiLCJEYXRlIiwic2NyZWVuIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsIm1hdGNoTWVkaWEiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImwiLCJ3aW5kb3ciLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImQiLCJwIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsInRvU3RyaW5nIiwidSIsInB1c2giLCJGdW5jdGlvbiIsImJpbmQiLCJjIiwiTWFwIiwiaW5kZXhPZiIsIlR5cGVFcnJvciIsImhhcyIsImdldCIsInNldCIsImNyZWF0ZSIsInZhbHVlIiwiaCIsImNvbmNhdCIsIlJlZmVyZW5jZUVycm9yIiwiQXJyYXkiLCJ2IiwiaXNBcnJheSIsImYiLCJmaWx0ZXIiLCJtIiwidHJpbSIsImlubmVySFRNTCIsIm5vZGVUeXBlIiwiZm4iLCJnIiwieSIsInciLCJiIiwiYWRkQ2xhc3MiLCJtYXAiLCJzcGxpdCIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZUNsYXNzIiwicmVtb3ZlIiwiaGFzQ2xhc3MiLCJjb250YWlucyIsInRvZ2dsZUNsYXNzIiwidG9nZ2xlIiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2l0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwib24iLCJ0YXJnZXQiLCJkb203RXZlbnREYXRhIiwidW5zaGlmdCIsImlzIiwicGFyZW50cyIsImRvbTdMaXZlTGlzdGVuZXJzIiwibGlzdGVuZXIiLCJwcm94eUxpc3RlbmVyIiwiZG9tN0xpc3RlbmVycyIsIm9mZiIsImRvbTdwcm94eSIsInNwbGljZSIsInRyaWdnZXIiLCJkZXRhaWwiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJ0cmFuc2l0aW9uRW5kIiwib3V0ZXJXaWR0aCIsInN0eWxlcyIsIm9mZnNldFdpZHRoIiwicGFyc2VGbG9hdCIsIm91dGVySGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsInNjcm9sbFkiLCJzY3JvbGxUb3AiLCJzY3JvbGxYIiwic2Nyb2xsTGVmdCIsInRvcCIsImxlZnQiLCJjc3MiLCJlYWNoIiwiaHRtbCIsInRleHQiLCJ0ZXh0Q29udGVudCIsIm1hdGNoZXMiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwiZXEiLCJhcHBlbmQiLCJmaXJzdENoaWxkIiwiYXBwZW5kQ2hpbGQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwibmV4dCIsIm5leHRFbGVtZW50U2libGluZyIsIm5leHRBbGwiLCJwcmV2IiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInByZXZBbGwiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiY2xvc2VzdCIsImZpbmQiLCJyZW1vdmVDaGlsZCIsIkUiLCJ4Iiwibm93IiwiVCIsIldlYktpdENTU01hdHJpeCIsIndlYmtpdFRyYW5zZm9ybSIsInJlcGxhY2UiLCJqb2luIiwiTW96VHJhbnNmb3JtIiwiT1RyYW5zZm9ybSIsIk1zVHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJtNDEiLCJtNDIiLCJDIiwiUyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIk0iLCJ6IiwidG91Y2giLCJEb2N1bWVudFRvdWNoIiwicG9pbnRlckV2ZW50cyIsIlBvaW50ZXJFdmVudCIsIm1heFRvdWNoUG9pbnRzIiwib2JzZXJ2ZXIiLCJwYXNzaXZlTGlzdGVuZXIiLCJnZXN0dXJlcyIsIlAiLCJwbGF0Zm9ybSIsImlvcyIsImFuZHJvaWQiLCJ3aWR0aCIsImhlaWdodCIsIm1hdGNoIiwib3MiLCJrIiwiaXNFZGdlIiwiaXNTYWZhcmkiLCJ0b0xvd2VyQ2FzZSIsImlzV2ViVmlldyIsInRlc3QiLCJMIiwibmFtZSIsInJlc2l6ZSIsInJlc2l6ZUhhbmRsZXIiLCJkZXN0cm95ZWQiLCJpbml0aWFsaXplZCIsImVtaXQiLCJvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIiLCJpbml0IiwiZGVzdHJveSIsIiQiLCJhdHRhY2giLCJNdXRhdGlvbk9ic2VydmVyIiwiV2Via2l0TXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsIm9ic2VydmVycyIsInN1cHBvcnQiLCJwYXJhbXMiLCJvYnNlcnZlUGFyZW50cyIsIiRlbCIsIm9ic2VydmVTbGlkZUNoaWxkcmVuIiwiJHdyYXBwZXJFbCIsImRpc2Nvbm5lY3QiLCJJIiwiTyIsInRvdWNoRXZlbnRzRGF0YSIsInRvdWNoZXMiLCJhbmltYXRpbmciLCJwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24iLCJvcmlnaW5hbEV2ZW50IiwidG91Y2hFdmVudHNUYXJnZXQiLCJ3cmFwcGVyRWwiLCJpc1RvdWNoRXZlbnQiLCJ0eXBlIiwid2hpY2giLCJidXR0b24iLCJpc1RvdWNoZWQiLCJpc01vdmVkIiwibm9Td2lwaW5nQ2xhc3MiLCJzaGFkb3dSb290IiwicGF0aCIsIm5vU3dpcGluZyIsIm5vU3dpcGluZ1NlbGVjdG9yIiwiYWxsb3dDbGljayIsInN3aXBlSGFuZGxlciIsImN1cnJlbnRYIiwidGFyZ2V0VG91Y2hlcyIsInBhZ2VYIiwiY3VycmVudFkiLCJwYWdlWSIsImVkZ2VTd2lwZURldGVjdGlvbiIsImlPU0VkZ2VTd2lwZURldGVjdGlvbiIsImVkZ2VTd2lwZVRocmVzaG9sZCIsImlPU0VkZ2VTd2lwZVRocmVzaG9sZCIsImlubmVyV2lkdGgiLCJhbGxvd1RvdWNoQ2FsbGJhY2tzIiwiaXNTY3JvbGxpbmciLCJzdGFydE1vdmluZyIsInN0YXJ0WCIsInN0YXJ0WSIsInRvdWNoU3RhcnRUaW1lIiwidXBkYXRlU2l6ZSIsInN3aXBlRGlyZWN0aW9uIiwidGhyZXNob2xkIiwiYWxsb3dUaHJlc2hvbGRNb3ZlIiwiZm9ybUVsZW1lbnRzIiwiYWxsb3dUb3VjaE1vdmUiLCJ0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQiLCJ0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCIsImlzQ29udGVudEVkaXRhYmxlIiwicHJldmVudERlZmF1bHQiLCJBIiwicnRsVHJhbnNsYXRlIiwiY2hhbmdlZFRvdWNoZXMiLCJwcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciIsInRvdWNoUmVsZWFzZU9uRWRnZXMiLCJsb29wIiwiaXNWZXJ0aWNhbCIsInRyYW5zbGF0ZSIsIm1heFRyYW5zbGF0ZSIsIm1pblRyYW5zbGF0ZSIsIk1hdGgiLCJzcXJ0IiwicG93IiwiaXNIb3Jpem9udGFsIiwiYXRhbjIiLCJhYnMiLCJQSSIsInRvdWNoQW5nbGUiLCJjc3NNb2RlIiwidG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uIiwibmVzdGVkIiwic3RvcFByb3BhZ2F0aW9uIiwibG9vcEZpeCIsInN0YXJ0VHJhbnNsYXRlIiwiZ2V0VHJhbnNsYXRlIiwic2V0VHJhbnNpdGlvbiIsImFsbG93TW9tZW50dW1Cb3VuY2UiLCJncmFiQ3Vyc29yIiwiYWxsb3dTbGlkZU5leHQiLCJhbGxvd1NsaWRlUHJldiIsInNldEdyYWJDdXJzb3IiLCJkaWZmIiwidG91Y2hSYXRpbyIsImN1cnJlbnRUcmFuc2xhdGUiLCJyZXNpc3RhbmNlUmF0aW8iLCJyZXNpc3RhbmNlIiwiZm9sbG93RmluZ2VyIiwiZnJlZU1vZGUiLCJ3YXRjaFNsaWRlc1Byb2dyZXNzIiwid2F0Y2hTbGlkZXNWaXNpYmlsaXR5IiwidXBkYXRlQWN0aXZlSW5kZXgiLCJ1cGRhdGVTbGlkZXNDbGFzc2VzIiwidmVsb2NpdGllcyIsInBvc2l0aW9uIiwidGltZSIsInVwZGF0ZVByb2dyZXNzIiwic2V0VHJhbnNsYXRlIiwiRCIsInNsaWRlc0dyaWQiLCJzbmFwR3JpZCIsInVwZGF0ZUNsaWNrZWRTbGlkZSIsImxhc3RDbGlja1RpbWUiLCJzbGlkZVRvIiwiYWN0aXZlSW5kZXgiLCJzbGlkZXMiLCJmcmVlTW9kZU1vbWVudHVtIiwicG9wIiwidmVsb2NpdHkiLCJmcmVlTW9kZU1pbmltdW1WZWxvY2l0eSIsImZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvIiwiZnJlZU1vZGVNb21lbnR1bVJhdGlvIiwiZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvIiwiZnJlZU1vZGVNb21lbnR1bUJvdW5jZSIsImNlbnRlcmVkU2xpZGVzIiwiZnJlZU1vZGVTdGlja3kiLCJvbmNlIiwic2xpZGVzU2l6ZXNHcmlkIiwic3BlZWQiLCJzbGlkZVRvQ2xvc2VzdCIsInRyYW5zaXRpb25TdGFydCIsImxvbmdTd2lwZXNNcyIsInNsaWRlc1Blckdyb3VwU2tpcCIsInNsaWRlc1Blckdyb3VwIiwibG9uZ1N3aXBlcyIsImxvbmdTd2lwZXNSYXRpbyIsInNob3J0U3dpcGVzIiwibmF2aWdhdGlvbiIsIm5leHRFbCIsInByZXZFbCIsIkciLCJlbCIsImJyZWFrcG9pbnRzIiwic2V0QnJlYWtwb2ludCIsInVwZGF0ZVNsaWRlcyIsInNsaWRlc1BlclZpZXciLCJpc0VuZCIsImlzQmVnaW5uaW5nIiwiYXV0b3BsYXkiLCJydW5uaW5nIiwicGF1c2VkIiwicnVuIiwid2F0Y2hPdmVyZmxvdyIsImNoZWNrT3ZlcmZsb3ciLCJOIiwicHJldmVudENsaWNrcyIsInByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIkIiLCJwcmV2aW91c1RyYW5zbGF0ZSIsInNjcm9sbFdpZHRoIiwicHJvZ3Jlc3MiLCJIIiwiWCIsIlkiLCJkaXJlY3Rpb24iLCJpbml0aWFsU2xpZGUiLCJ1cGRhdGVPbldpbmRvd1Jlc2l6ZSIsInVybCIsImF1dG9IZWlnaHQiLCJzZXRXcmFwcGVyU2l6ZSIsInZpcnR1YWxUcmFuc2xhdGUiLCJlZmZlY3QiLCJzcGFjZUJldHdlZW4iLCJzbGlkZXNQZXJDb2x1bW4iLCJzbGlkZXNQZXJDb2x1bW5GaWxsIiwiY2VudGVyZWRTbGlkZXNCb3VuZHMiLCJzbGlkZXNPZmZzZXRCZWZvcmUiLCJzbGlkZXNPZmZzZXRBZnRlciIsIm5vcm1hbGl6ZVNsaWRlSW5kZXgiLCJjZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMiLCJyb3VuZExlbmd0aHMiLCJzaW11bGF0ZVRvdWNoIiwidW5pcXVlTmF2RWxlbWVudHMiLCJzbGlkZVRvQ2xpY2tlZFNsaWRlIiwicHJlbG9hZEltYWdlcyIsInVwZGF0ZU9uSW1hZ2VzUmVhZHkiLCJsb29wQWRkaXRpb25hbFNsaWRlcyIsImxvb3BlZFNsaWRlcyIsImxvb3BGaWxsR3JvdXBXaXRoQmxhbmsiLCJsb29wUHJldmVudHNTbGlkZSIsInBhc3NpdmVMaXN0ZW5lcnMiLCJjb250YWluZXJNb2RpZmllckNsYXNzIiwic2xpZGVDbGFzcyIsInNsaWRlQmxhbmtDbGFzcyIsInNsaWRlQWN0aXZlQ2xhc3MiLCJzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzIiwic2xpZGVWaXNpYmxlQ2xhc3MiLCJzbGlkZUR1cGxpY2F0ZUNsYXNzIiwic2xpZGVOZXh0Q2xhc3MiLCJzbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyIsInNsaWRlUHJldkNsYXNzIiwic2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MiLCJ3cmFwcGVyQ2xhc3MiLCJydW5DYWxsYmFja3NPbkluaXQiLCJfZW1pdENsYXNzZXMiLCJWIiwibW9kdWxhciIsInVzZVBhcmFtcyIsIm1vZHVsZXMiLCJ1c2VNb2R1bGVzIiwiZXZlbnRzRW1pdHRlciIsImV2ZW50c0xpc3RlbmVycyIsIl9fZW1pdHRlclByb3h5Iiwib25BbnkiLCJldmVudHNBbnlMaXN0ZW5lcnMiLCJvZmZBbnkiLCJzbGljZSIsImV2ZW50cyIsImRhdGEiLCJjb250ZXh0IiwidXBkYXRlIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwic2l6ZSIsIndyb25nUlRMIiwidmlydHVhbCIsImVuYWJsZWQiLCJ2aXJ0dWFsU2l6ZSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsImZsb29yIiwiY2VpbCIsIm1heCIsIm1pbiIsIm9yZGVyIiwiRiIsIlIiLCJXIiwicSIsImoiLCJfIiwiVSIsIksiLCJaIiwiSiIsIlEiLCJlZSIsInRlIiwiYWUiLCJpZSIsInN3aXBlclNsaWRlU2l6ZSIsInNlIiwicmUiLCJuZSIsImxlIiwib2UiLCJkZSIsInBlIiwidWUiLCJ1cGRhdGVTbGlkZXNPZmZzZXQiLCJ1cGRhdGVBdXRvSGVpZ2h0IiwidmlzaWJsZVNsaWRlcyIsInN3aXBlclNsaWRlT2Zmc2V0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsInVwZGF0ZVNsaWRlc1Byb2dyZXNzIiwidmlzaWJsZVNsaWRlc0luZGV4ZXMiLCJyZWFsSW5kZXgiLCJlbWl0U2xpZGVzQ2xhc3NlcyIsInNuYXBJbmRleCIsInByZXZpb3VzSW5kZXgiLCJjbGlja2VkU2xpZGUiLCJjbGlja2VkSW5kZXgiLCJ0cmFuc2xhdGVUbyIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJvblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQiLCJzbGlkZSIsIkVycm9yIiwiaXNGaW5pdGUiLCJvblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCIsInNsaWRlVG9Mb29wIiwic2xpZGVOZXh0IiwiX2NsaWVudExlZnQiLCJzbGlkZVByZXYiLCJzbGlkZVJlc2V0Iiwic2xpZGVzUGVyVmlld0R5bmFtaWMiLCJsb29wQ3JlYXRlIiwiY2xvbmVOb2RlIiwibG9vcERlc3Ryb3kiLCJpc0xvY2tlZCIsImN1cnNvciIsInVuc2V0R3JhYkN1cnNvciIsIm1hbmlwdWxhdGlvbiIsImFwcGVuZFNsaWRlIiwicHJlcGVuZFNsaWRlIiwiYWRkU2xpZGUiLCJyZW1vdmVTbGlkZSIsInJlbW92ZUFsbFNsaWRlcyIsImF0dGFjaEV2ZW50cyIsInRvdWNoRXZlbnRzIiwiZGV2aWNlIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25TY3JvbGwiLCJvbkNsaWNrIiwic3RhcnQiLCJtb3ZlIiwiZW5kIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJjYW5jZWwiLCJkZXRhY2hFdmVudHMiLCJnZXRCcmVha3BvaW50IiwiY3VycmVudEJyZWFrcG9pbnQiLCJvcmlnaW5hbFBhcmFtcyIsImVtaXRDb250YWluZXJDbGFzc2VzIiwiY2hhbmdlRGlyZWN0aW9uIiwic3Vic3RyIiwiaW5uZXJIZWlnaHQiLCJwb2ludCIsInNvcnQiLCJjbGFzc2VzIiwiYWRkQ2xhc3NlcyIsImNsYXNzTmFtZXMiLCJydGwiLCJyZW1vdmVDbGFzc2VzIiwiaW1hZ2VzIiwibG9hZEltYWdlIiwiY29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwic2l6ZXMiLCJzcmNzZXQiLCJzcmMiLCJpbWFnZXNMb2FkZWQiLCJpbWFnZXNUb0xvYWQiLCJjdXJyZW50U3JjIiwiYnJvd3NlciIsInBhc3NlZFBhcmFtcyIsInN3aXBlciIsImRpciIsInRvdWNoRXZlbnRzVG91Y2giLCJ0b3VjaEV2ZW50c0Rlc2t0b3AiLCJjbGlja1RpbWVvdXQiLCJjbGFzc05hbWUiLCJnZXRTbGlkZUNsYXNzZXMiLCJleHRlbmREZWZhdWx0cyIsImluc3RhbGxNb2R1bGUiLCJ1c2UiLCJhZGRTbGlkZXNCZWZvcmUiLCJhZGRTbGlkZXNBZnRlciIsImZyb20iLCJ0byIsInJlbmRlclNsaWRlIiwibGF6eSIsImxvYWQiLCJyZW5kZXJFeHRlcm5hbCIsInJlbmRlckV4dGVybmFsVXBkYXRlIiwiY2FjaGUiLCJiZWZvcmVJbml0IiwiaGFuZGxlIiwia2V5Q29kZSIsImNoYXJDb2RlIiwia2V5Ym9hcmQiLCJwYWdlVXBEb3duIiwic2hpZnRLZXkiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsIm9ubHlJblZpZXdwb3J0IiwicmV0dXJuVmFsdWUiLCJlbmFibGUiLCJkaXNhYmxlIiwibGFzdFNjcm9sbFRpbWUiLCJsYXN0RXZlbnRCZWZvcmVTbmFwIiwicmVjZW50V2hlZWxFdmVudHMiLCJldmVudCIsIm9ud2hlZWwiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJub3JtYWxpemUiLCJ3aGVlbERlbHRhIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhWCIsImF4aXMiLCJIT1JJWk9OVEFMX0FYSVMiLCJkZWx0YVkiLCJkZWx0YVgiLCJkZWx0YU1vZGUiLCJzcGluWCIsInNwaW5ZIiwicGl4ZWxYIiwicGl4ZWxZIiwiaGFuZGxlTW91c2VFbnRlciIsIm1vdXNlRW50ZXJlZCIsImhhbmRsZU1vdXNlTGVhdmUiLCJtb3VzZXdoZWVsIiwiZXZlbnRzVGFyZ2V0IiwicmVsZWFzZU9uRWRnZXMiLCJmb3JjZVRvQXhpcyIsImludmVydCIsInNlbnNpdGl2aXR5IiwiZGVsdGEiLCJzaWduIiwidGltZW91dCIsInNoaWZ0IiwiYXV0b3BsYXlEaXNhYmxlT25JbnRlcmFjdGlvbiIsInN0b3AiLCJyYXciLCJhbmltYXRlU2xpZGVyIiwicmVsZWFzZVNjcm9sbCIsInRocmVzaG9sZERlbHRhIiwidGhyZXNob2xkVGltZSIsImdldFRpbWUiLCIkbmV4dEVsIiwiJHByZXZFbCIsImRpc2FibGVkQ2xhc3MiLCJsb2NrQ2xhc3MiLCJvblByZXZDbGljayIsIm9uTmV4dENsaWNrIiwicGFnaW5hdGlvbiIsInBhZ2luYXRpb25UeXBlIiwiYnVsbGV0cyIsImR5bmFtaWNCdWxsZXRzIiwiYnVsbGV0U2l6ZSIsImR5bmFtaWNNYWluQnVsbGV0cyIsImR5bmFtaWNCdWxsZXRJbmRleCIsImJ1bGxldEFjdGl2ZUNsYXNzIiwiY3VycmVudENsYXNzIiwiZm9ybWF0RnJhY3Rpb25DdXJyZW50IiwidG90YWxDbGFzcyIsImZvcm1hdEZyYWN0aW9uVG90YWwiLCJwcm9ncmVzc2Jhck9wcG9zaXRlIiwicHJvZ3Jlc3NiYXJGaWxsQ2xhc3MiLCJyZW5kZXJDdXN0b20iLCJyZW5kZXIiLCJyZW5kZXJCdWxsZXQiLCJidWxsZXRDbGFzcyIsImJ1bGxldEVsZW1lbnQiLCJyZW5kZXJGcmFjdGlvbiIsInJlbmRlclByb2dyZXNzYmFyIiwiY2xpY2thYmxlIiwiY2xpY2thYmxlQ2xhc3MiLCJtb2RpZmllckNsYXNzIiwicHJvZ3Jlc3NiYXJPcHBvc2l0ZUNsYXNzIiwiaGlkZGVuQ2xhc3MiLCJzY3JvbGxiYXIiLCJkcmFnU2l6ZSIsInRyYWNrU2l6ZSIsIiRkcmFnRWwiLCJoaWRlIiwib3BhY2l0eSIsImRpc3BsYXkiLCJkaXZpZGVyIiwibW92ZURpdmlkZXIiLCJnZXRQb2ludGVyUG9zaXRpb24iLCJjbGllbnRYIiwiY2xpZW50WSIsInNldERyYWdQb3NpdGlvbiIsImRyYWdTdGFydFBvcyIsIm9uRHJhZ1N0YXJ0IiwiZHJhZ1RpbWVvdXQiLCJvbkRyYWdNb3ZlIiwib25EcmFnRW5kIiwic25hcE9uUmVsZWFzZSIsImVuYWJsZURyYWdnYWJsZSIsImRpc2FibGVEcmFnZ2FibGUiLCJkcmFnQ2xhc3MiLCJkcmFnRWwiLCJkcmFnZ2FibGUiLCJzZXRUcmFuc2Zvcm0iLCJwYXJhbGxheCIsImdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMiLCJvbkdlc3R1cmVTdGFydCIsInpvb20iLCJnZXN0dXJlIiwiZmFrZUdlc3R1cmVUb3VjaGVkIiwiZmFrZUdlc3R1cmVNb3ZlZCIsInNjYWxlU3RhcnQiLCIkc2xpZGVFbCIsIiRpbWFnZUVsIiwiJGltYWdlV3JhcEVsIiwiY29udGFpbmVyQ2xhc3MiLCJtYXhSYXRpbyIsImlzU2NhbGluZyIsIm9uR2VzdHVyZUNoYW5nZSIsInNjYWxlTW92ZSIsInNjYWxlIiwiY3VycmVudFNjYWxlIiwibWluUmF0aW8iLCJvbkdlc3R1cmVFbmQiLCJpbWFnZSIsInRvdWNoZXNTdGFydCIsInNsaWRlV2lkdGgiLCJzbGlkZUhlaWdodCIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJ0b3VjaGVzQ3VycmVudCIsInByZXZQb3NpdGlvblgiLCJwcmV2UG9zaXRpb25ZIiwicHJldlRpbWUiLCJvblRyYW5zaXRpb25FbmQiLCJvdXQiLCJ6b29tZWRTbGlkZUNsYXNzIiwidG9nZ2xlR2VzdHVyZXMiLCJzbGlkZVNlbGVjdG9yIiwiZW5hYmxlR2VzdHVyZXMiLCJnZXN0dXJlc0VuYWJsZWQiLCJkaXNhYmxlR2VzdHVyZXMiLCJsb2FkSW5TbGlkZSIsImVsZW1lbnRDbGFzcyIsImxvYWRlZENsYXNzIiwibG9hZGluZ0NsYXNzIiwicHJlbG9hZGVyQ2xhc3MiLCJpbml0aWFsSW1hZ2VMb2FkZWQiLCJsb2FkUHJldk5leHQiLCJsb2FkUHJldk5leHRBbW91bnQiLCJjaGVja0luVmlld09uTG9hZCIsInNjcm9sbGluZ0VsZW1lbnQiLCJzY3JvbGxIYW5kbGVyQXR0YWNoZWQiLCJMaW5lYXJTcGxpbmUiLCJsYXN0SW5kZXgiLCJpbnRlcnBvbGF0ZSIsImdldEludGVycG9sYXRlRnVuY3Rpb24iLCJjb250cm9sbGVyIiwic3BsaW5lIiwiY29udHJvbCIsImJ5IiwiaW52ZXJzZSIsImdldFJhbmRvbU51bWJlciIsInJlcGVhdCIsInJvdW5kIiwicmFuZG9tIiwibWFrZUVsRm9jdXNhYmxlIiwibWFrZUVsTm90Rm9jdXNhYmxlIiwiYWRkRWxSb2xlIiwiYWRkRWxSb2xlRGVzY3JpcHRpb24iLCJhZGRFbENvbnRyb2xzIiwiYWRkRWxMYWJlbCIsImFkZEVsSWQiLCJhZGRFbExpdmUiLCJkaXNhYmxlRWwiLCJlbmFibGVFbCIsIm9uRW50ZXJLZXkiLCJhMTF5Iiwibm90aWZ5IiwibGFzdFNsaWRlTWVzc2FnZSIsIm5leHRTbGlkZU1lc3NhZ2UiLCJmaXJzdFNsaWRlTWVzc2FnZSIsInByZXZTbGlkZU1lc3NhZ2UiLCJjbGljayIsImxpdmVSZWdpb24iLCJ1cGRhdGVOYXZpZ2F0aW9uIiwidXBkYXRlUGFnaW5hdGlvbiIsInBhZ2luYXRpb25CdWxsZXRNZXNzYWdlIiwiY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSIsImNvbnRhaW5lck1lc3NhZ2UiLCJpdGVtUm9sZURlc2NyaXB0aW9uTWVzc2FnZSIsInRhZ05hbWUiLCJoYXNoTmF2aWdhdGlvbiIsInBhdGhzIiwiZ2V0UGF0aFZhbHVlcyIsInNjcm9sbFRvU2xpZGUiLCJzZXRIaXN0b3J5UG9wU3RhdGUiLCJVUkwiLCJzZXRIaXN0b3J5Iiwic2x1Z2lmeSIsImluY2x1ZGVzIiwic3RhdGUiLCJvbkhhc2hDYW5nZSIsInNldEhhc2giLCJ3YXRjaFN0YXRlIiwiZGVsYXkiLCJyZXZlcnNlRGlyZWN0aW9uIiwic3RvcE9uTGFzdFNsaWRlIiwicGF1c2UiLCJ3YWl0Rm9yVHJhbnNpdGlvbiIsIm9uVmlzaWJpbGl0eUNoYW5nZSIsInZpc2liaWxpdHlTdGF0ZSIsImZhZGVFZmZlY3QiLCJjcm9zc0ZhZGUiLCJjdWJlRWZmZWN0Iiwic2hhZG93Iiwic2xpZGVTaGFkb3dzIiwic2hhZG93T2Zmc2V0Iiwic2hhZG93U2NhbGUiLCJzaW4iLCJjb3MiLCJmbGlwRWZmZWN0IiwibGltaXRSb3RhdGlvbiIsInpJbmRleCIsImNvdmVyZmxvd0VmZmVjdCIsInJvdGF0ZSIsImRlcHRoIiwibW9kaWZpZXIiLCJzdHJldGNoIiwidGh1bWJzIiwic3dpcGVyQ3JlYXRlZCIsInRodW1ic0NvbnRhaW5lckNsYXNzIiwib25UaHVtYkNsaWNrIiwic2xpZGVUaHVtYkFjdGl2ZUNsYXNzIiwiYXV0b1Njcm9sbE9mZnNldCIsIm11bHRpcGxlQWN0aXZlVGh1bWJzIiwiY2UiLCJoaWRlT25DbGljayIsInRvRWRnZSIsImZyb21FZGdlIiwiYWN0aXZlSW5kZXhDaGFuZ2UiLCJzbmFwSW5kZXhDaGFuZ2UiLCJzbGlkZXNMZW5ndGhDaGFuZ2UiLCJzbmFwR3JpZExlbmd0aENoYW5nZSIsIm9ic2VydmVyVXBkYXRlIiwidG91Y2hTdGFydCIsInRvdWNoRW5kIiwiZG91YmxlVGFwIiwic2xpZGVDaGFuZ2UiLCJjaGVja0luVmlldyIsImxvYWRPblRyYW5zaXRpb25TdGFydCIsInNjcm9sbCIsInNjcm9sbGJhckRyYWdNb3ZlIiwibm90aWZpY2F0aW9uQ2xhc3MiLCJhZnRlckluaXQiLCJwYWdpbmF0aW9uVXBkYXRlIiwiZGlzYWJsZU9uSW50ZXJhY3Rpb24iLCJiZWZvcmVUcmFuc2l0aW9uU3RhcnQiLCJzbGlkZXJGaXJzdE1vdmUiLCJiZWZvcmVEZXN0cm95Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QixTQUFDLElBQUVBLENBQUMsQ0FBQzJVLGFBQUYsQ0FBZ0IvVSxDQUFoQixDQUFIO0FBQXNCLE9BQW5aO0FBQW9acTNCLG1CQUFhLEVBQUMsdUJBQVN0M0IsQ0FBVCxFQUFXO0FBQUMsWUFBSUMsQ0FBQyxHQUFDRCxDQUFDLENBQUN3MUIsTUFBRixDQUFTblEsTUFBZjtBQUFzQnBsQixTQUFDLElBQUVELENBQUMsQ0FBQ3cxQixNQUFGLENBQVNDLGFBQVosSUFBMkJ4MUIsQ0FBM0IsSUFBOEJBLENBQUMsQ0FBQ3FQLE9BQUYsRUFBOUI7QUFBMEM7QUFBOWU7QUFBblEsR0FBeGlaLENBQXJnbEQ7QUFBa3kvRCxTQUFPc1AsQ0FBQyxDQUFDa0gsR0FBRixDQUFNaVEsRUFBTixHQUFVblgsQ0FBakI7QUFBbUIsQ0FBL3Z3SSxDQUFEIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL3N3aXBlci5taW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU3dpcGVyIDYuNC41XHJcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXHJcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE0LTIwMjAgVmxhZGltaXIgS2hhcmxhbXBpZGlcclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXHJcbiAqXHJcbiAqIFJlbGVhc2VkIG9uOiBEZWNlbWJlciAxOCwgMjAyMFxyXG4gKi9cclxuXHJcbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKHQpOihlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6ZXx8c2VsZikuU3dpcGVyPXQoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBpPXRbYV07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX1mdW5jdGlvbiB0KCl7cmV0dXJuKHQ9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIGE9YXJndW1lbnRzW3RdO2Zvcih2YXIgaSBpbiBhKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGkpJiYoZVtpXT1hW2ldKX1yZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBhKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiY29uc3RydWN0b3JcImluIGUmJmUuY29uc3RydWN0b3I9PT1PYmplY3R9ZnVuY3Rpb24gaShlLHQpe3ZvaWQgMD09PWUmJihlPXt9KSx2b2lkIDA9PT10JiYodD17fSksT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24ocyl7dm9pZCAwPT09ZVtzXT9lW3NdPXRbc106YSh0W3NdKSYmYShlW3NdKSYmT2JqZWN0LmtleXModFtzXSkubGVuZ3RoPjAmJmkoZVtzXSx0W3NdKX0pKX12YXIgcz17Ym9keTp7fSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKCl7fSxyZW1vdmVFdmVudExpc3RlbmVyOmZ1bmN0aW9uKCl7fSxhY3RpdmVFbGVtZW50OntibHVyOmZ1bmN0aW9uKCl7fSxub2RlTmFtZTpcIlwifSxxdWVyeVNlbGVjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LHF1ZXJ5U2VsZWN0b3JBbGw6ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0RWxlbWVudEJ5SWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sY3JlYXRlRXZlbnQ6ZnVuY3Rpb24oKXtyZXR1cm57aW5pdEV2ZW50OmZ1bmN0aW9uKCl7fX19LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm57Y2hpbGRyZW46W10sY2hpbGROb2RlczpbXSxzdHlsZTp7fSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LGdldEVsZW1lbnRzQnlUYWdOYW1lOmZ1bmN0aW9uKCl7cmV0dXJuW119fX0sY3JlYXRlRWxlbWVudE5TOmZ1bmN0aW9uKCl7cmV0dXJue319LGltcG9ydE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbG9jYXRpb246e2hhc2g6XCJcIixob3N0OlwiXCIsaG9zdG5hbWU6XCJcIixocmVmOlwiXCIsb3JpZ2luOlwiXCIscGF0aG5hbWU6XCJcIixwcm90b2NvbDpcIlwiLHNlYXJjaDpcIlwifX07ZnVuY3Rpb24gcigpe3ZhciBlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudD9kb2N1bWVudDp7fTtyZXR1cm4gaShlLHMpLGV9dmFyIG49e2RvY3VtZW50OnMsbmF2aWdhdG9yOnt1c2VyQWdlbnQ6XCJcIn0sbG9jYXRpb246e2hhc2g6XCJcIixob3N0OlwiXCIsaG9zdG5hbWU6XCJcIixocmVmOlwiXCIsb3JpZ2luOlwiXCIscGF0aG5hbWU6XCJcIixwcm90b2NvbDpcIlwiLHNlYXJjaDpcIlwifSxoaXN0b3J5OntyZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LHB1c2hTdGF0ZTpmdW5jdGlvbigpe30sZ286ZnVuY3Rpb24oKXt9LGJhY2s6ZnVuY3Rpb24oKXt9fSxDdXN0b21FdmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzfSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKCl7fSxyZW1vdmVFdmVudExpc3RlbmVyOmZ1bmN0aW9uKCl7fSxnZXRDb21wdXRlZFN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJue2dldFByb3BlcnR5VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cIlwifX19LEltYWdlOmZ1bmN0aW9uKCl7fSxEYXRlOmZ1bmN0aW9uKCl7fSxzY3JlZW46e30sc2V0VGltZW91dDpmdW5jdGlvbigpe30sY2xlYXJUaW1lb3V0OmZ1bmN0aW9uKCl7fSxtYXRjaE1lZGlhOmZ1bmN0aW9uKCl7cmV0dXJue319LHJlcXVlc3RBbmltYXRpb25GcmFtZTpmdW5jdGlvbihlKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2V0VGltZW91dD8oZSgpLG51bGwpOnNldFRpbWVvdXQoZSwwKX0sY2FuY2VsQW5pbWF0aW9uRnJhbWU6ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNldFRpbWVvdXQmJmNsZWFyVGltZW91dChlKX19O2Z1bmN0aW9uIGwoKXt2YXIgZT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fTtyZXR1cm4gaShlLG4pLGV9ZnVuY3Rpb24gbyhlKXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gZChlLHQpe3JldHVybihkPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX1mdW5jdGlvbiBwKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fWZ1bmN0aW9uIHUoZSx0LGEpe3JldHVybih1PXAoKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5jdGlvbihlLHQsYSl7dmFyIGk9W251bGxdO2kucHVzaC5hcHBseShpLHQpO3ZhciBzPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KGUsaSkpO3JldHVybiBhJiZkKHMsYS5wcm90b3R5cGUpLHN9KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYyhlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuKGM9ZnVuY3Rpb24oZSl7aWYobnVsbD09PWV8fChhPWUsLTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKGEpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKSlyZXR1cm4gZTt2YXIgYTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT10KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxpKX1mdW5jdGlvbiBpKCl7cmV0dXJuIHUoZSxhcmd1bWVudHMsbyh0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTppLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGQoaSxlKX0pKGUpfXZhciBoPWZ1bmN0aW9uKGUpe3ZhciB0LGE7ZnVuY3Rpb24gaSh0KXt2YXIgYSxpLHM7cmV0dXJuIGE9ZS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdCh0KSl8fHRoaXMsaT1mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gZX0oYSkscz1pLl9fcHJvdG9fXyxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxcIl9fcHJvdG9fX1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gc30sc2V0OmZ1bmN0aW9uKGUpe3MuX19wcm90b19fPWV9fSksYX1yZXR1cm4gYT1lLCh0PWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGEucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LHQuX19wcm90b19fPWEsaX0oYyhBcnJheSkpO2Z1bmN0aW9uIHYoZSl7dm9pZCAwPT09ZSYmKGU9W10pO3ZhciB0PVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe0FycmF5LmlzQXJyYXkoZSk/dC5wdXNoLmFwcGx5KHQsdihlKSk6dC5wdXNoKGUpfSkpLHR9ZnVuY3Rpb24gZihlLHQpe3JldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZSx0KX1mdW5jdGlvbiBtKGUsdCl7dmFyIGE9bCgpLGk9cigpLHM9W107aWYoIXQmJmUgaW5zdGFuY2VvZiBoKXJldHVybiBlO2lmKCFlKXJldHVybiBuZXcgaChzKTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIG49ZS50cmltKCk7aWYobi5pbmRleE9mKFwiPFwiKT49MCYmbi5pbmRleE9mKFwiPlwiKT49MCl7dmFyIG89XCJkaXZcIjswPT09bi5pbmRleE9mKFwiPGxpXCIpJiYobz1cInVsXCIpLDA9PT1uLmluZGV4T2YoXCI8dHJcIikmJihvPVwidGJvZHlcIiksMCE9PW4uaW5kZXhPZihcIjx0ZFwiKSYmMCE9PW4uaW5kZXhPZihcIjx0aFwiKXx8KG89XCJ0clwiKSwwPT09bi5pbmRleE9mKFwiPHRib2R5XCIpJiYobz1cInRhYmxlXCIpLDA9PT1uLmluZGV4T2YoXCI8b3B0aW9uXCIpJiYobz1cInNlbGVjdFwiKTt2YXIgZD1pLmNyZWF0ZUVsZW1lbnQobyk7ZC5pbm5lckhUTUw9bjtmb3IodmFyIHA9MDtwPGQuY2hpbGROb2Rlcy5sZW5ndGg7cCs9MSlzLnB1c2goZC5jaGlsZE5vZGVzW3BdKX1lbHNlIHM9ZnVuY3Rpb24oZSx0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm5bZV07Zm9yKHZhciBhPVtdLGk9dC5xdWVyeVNlbGVjdG9yQWxsKGUpLHM9MDtzPGkubGVuZ3RoO3MrPTEpYS5wdXNoKGlbc10pO3JldHVybiBhfShlLnRyaW0oKSx0fHxpKX1lbHNlIGlmKGUubm9kZVR5cGV8fGU9PT1hfHxlPT09aSlzLnB1c2goZSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXtpZihlIGluc3RhbmNlb2YgaClyZXR1cm4gZTtzPWV9cmV0dXJuIG5ldyBoKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxhPTA7YTxlLmxlbmd0aDthKz0xKS0xPT09dC5pbmRleE9mKGVbYV0pJiZ0LnB1c2goZVthXSk7cmV0dXJuIHR9KHMpKX1tLmZuPWgucHJvdG90eXBlO3ZhciBnLHksdyxiPXthZGRDbGFzczpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLGE9MDthPGU7YSsrKXRbYV09YXJndW1lbnRzW2FdO3ZhciBpPXYodC5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwbGl0KFwiIFwiKX0pKSk7cmV0dXJuIHRoaXMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ7KHQ9ZS5jbGFzc0xpc3QpLmFkZC5hcHBseSh0LGkpfSkpLHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSksYT0wO2E8ZTthKyspdFthXT1hcmd1bWVudHNbYV07dmFyIGk9dih0Lm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCIgXCIpfSkpKTtyZXR1cm4gdGhpcy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdDsodD1lLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KHQsaSl9KSksdGhpc30saGFzQ2xhc3M6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxhPTA7YTxlO2ErKyl0W2FdPWFyZ3VtZW50c1thXTt2YXIgaT12KHQubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChcIiBcIil9KSkpO3JldHVybiBmKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIGUuY2xhc3NMaXN0LmNvbnRhaW5zKHQpfSkpLmxlbmd0aD4wfSkpLmxlbmd0aD4wfSx0b2dnbGVDbGFzczpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLGE9MDthPGU7YSsrKXRbYV09YXJndW1lbnRzW2FdO3ZhciBpPXYodC5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwbGl0KFwiIFwiKX0pKSk7dGhpcy5mb3JFYWNoKChmdW5jdGlvbihlKXtpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UuY2xhc3NMaXN0LnRvZ2dsZSh0KX0pKX0pKX0sYXR0cjpmdW5jdGlvbihlLHQpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gdGhpc1swXT90aGlzWzBdLmdldEF0dHJpYnV0ZShlKTp2b2lkIDA7Zm9yKHZhciBhPTA7YTx0aGlzLmxlbmd0aDthKz0xKWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXNbYV0uc2V0QXR0cmlidXRlKGUsdCk7ZWxzZSBmb3IodmFyIGkgaW4gZSl0aGlzW2FdW2ldPWVbaV0sdGhpc1thXS5zZXRBdHRyaWJ1dGUoaSxlW2ldKTtyZXR1cm4gdGhpc30scmVtb3ZlQXR0cjpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PHRoaXMubGVuZ3RoO3QrPTEpdGhpc1t0XS5yZW1vdmVBdHRyaWJ1dGUoZSk7cmV0dXJuIHRoaXN9LHRyYW5zZm9ybTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PHRoaXMubGVuZ3RoO3QrPTEpdGhpc1t0XS5zdHlsZS50cmFuc2Zvcm09ZTtyZXR1cm4gdGhpc30sdHJhbnNpdGlvbjpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PHRoaXMubGVuZ3RoO3QrPTEpdGhpc1t0XS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb249XCJzdHJpbmdcIiE9dHlwZW9mIGU/ZStcIm1zXCI6ZTtyZXR1cm4gdGhpc30sb246ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxhPTA7YTxlO2ErKyl0W2FdPWFyZ3VtZW50c1thXTt2YXIgaT10WzBdLHM9dFsxXSxyPXRbMl0sbj10WzNdO2Z1bmN0aW9uIGwoZSl7dmFyIHQ9ZS50YXJnZXQ7aWYodCl7dmFyIGE9ZS50YXJnZXQuZG9tN0V2ZW50RGF0YXx8W107aWYoYS5pbmRleE9mKGUpPDAmJmEudW5zaGlmdChlKSxtKHQpLmlzKHMpKXIuYXBwbHkodCxhKTtlbHNlIGZvcih2YXIgaT1tKHQpLnBhcmVudHMoKSxuPTA7bjxpLmxlbmd0aDtuKz0xKW0oaVtuXSkuaXMocykmJnIuYXBwbHkoaVtuXSxhKX19ZnVuY3Rpb24gbyhlKXt2YXIgdD1lJiZlLnRhcmdldCYmZS50YXJnZXQuZG9tN0V2ZW50RGF0YXx8W107dC5pbmRleE9mKGUpPDAmJnQudW5zaGlmdChlKSxyLmFwcGx5KHRoaXMsdCl9XCJmdW5jdGlvblwiPT10eXBlb2YgdFsxXSYmKGk9dFswXSxyPXRbMV0sbj10WzJdLHM9dm9pZCAwKSxufHwobj0hMSk7Zm9yKHZhciBkLHA9aS5zcGxpdChcIiBcIiksdT0wO3U8dGhpcy5sZW5ndGg7dSs9MSl7dmFyIGM9dGhpc1t1XTtpZihzKWZvcihkPTA7ZDxwLmxlbmd0aDtkKz0xKXt2YXIgaD1wW2RdO2MuZG9tN0xpdmVMaXN0ZW5lcnN8fChjLmRvbTdMaXZlTGlzdGVuZXJzPXt9KSxjLmRvbTdMaXZlTGlzdGVuZXJzW2hdfHwoYy5kb203TGl2ZUxpc3RlbmVyc1toXT1bXSksYy5kb203TGl2ZUxpc3RlbmVyc1toXS5wdXNoKHtsaXN0ZW5lcjpyLHByb3h5TGlzdGVuZXI6bH0pLGMuYWRkRXZlbnRMaXN0ZW5lcihoLGwsbil9ZWxzZSBmb3IoZD0wO2Q8cC5sZW5ndGg7ZCs9MSl7dmFyIHY9cFtkXTtjLmRvbTdMaXN0ZW5lcnN8fChjLmRvbTdMaXN0ZW5lcnM9e30pLGMuZG9tN0xpc3RlbmVyc1t2XXx8KGMuZG9tN0xpc3RlbmVyc1t2XT1bXSksYy5kb203TGlzdGVuZXJzW3ZdLnB1c2goe2xpc3RlbmVyOnIscHJveHlMaXN0ZW5lcjpvfSksYy5hZGRFdmVudExpc3RlbmVyKHYsbyxuKX19cmV0dXJuIHRoaXN9LG9mZjpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLGE9MDthPGU7YSsrKXRbYV09YXJndW1lbnRzW2FdO3ZhciBpPXRbMF0scz10WzFdLHI9dFsyXSxuPXRbM107XCJmdW5jdGlvblwiPT10eXBlb2YgdFsxXSYmKGk9dFswXSxyPXRbMV0sbj10WzJdLHM9dm9pZCAwKSxufHwobj0hMSk7Zm9yKHZhciBsPWkuc3BsaXQoXCIgXCIpLG89MDtvPGwubGVuZ3RoO28rPTEpZm9yKHZhciBkPWxbb10scD0wO3A8dGhpcy5sZW5ndGg7cCs9MSl7dmFyIHU9dGhpc1twXSxjPXZvaWQgMDtpZighcyYmdS5kb203TGlzdGVuZXJzP2M9dS5kb203TGlzdGVuZXJzW2RdOnMmJnUuZG9tN0xpdmVMaXN0ZW5lcnMmJihjPXUuZG9tN0xpdmVMaXN0ZW5lcnNbZF0pLGMmJmMubGVuZ3RoKWZvcih2YXIgaD1jLmxlbmd0aC0xO2g+PTA7aC09MSl7dmFyIHY9Y1toXTtyJiZ2Lmxpc3RlbmVyPT09cnx8ciYmdi5saXN0ZW5lciYmdi5saXN0ZW5lci5kb203cHJveHkmJnYubGlzdGVuZXIuZG9tN3Byb3h5PT09cj8odS5yZW1vdmVFdmVudExpc3RlbmVyKGQsdi5wcm94eUxpc3RlbmVyLG4pLGMuc3BsaWNlKGgsMSkpOnJ8fCh1LnJlbW92ZUV2ZW50TGlzdGVuZXIoZCx2LnByb3h5TGlzdGVuZXIsbiksYy5zcGxpY2UoaCwxKSl9fXJldHVybiB0aGlzfSx0cmlnZ2VyOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWwoKSx0PWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspYVtpXT1hcmd1bWVudHNbaV07Zm9yKHZhciBzPWFbMF0uc3BsaXQoXCIgXCIpLHI9YVsxXSxuPTA7bjxzLmxlbmd0aDtuKz0xKWZvcih2YXIgbz1zW25dLGQ9MDtkPHRoaXMubGVuZ3RoO2QrPTEpe3ZhciBwPXRoaXNbZF07aWYoZS5DdXN0b21FdmVudCl7dmFyIHU9bmV3IGUuQ3VzdG9tRXZlbnQobyx7ZGV0YWlsOnIsYnViYmxlczohMCxjYW5jZWxhYmxlOiEwfSk7cC5kb203RXZlbnREYXRhPWEuZmlsdGVyKChmdW5jdGlvbihlLHQpe3JldHVybiB0PjB9KSkscC5kaXNwYXRjaEV2ZW50KHUpLHAuZG9tN0V2ZW50RGF0YT1bXSxkZWxldGUgcC5kb203RXZlbnREYXRhfX1yZXR1cm4gdGhpc30sdHJhbnNpdGlvbkVuZDpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlJiZ0Lm9uKFwidHJhbnNpdGlvbmVuZFwiLChmdW5jdGlvbiBhKGkpe2kudGFyZ2V0PT09dGhpcyYmKGUuY2FsbCh0aGlzLGkpLHQub2ZmKFwidHJhbnNpdGlvbmVuZFwiLGEpKX0pKSx0aGlzfSxvdXRlcldpZHRoOmZ1bmN0aW9uKGUpe2lmKHRoaXMubGVuZ3RoPjApe2lmKGUpe3ZhciB0PXRoaXMuc3R5bGVzKCk7cmV0dXJuIHRoaXNbMF0ub2Zmc2V0V2lkdGgrcGFyc2VGbG9hdCh0LmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tcmlnaHRcIikpK3BhcnNlRmxvYXQodC5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWxlZnRcIikpfXJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRofXJldHVybiBudWxsfSxvdXRlckhlaWdodDpmdW5jdGlvbihlKXtpZih0aGlzLmxlbmd0aD4wKXtpZihlKXt2YXIgdD10aGlzLnN0eWxlcygpO3JldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodCtwYXJzZUZsb2F0KHQuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi10b3BcIikpK3BhcnNlRmxvYXQodC5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWJvdHRvbVwiKSl9cmV0dXJuIHRoaXNbMF0ub2Zmc2V0SGVpZ2h0fXJldHVybiBudWxsfSxzdHlsZXM6ZnVuY3Rpb24oKXt2YXIgZT1sKCk7cmV0dXJuIHRoaXNbMF0/ZS5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sbnVsbCk6e319LG9mZnNldDpmdW5jdGlvbigpe2lmKHRoaXMubGVuZ3RoPjApe3ZhciBlPWwoKSx0PXIoKSxhPXRoaXNbMF0saT1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHM9dC5ib2R5LG49YS5jbGllbnRUb3B8fHMuY2xpZW50VG9wfHwwLG89YS5jbGllbnRMZWZ0fHxzLmNsaWVudExlZnR8fDAsZD1hPT09ZT9lLnNjcm9sbFk6YS5zY3JvbGxUb3AscD1hPT09ZT9lLnNjcm9sbFg6YS5zY3JvbGxMZWZ0O3JldHVybnt0b3A6aS50b3ArZC1uLGxlZnQ6aS5sZWZ0K3Atb319cmV0dXJuIG51bGx9LGNzczpmdW5jdGlvbihlLHQpe3ZhciBhLGk9bCgpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl7Zm9yKGE9MDthPHRoaXMubGVuZ3RoO2ErPTEpZm9yKHZhciBzIGluIGUpdGhpc1thXS5zdHlsZVtzXT1lW3NdO3JldHVybiB0aGlzfWlmKHRoaXNbMF0pcmV0dXJuIGkuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLG51bGwpLmdldFByb3BlcnR5VmFsdWUoZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwic3RyaW5nXCI9PXR5cGVvZiBlKXtmb3IoYT0wO2E8dGhpcy5sZW5ndGg7YSs9MSl0aGlzW2FdLnN0eWxlW2VdPXQ7cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXN9LGVhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/KHRoaXMuZm9yRWFjaCgoZnVuY3Rpb24odCxhKXtlLmFwcGx5KHQsW3QsYV0pfSkpLHRoaXMpOnRoaXN9LGh0bWw6ZnVuY3Rpb24oZSl7aWYodm9pZCAwPT09ZSlyZXR1cm4gdGhpc1swXT90aGlzWzBdLmlubmVySFRNTDpudWxsO2Zvcih2YXIgdD0wO3Q8dGhpcy5sZW5ndGg7dCs9MSl0aGlzW3RdLmlubmVySFRNTD1lO3JldHVybiB0aGlzfSx0ZXh0OmZ1bmN0aW9uKGUpe2lmKHZvaWQgMD09PWUpcmV0dXJuIHRoaXNbMF0/dGhpc1swXS50ZXh0Q29udGVudC50cmltKCk6bnVsbDtmb3IodmFyIHQ9MDt0PHRoaXMubGVuZ3RoO3QrPTEpdGhpc1t0XS50ZXh0Q29udGVudD1lO3JldHVybiB0aGlzfSxpczpmdW5jdGlvbihlKXt2YXIgdCxhLGk9bCgpLHM9cigpLG49dGhpc1swXTtpZighbnx8dm9pZCAwPT09ZSlyZXR1cm4hMTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYobi5tYXRjaGVzKXJldHVybiBuLm1hdGNoZXMoZSk7aWYobi53ZWJraXRNYXRjaGVzU2VsZWN0b3IpcmV0dXJuIG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKGUpO2lmKG4ubXNNYXRjaGVzU2VsZWN0b3IpcmV0dXJuIG4ubXNNYXRjaGVzU2VsZWN0b3IoZSk7Zm9yKHQ9bShlKSxhPTA7YTx0Lmxlbmd0aDthKz0xKWlmKHRbYV09PT1uKXJldHVybiEwO3JldHVybiExfWlmKGU9PT1zKXJldHVybiBuPT09cztpZihlPT09aSlyZXR1cm4gbj09PWk7aWYoZS5ub2RlVHlwZXx8ZSBpbnN0YW5jZW9mIGgpe2Zvcih0PWUubm9kZVR5cGU/W2VdOmUsYT0wO2E8dC5sZW5ndGg7YSs9MSlpZih0W2FdPT09bilyZXR1cm4hMDtyZXR1cm4hMX1yZXR1cm4hMX0saW5kZXg6ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXNbMF07aWYodCl7Zm9yKGU9MDtudWxsIT09KHQ9dC5wcmV2aW91c1NpYmxpbmcpOykxPT09dC5ub2RlVHlwZSYmKGUrPTEpO3JldHVybiBlfX0sZXE6ZnVuY3Rpb24oZSl7aWYodm9pZCAwPT09ZSlyZXR1cm4gdGhpczt2YXIgdD10aGlzLmxlbmd0aDtpZihlPnQtMSlyZXR1cm4gbShbXSk7aWYoZTwwKXt2YXIgYT10K2U7cmV0dXJuIG0oYTwwP1tdOlt0aGlzW2FdXSl9cmV0dXJuIG0oW3RoaXNbZV1dKX0sYXBwZW5kOmZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQ9cigpLGE9MDthPGFyZ3VtZW50cy5sZW5ndGg7YSs9MSl7ZT1hPDB8fGFyZ3VtZW50cy5sZW5ndGg8PWE/dm9pZCAwOmFyZ3VtZW50c1thXTtmb3IodmFyIGk9MDtpPHRoaXMubGVuZ3RoO2krPTEpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBzPXQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3Iocy5pbm5lckhUTUw9ZTtzLmZpcnN0Q2hpbGQ7KXRoaXNbaV0uYXBwZW5kQ2hpbGQocy5maXJzdENoaWxkKX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBoKWZvcih2YXIgbj0wO248ZS5sZW5ndGg7bis9MSl0aGlzW2ldLmFwcGVuZENoaWxkKGVbbl0pO2Vsc2UgdGhpc1tpXS5hcHBlbmRDaGlsZChlKX1yZXR1cm4gdGhpc30scHJlcGVuZDpmdW5jdGlvbihlKXt2YXIgdCxhLGk9cigpO2Zvcih0PTA7dDx0aGlzLmxlbmd0aDt0Kz0xKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgcz1pLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Zm9yKHMuaW5uZXJIVE1MPWUsYT1zLmNoaWxkTm9kZXMubGVuZ3RoLTE7YT49MDthLT0xKXRoaXNbdF0uaW5zZXJ0QmVmb3JlKHMuY2hpbGROb2Rlc1thXSx0aGlzW3RdLmNoaWxkTm9kZXNbMF0pfWVsc2UgaWYoZSBpbnN0YW5jZW9mIGgpZm9yKGE9MDthPGUubGVuZ3RoO2ErPTEpdGhpc1t0XS5pbnNlcnRCZWZvcmUoZVthXSx0aGlzW3RdLmNoaWxkTm9kZXNbMF0pO2Vsc2UgdGhpc1t0XS5pbnNlcnRCZWZvcmUoZSx0aGlzW3RdLmNoaWxkTm9kZXNbMF0pO3JldHVybiB0aGlzfSxuZXh0OmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlbmd0aD4wP2U/dGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcmJm0odGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpLmlzKGUpP20oW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSk6bShbXSk6dGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmc/bShbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTptKFtdKTptKFtdKX0sbmV4dEFsbDpmdW5jdGlvbihlKXt2YXIgdD1bXSxhPXRoaXNbMF07aWYoIWEpcmV0dXJuIG0oW10pO2Zvcig7YS5uZXh0RWxlbWVudFNpYmxpbmc7KXt2YXIgaT1hLm5leHRFbGVtZW50U2libGluZztlP20oaSkuaXMoZSkmJnQucHVzaChpKTp0LnB1c2goaSksYT1pfXJldHVybiBtKHQpfSxwcmV2OmZ1bmN0aW9uKGUpe2lmKHRoaXMubGVuZ3RoPjApe3ZhciB0PXRoaXNbMF07cmV0dXJuIGU/dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nJiZtKHQucHJldmlvdXNFbGVtZW50U2libGluZykuaXMoZSk/bShbdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSk6bShbXSk6dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nP20oW3QucHJldmlvdXNFbGVtZW50U2libGluZ10pOm0oW10pfXJldHVybiBtKFtdKX0scHJldkFsbDpmdW5jdGlvbihlKXt2YXIgdD1bXSxhPXRoaXNbMF07aWYoIWEpcmV0dXJuIG0oW10pO2Zvcig7YS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOyl7dmFyIGk9YS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO2U/bShpKS5pcyhlKSYmdC5wdXNoKGkpOnQucHVzaChpKSxhPWl9cmV0dXJuIG0odCl9LHBhcmVudDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10sYT0wO2E8dGhpcy5sZW5ndGg7YSs9MSludWxsIT09dGhpc1thXS5wYXJlbnROb2RlJiYoZT9tKHRoaXNbYV0ucGFyZW50Tm9kZSkuaXMoZSkmJnQucHVzaCh0aGlzW2FdLnBhcmVudE5vZGUpOnQucHVzaCh0aGlzW2FdLnBhcmVudE5vZGUpKTtyZXR1cm4gbSh0KX0scGFyZW50czpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10sYT0wO2E8dGhpcy5sZW5ndGg7YSs9MSlmb3IodmFyIGk9dGhpc1thXS5wYXJlbnROb2RlO2k7KWU/bShpKS5pcyhlKSYmdC5wdXNoKGkpOnQucHVzaChpKSxpPWkucGFyZW50Tm9kZTtyZXR1cm4gbSh0KX0sY2xvc2VzdDpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB2b2lkIDA9PT1lP20oW10pOih0LmlzKGUpfHwodD10LnBhcmVudHMoZSkuZXEoMCkpLHQpfSxmaW5kOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxhPTA7YTx0aGlzLmxlbmd0aDthKz0xKWZvcih2YXIgaT10aGlzW2FdLnF1ZXJ5U2VsZWN0b3JBbGwoZSkscz0wO3M8aS5sZW5ndGg7cys9MSl0LnB1c2goaVtzXSk7cmV0dXJuIG0odCl9LGNoaWxkcmVuOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxhPTA7YTx0aGlzLmxlbmd0aDthKz0xKWZvcih2YXIgaT10aGlzW2FdLmNoaWxkcmVuLHM9MDtzPGkubGVuZ3RoO3MrPTEpZSYmIW0oaVtzXSkuaXMoZSl8fHQucHVzaChpW3NdKTtyZXR1cm4gbSh0KX0sZmlsdGVyOmZ1bmN0aW9uKGUpe3JldHVybiBtKGYodGhpcyxlKSl9LHJlbW92ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8dGhpcy5sZW5ndGg7ZSs9MSl0aGlzW2VdLnBhcmVudE5vZGUmJnRoaXNbZV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzW2VdKTtyZXR1cm4gdGhpc319O2Z1bmN0aW9uIEUoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksc2V0VGltZW91dChlLHQpfWZ1bmN0aW9uIHgoKXtyZXR1cm4gRGF0ZS5ub3coKX1mdW5jdGlvbiBUKGUsdCl7dm9pZCAwPT09dCYmKHQ9XCJ4XCIpO3ZhciBhLGkscyxyPWwoKSxuPXIuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpO3JldHVybiByLldlYktpdENTU01hdHJpeD8oKGk9bi50cmFuc2Zvcm18fG4ud2Via2l0VHJhbnNmb3JtKS5zcGxpdChcIixcIikubGVuZ3RoPjYmJihpPWkuc3BsaXQoXCIsIFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoXCIsXCIsXCIuXCIpfSkpLmpvaW4oXCIsIFwiKSkscz1uZXcgci5XZWJLaXRDU1NNYXRyaXgoXCJub25lXCI9PT1pP1wiXCI6aSkpOmE9KHM9bi5Nb3pUcmFuc2Zvcm18fG4uT1RyYW5zZm9ybXx8bi5Nc1RyYW5zZm9ybXx8bi5tc1RyYW5zZm9ybXx8bi50cmFuc2Zvcm18fG4uZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKS5yZXBsYWNlKFwidHJhbnNsYXRlKFwiLFwibWF0cml4KDEsIDAsIDAsIDEsXCIpKS50b1N0cmluZygpLnNwbGl0KFwiLFwiKSxcInhcIj09PXQmJihpPXIuV2ViS2l0Q1NTTWF0cml4P3MubTQxOjE2PT09YS5sZW5ndGg/cGFyc2VGbG9hdChhWzEyXSk6cGFyc2VGbG9hdChhWzRdKSksXCJ5XCI9PT10JiYoaT1yLldlYktpdENTU01hdHJpeD9zLm00MjoxNj09PWEubGVuZ3RoP3BhcnNlRmxvYXQoYVsxM10pOnBhcnNlRmxvYXQoYVs1XSkpLGl8fDB9ZnVuY3Rpb24gQyhlKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUmJmUuY29uc3RydWN0b3ImJmUuY29uc3RydWN0b3I9PT1PYmplY3R9ZnVuY3Rpb24gUygpe2Zvcih2YXIgZT1PYmplY3QoYXJndW1lbnRzLmxlbmd0aDw9MD92b2lkIDA6YXJndW1lbnRzWzBdKSx0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrPTEpe3ZhciBhPXQ8MHx8YXJndW1lbnRzLmxlbmd0aDw9dD92b2lkIDA6YXJndW1lbnRzW3RdO2lmKG51bGwhPWEpZm9yKHZhciBpPU9iamVjdC5rZXlzKE9iamVjdChhKSkscz0wLHI9aS5sZW5ndGg7czxyO3MrPTEpe3ZhciBuPWlbc10sbD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsbik7dm9pZCAwIT09bCYmbC5lbnVtZXJhYmxlJiYoQyhlW25dKSYmQyhhW25dKT9TKGVbbl0sYVtuXSk6IUMoZVtuXSkmJkMoYVtuXSk/KGVbbl09e30sUyhlW25dLGFbbl0pKTplW25dPWFbbl0pfX1yZXR1cm4gZX1mdW5jdGlvbiBNKGUsdCl7T2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24oYSl7Qyh0W2FdKSYmT2JqZWN0LmtleXModFthXSkuZm9yRWFjaCgoZnVuY3Rpb24oaSl7XCJmdW5jdGlvblwiPT10eXBlb2YgdFthXVtpXSYmKHRbYV1baV09dFthXVtpXS5iaW5kKGUpKX0pKSxlW2FdPXRbYV19KSl9ZnVuY3Rpb24geigpe3JldHVybiBnfHwoZz1mdW5jdGlvbigpe3ZhciBlPWwoKSx0PXIoKTtyZXR1cm57dG91Y2g6ISEoXCJvbnRvdWNoc3RhcnRcImluIGV8fGUuRG9jdW1lbnRUb3VjaCYmdCBpbnN0YW5jZW9mIGUuRG9jdW1lbnRUb3VjaCkscG9pbnRlckV2ZW50czohIWUuUG9pbnRlckV2ZW50JiZcIm1heFRvdWNoUG9pbnRzXCJpbiBlLm5hdmlnYXRvciYmZS5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM+PTAsb2JzZXJ2ZXI6XCJNdXRhdGlvbk9ic2VydmVyXCJpbiBlfHxcIldlYmtpdE11dGF0aW9uT2JzZXJ2ZXJcImluIGUscGFzc2l2ZUxpc3RlbmVyOmZ1bmN0aW9uKCl7dmFyIHQ9ITE7dHJ5e3ZhciBhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7dD0hMH19KTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZUxpc3RlbmVyXCIsbnVsbCxhKX1jYXRjaChlKXt9cmV0dXJuIHR9KCksZ2VzdHVyZXM6XCJvbmdlc3R1cmVzdGFydFwiaW4gZX19KCkpLGd9ZnVuY3Rpb24gUChlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHl8fCh5PWZ1bmN0aW9uKGUpe3ZhciB0PSh2b2lkIDA9PT1lP3t9OmUpLnVzZXJBZ2VudCxhPXooKSxpPWwoKSxzPWkubmF2aWdhdG9yLnBsYXRmb3JtLHI9dHx8aS5uYXZpZ2F0b3IudXNlckFnZW50LG49e2lvczohMSxhbmRyb2lkOiExfSxvPWkuc2NyZWVuLndpZHRoLGQ9aS5zY3JlZW4uaGVpZ2h0LHA9ci5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/LyksdT1yLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyksYz1yLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/LyksaD0hdSYmci5tYXRjaCgvKGlQaG9uZVxcc09TfGlPUylcXHMoW1xcZF9dKykvKSx2PVwiV2luMzJcIj09PXMsZj1cIk1hY0ludGVsXCI9PT1zO3JldHVybiF1JiZmJiZhLnRvdWNoJiZbXCIxMDI0eDEzNjZcIixcIjEzNjZ4MTAyNFwiLFwiODM0eDExOTRcIixcIjExOTR4ODM0XCIsXCI4MzR4MTExMlwiLFwiMTExMng4MzRcIixcIjc2OHgxMDI0XCIsXCIxMDI0eDc2OFwiLFwiODIweDExODBcIixcIjExODB4ODIwXCIsXCI4MTB4MTA4MFwiLFwiMTA4MHg4MTBcIl0uaW5kZXhPZihvK1wieFwiK2QpPj0wJiYoKHU9ci5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLykpfHwodT1bMCwxLFwiMTNfMF8wXCJdKSxmPSExKSxwJiYhdiYmKG4ub3M9XCJhbmRyb2lkXCIsbi5hbmRyb2lkPSEwKSwodXx8aHx8YykmJihuLm9zPVwiaW9zXCIsbi5pb3M9ITApLG59KGUpKSx5fWZ1bmN0aW9uIGsoKXtyZXR1cm4gd3x8KHc9ZnVuY3Rpb24oKXt2YXIgZSx0PWwoKTtyZXR1cm57aXNFZGdlOiEhdC5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlL2cpLGlzU2FmYXJpOihlPXQubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLGUuaW5kZXhPZihcInNhZmFyaVwiKT49MCYmZS5pbmRleE9mKFwiY2hyb21lXCIpPDAmJmUuaW5kZXhPZihcImFuZHJvaWRcIik8MCksaXNXZWJWaWV3Oi8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh0Lm5hdmlnYXRvci51c2VyQWdlbnQpfX0oKSksd31PYmplY3Qua2V5cyhiKS5mb3JFYWNoKChmdW5jdGlvbihlKXttLmZuW2VdPWJbZV19KSk7dmFyIEw9e25hbWU6XCJyZXNpemVcIixjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO1MoZSx7cmVzaXplOntyZXNpemVIYW5kbGVyOmZ1bmN0aW9uKCl7ZSYmIWUuZGVzdHJveWVkJiZlLmluaXRpYWxpemVkJiYoZS5lbWl0KFwiYmVmb3JlUmVzaXplXCIpLGUuZW1pdChcInJlc2l6ZVwiKSl9LG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcjpmdW5jdGlvbigpe2UmJiFlLmRlc3Ryb3llZCYmZS5pbml0aWFsaXplZCYmZS5lbWl0KFwib3JpZW50YXRpb25jaGFuZ2VcIil9fX0pfSxvbjp7aW5pdDpmdW5jdGlvbihlKXt2YXIgdD1sKCk7dC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsZS5yZXNpemUucmVzaXplSGFuZGxlciksdC5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIixlLnJlc2l6ZS5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpfSxkZXN0cm95OmZ1bmN0aW9uKGUpe3ZhciB0PWwoKTt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixlLnJlc2l6ZS5yZXNpemVIYW5kbGVyKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLGUucmVzaXplLm9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcil9fX0sJD17YXR0YWNoOmZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciBhPWwoKSxpPXRoaXMscz1uZXcoYS5NdXRhdGlvbk9ic2VydmVyfHxhLldlYmtpdE11dGF0aW9uT2JzZXJ2ZXIpKChmdW5jdGlvbihlKXtpZigxIT09ZS5sZW5ndGgpe3ZhciB0PWZ1bmN0aW9uKCl7aS5lbWl0KFwib2JzZXJ2ZXJVcGRhdGVcIixlWzBdKX07YS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/YS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCk6YS5zZXRUaW1lb3V0KHQsMCl9ZWxzZSBpLmVtaXQoXCJvYnNlcnZlclVwZGF0ZVwiLGVbMF0pfSkpO3Mub2JzZXJ2ZShlLHthdHRyaWJ1dGVzOnZvaWQgMD09PXQuYXR0cmlidXRlc3x8dC5hdHRyaWJ1dGVzLGNoaWxkTGlzdDp2b2lkIDA9PT10LmNoaWxkTGlzdHx8dC5jaGlsZExpc3QsY2hhcmFjdGVyRGF0YTp2b2lkIDA9PT10LmNoYXJhY3RlckRhdGF8fHQuY2hhcmFjdGVyRGF0YX0pLGkub2JzZXJ2ZXIub2JzZXJ2ZXJzLnB1c2gocyl9LGluaXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKGUuc3VwcG9ydC5vYnNlcnZlciYmZS5wYXJhbXMub2JzZXJ2ZXIpe2lmKGUucGFyYW1zLm9ic2VydmVQYXJlbnRzKWZvcih2YXIgdD1lLiRlbC5wYXJlbnRzKCksYT0wO2E8dC5sZW5ndGg7YSs9MSllLm9ic2VydmVyLmF0dGFjaCh0W2FdKTtlLm9ic2VydmVyLmF0dGFjaChlLiRlbFswXSx7Y2hpbGRMaXN0OmUucGFyYW1zLm9ic2VydmVTbGlkZUNoaWxkcmVufSksZS5vYnNlcnZlci5hdHRhY2goZS4kd3JhcHBlckVsWzBdLHthdHRyaWJ1dGVzOiExfSl9fSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5vYnNlcnZlci5vYnNlcnZlcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5kaXNjb25uZWN0KCl9KSksdGhpcy5vYnNlcnZlci5vYnNlcnZlcnM9W119fSxJPXtuYW1lOlwib2JzZXJ2ZXJcIixwYXJhbXM6e29ic2VydmVyOiExLG9ic2VydmVQYXJlbnRzOiExLG9ic2VydmVTbGlkZUNoaWxkcmVuOiExfSxjcmVhdGU6ZnVuY3Rpb24oKXtNKHRoaXMse29ic2VydmVyOnQoe30sJCx7b2JzZXJ2ZXJzOltdfSl9KX0sb246e2luaXQ6ZnVuY3Rpb24oZSl7ZS5vYnNlcnZlci5pbml0KCl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS5vYnNlcnZlci5kZXN0cm95KCl9fX07ZnVuY3Rpb24gTyhlKXt2YXIgdD10aGlzLGE9cigpLGk9bCgpLHM9dC50b3VjaEV2ZW50c0RhdGEsbj10LnBhcmFtcyxvPXQudG91Y2hlcztpZighdC5hbmltYXRpbmd8fCFuLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbil7dmFyIGQ9ZTtkLm9yaWdpbmFsRXZlbnQmJihkPWQub3JpZ2luYWxFdmVudCk7dmFyIHA9bShkLnRhcmdldCk7aWYoXCJ3cmFwcGVyXCIhPT1uLnRvdWNoRXZlbnRzVGFyZ2V0fHxwLmNsb3Nlc3QodC53cmFwcGVyRWwpLmxlbmd0aClpZihzLmlzVG91Y2hFdmVudD1cInRvdWNoc3RhcnRcIj09PWQudHlwZSxzLmlzVG91Y2hFdmVudHx8IShcIndoaWNoXCJpbiBkKXx8MyE9PWQud2hpY2gpaWYoISghcy5pc1RvdWNoRXZlbnQmJlwiYnV0dG9uXCJpbiBkJiZkLmJ1dHRvbj4wKSlpZighcy5pc1RvdWNoZWR8fCFzLmlzTW92ZWQpaWYoISFuLm5vU3dpcGluZ0NsYXNzJiZcIlwiIT09bi5ub1N3aXBpbmdDbGFzcyYmZC50YXJnZXQmJmQudGFyZ2V0LnNoYWRvd1Jvb3QmJmUucGF0aCYmZS5wYXRoWzBdJiYocD1tKGUucGF0aFswXSkpLG4ubm9Td2lwaW5nJiZwLmNsb3Nlc3Qobi5ub1N3aXBpbmdTZWxlY3Rvcj9uLm5vU3dpcGluZ1NlbGVjdG9yOlwiLlwiK24ubm9Td2lwaW5nQ2xhc3MpWzBdKXQuYWxsb3dDbGljaz0hMDtlbHNlIGlmKCFuLnN3aXBlSGFuZGxlcnx8cC5jbG9zZXN0KG4uc3dpcGVIYW5kbGVyKVswXSl7by5jdXJyZW50WD1cInRvdWNoc3RhcnRcIj09PWQudHlwZT9kLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg6ZC5wYWdlWCxvLmN1cnJlbnRZPVwidG91Y2hzdGFydFwiPT09ZC50eXBlP2QudGFyZ2V0VG91Y2hlc1swXS5wYWdlWTpkLnBhZ2VZO3ZhciB1PW8uY3VycmVudFgsYz1vLmN1cnJlbnRZLGg9bi5lZGdlU3dpcGVEZXRlY3Rpb258fG4uaU9TRWRnZVN3aXBlRGV0ZWN0aW9uLHY9bi5lZGdlU3dpcGVUaHJlc2hvbGR8fG4uaU9TRWRnZVN3aXBlVGhyZXNob2xkO2lmKCFofHwhKHU8PXZ8fHU+PWkuaW5uZXJXaWR0aC12KSl7aWYoUyhzLHtpc1RvdWNoZWQ6ITAsaXNNb3ZlZDohMSxhbGxvd1RvdWNoQ2FsbGJhY2tzOiEwLGlzU2Nyb2xsaW5nOnZvaWQgMCxzdGFydE1vdmluZzp2b2lkIDB9KSxvLnN0YXJ0WD11LG8uc3RhcnRZPWMscy50b3VjaFN0YXJ0VGltZT14KCksdC5hbGxvd0NsaWNrPSEwLHQudXBkYXRlU2l6ZSgpLHQuc3dpcGVEaXJlY3Rpb249dm9pZCAwLG4udGhyZXNob2xkPjAmJihzLmFsbG93VGhyZXNob2xkTW92ZT0hMSksXCJ0b3VjaHN0YXJ0XCIhPT1kLnR5cGUpe3ZhciBmPSEwO3AuaXMocy5mb3JtRWxlbWVudHMpJiYoZj0hMSksYS5hY3RpdmVFbGVtZW50JiZtKGEuYWN0aXZlRWxlbWVudCkuaXMocy5mb3JtRWxlbWVudHMpJiZhLmFjdGl2ZUVsZW1lbnQhPT1wWzBdJiZhLmFjdGl2ZUVsZW1lbnQuYmx1cigpO3ZhciBnPWYmJnQuYWxsb3dUb3VjaE1vdmUmJm4udG91Y2hTdGFydFByZXZlbnREZWZhdWx0OyFuLnRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0JiYhZ3x8cFswXS5pc0NvbnRlbnRFZGl0YWJsZXx8ZC5wcmV2ZW50RGVmYXVsdCgpfXQuZW1pdChcInRvdWNoU3RhcnRcIixkKX19fX1mdW5jdGlvbiBBKGUpe3ZhciB0PXIoKSxhPXRoaXMsaT1hLnRvdWNoRXZlbnRzRGF0YSxzPWEucGFyYW1zLG49YS50b3VjaGVzLGw9YS5ydGxUcmFuc2xhdGUsbz1lO2lmKG8ub3JpZ2luYWxFdmVudCYmKG89by5vcmlnaW5hbEV2ZW50KSxpLmlzVG91Y2hlZCl7aWYoIWkuaXNUb3VjaEV2ZW50fHxcInRvdWNobW92ZVwiPT09by50eXBlKXt2YXIgZD1cInRvdWNobW92ZVwiPT09by50eXBlJiZvLnRhcmdldFRvdWNoZXMmJihvLnRhcmdldFRvdWNoZXNbMF18fG8uY2hhbmdlZFRvdWNoZXNbMF0pLHA9XCJ0b3VjaG1vdmVcIj09PW8udHlwZT9kLnBhZ2VYOm8ucGFnZVgsdT1cInRvdWNobW92ZVwiPT09by50eXBlP2QucGFnZVk6by5wYWdlWTtpZihvLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyKXJldHVybiBuLnN0YXJ0WD1wLHZvaWQobi5zdGFydFk9dSk7aWYoIWEuYWxsb3dUb3VjaE1vdmUpcmV0dXJuIGEuYWxsb3dDbGljaz0hMSx2b2lkKGkuaXNUb3VjaGVkJiYoUyhuLHtzdGFydFg6cCxzdGFydFk6dSxjdXJyZW50WDpwLGN1cnJlbnRZOnV9KSxpLnRvdWNoU3RhcnRUaW1lPXgoKSkpO2lmKGkuaXNUb3VjaEV2ZW50JiZzLnRvdWNoUmVsZWFzZU9uRWRnZXMmJiFzLmxvb3ApaWYoYS5pc1ZlcnRpY2FsKCkpe2lmKHU8bi5zdGFydFkmJmEudHJhbnNsYXRlPD1hLm1heFRyYW5zbGF0ZSgpfHx1Pm4uc3RhcnRZJiZhLnRyYW5zbGF0ZT49YS5taW5UcmFuc2xhdGUoKSlyZXR1cm4gaS5pc1RvdWNoZWQ9ITEsdm9pZChpLmlzTW92ZWQ9ITEpfWVsc2UgaWYocDxuLnN0YXJ0WCYmYS50cmFuc2xhdGU8PWEubWF4VHJhbnNsYXRlKCl8fHA+bi5zdGFydFgmJmEudHJhbnNsYXRlPj1hLm1pblRyYW5zbGF0ZSgpKXJldHVybjtpZihpLmlzVG91Y2hFdmVudCYmdC5hY3RpdmVFbGVtZW50JiZvLnRhcmdldD09PXQuYWN0aXZlRWxlbWVudCYmbShvLnRhcmdldCkuaXMoaS5mb3JtRWxlbWVudHMpKXJldHVybiBpLmlzTW92ZWQ9ITAsdm9pZChhLmFsbG93Q2xpY2s9ITEpO2lmKGkuYWxsb3dUb3VjaENhbGxiYWNrcyYmYS5lbWl0KFwidG91Y2hNb3ZlXCIsbyksIShvLnRhcmdldFRvdWNoZXMmJm8udGFyZ2V0VG91Y2hlcy5sZW5ndGg+MSkpe24uY3VycmVudFg9cCxuLmN1cnJlbnRZPXU7dmFyIGM9bi5jdXJyZW50WC1uLnN0YXJ0WCxoPW4uY3VycmVudFktbi5zdGFydFk7aWYoIShhLnBhcmFtcy50aHJlc2hvbGQmJk1hdGguc3FydChNYXRoLnBvdyhjLDIpK01hdGgucG93KGgsMikpPGEucGFyYW1zLnRocmVzaG9sZCkpe3ZhciB2O2lmKHZvaWQgMD09PWkuaXNTY3JvbGxpbmcpYS5pc0hvcml6b250YWwoKSYmbi5jdXJyZW50WT09PW4uc3RhcnRZfHxhLmlzVmVydGljYWwoKSYmbi5jdXJyZW50WD09PW4uc3RhcnRYP2kuaXNTY3JvbGxpbmc9ITE6YypjK2gqaD49MjUmJih2PTE4MCpNYXRoLmF0YW4yKE1hdGguYWJzKGgpLE1hdGguYWJzKGMpKS9NYXRoLlBJLGkuaXNTY3JvbGxpbmc9YS5pc0hvcml6b250YWwoKT92PnMudG91Y2hBbmdsZTo5MC12PnMudG91Y2hBbmdsZSk7aWYoaS5pc1Njcm9sbGluZyYmYS5lbWl0KFwidG91Y2hNb3ZlT3Bwb3NpdGVcIixvKSx2b2lkIDA9PT1pLnN0YXJ0TW92aW5nJiYobi5jdXJyZW50WD09PW4uc3RhcnRYJiZuLmN1cnJlbnRZPT09bi5zdGFydFl8fChpLnN0YXJ0TW92aW5nPSEwKSksaS5pc1Njcm9sbGluZylpLmlzVG91Y2hlZD0hMTtlbHNlIGlmKGkuc3RhcnRNb3Zpbmcpe2EuYWxsb3dDbGljaz0hMSwhcy5jc3NNb2RlJiZvLmNhbmNlbGFibGUmJm8ucHJldmVudERlZmF1bHQoKSxzLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiYmIXMubmVzdGVkJiZvLnN0b3BQcm9wYWdhdGlvbigpLGkuaXNNb3ZlZHx8KHMubG9vcCYmYS5sb29wRml4KCksaS5zdGFydFRyYW5zbGF0ZT1hLmdldFRyYW5zbGF0ZSgpLGEuc2V0VHJhbnNpdGlvbigwKSxhLmFuaW1hdGluZyYmYS4kd3JhcHBlckVsLnRyaWdnZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kIHRyYW5zaXRpb25lbmRcIiksaS5hbGxvd01vbWVudHVtQm91bmNlPSExLCFzLmdyYWJDdXJzb3J8fCEwIT09YS5hbGxvd1NsaWRlTmV4dCYmITAhPT1hLmFsbG93U2xpZGVQcmV2fHxhLnNldEdyYWJDdXJzb3IoITApLGEuZW1pdChcInNsaWRlckZpcnN0TW92ZVwiLG8pKSxhLmVtaXQoXCJzbGlkZXJNb3ZlXCIsbyksaS5pc01vdmVkPSEwO3ZhciBmPWEuaXNIb3Jpem9udGFsKCk/YzpoO24uZGlmZj1mLGYqPXMudG91Y2hSYXRpbyxsJiYoZj0tZiksYS5zd2lwZURpcmVjdGlvbj1mPjA/XCJwcmV2XCI6XCJuZXh0XCIsaS5jdXJyZW50VHJhbnNsYXRlPWYraS5zdGFydFRyYW5zbGF0ZTt2YXIgZz0hMCx5PXMucmVzaXN0YW5jZVJhdGlvO2lmKHMudG91Y2hSZWxlYXNlT25FZGdlcyYmKHk9MCksZj4wJiZpLmN1cnJlbnRUcmFuc2xhdGU+YS5taW5UcmFuc2xhdGUoKT8oZz0hMSxzLnJlc2lzdGFuY2UmJihpLmN1cnJlbnRUcmFuc2xhdGU9YS5taW5UcmFuc2xhdGUoKS0xK01hdGgucG93KC1hLm1pblRyYW5zbGF0ZSgpK2kuc3RhcnRUcmFuc2xhdGUrZix5KSkpOmY8MCYmaS5jdXJyZW50VHJhbnNsYXRlPGEubWF4VHJhbnNsYXRlKCkmJihnPSExLHMucmVzaXN0YW5jZSYmKGkuY3VycmVudFRyYW5zbGF0ZT1hLm1heFRyYW5zbGF0ZSgpKzEtTWF0aC5wb3coYS5tYXhUcmFuc2xhdGUoKS1pLnN0YXJ0VHJhbnNsYXRlLWYseSkpKSxnJiYoby5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcj0hMCksIWEuYWxsb3dTbGlkZU5leHQmJlwibmV4dFwiPT09YS5zd2lwZURpcmVjdGlvbiYmaS5jdXJyZW50VHJhbnNsYXRlPGkuc3RhcnRUcmFuc2xhdGUmJihpLmN1cnJlbnRUcmFuc2xhdGU9aS5zdGFydFRyYW5zbGF0ZSksIWEuYWxsb3dTbGlkZVByZXYmJlwicHJldlwiPT09YS5zd2lwZURpcmVjdGlvbiYmaS5jdXJyZW50VHJhbnNsYXRlPmkuc3RhcnRUcmFuc2xhdGUmJihpLmN1cnJlbnRUcmFuc2xhdGU9aS5zdGFydFRyYW5zbGF0ZSkscy50aHJlc2hvbGQ+MCl7aWYoIShNYXRoLmFicyhmKT5zLnRocmVzaG9sZHx8aS5hbGxvd1RocmVzaG9sZE1vdmUpKXJldHVybiB2b2lkKGkuY3VycmVudFRyYW5zbGF0ZT1pLnN0YXJ0VHJhbnNsYXRlKTtpZighaS5hbGxvd1RocmVzaG9sZE1vdmUpcmV0dXJuIGkuYWxsb3dUaHJlc2hvbGRNb3ZlPSEwLG4uc3RhcnRYPW4uY3VycmVudFgsbi5zdGFydFk9bi5jdXJyZW50WSxpLmN1cnJlbnRUcmFuc2xhdGU9aS5zdGFydFRyYW5zbGF0ZSx2b2lkKG4uZGlmZj1hLmlzSG9yaXpvbnRhbCgpP24uY3VycmVudFgtbi5zdGFydFg6bi5jdXJyZW50WS1uLnN0YXJ0WSl9cy5mb2xsb3dGaW5nZXImJiFzLmNzc01vZGUmJigocy5mcmVlTW9kZXx8cy53YXRjaFNsaWRlc1Byb2dyZXNzfHxzLndhdGNoU2xpZGVzVmlzaWJpbGl0eSkmJihhLnVwZGF0ZUFjdGl2ZUluZGV4KCksYS51cGRhdGVTbGlkZXNDbGFzc2VzKCkpLHMuZnJlZU1vZGUmJigwPT09aS52ZWxvY2l0aWVzLmxlbmd0aCYmaS52ZWxvY2l0aWVzLnB1c2goe3Bvc2l0aW9uOm5bYS5pc0hvcml6b250YWwoKT9cInN0YXJ0WFwiOlwic3RhcnRZXCJdLHRpbWU6aS50b3VjaFN0YXJ0VGltZX0pLGkudmVsb2NpdGllcy5wdXNoKHtwb3NpdGlvbjpuW2EuaXNIb3Jpem9udGFsKCk/XCJjdXJyZW50WFwiOlwiY3VycmVudFlcIl0sdGltZTp4KCl9KSksYS51cGRhdGVQcm9ncmVzcyhpLmN1cnJlbnRUcmFuc2xhdGUpLGEuc2V0VHJhbnNsYXRlKGkuY3VycmVudFRyYW5zbGF0ZSkpfX19fX1lbHNlIGkuc3RhcnRNb3ZpbmcmJmkuaXNTY3JvbGxpbmcmJmEuZW1pdChcInRvdWNoTW92ZU9wcG9zaXRlXCIsbyl9ZnVuY3Rpb24gRChlKXt2YXIgdD10aGlzLGE9dC50b3VjaEV2ZW50c0RhdGEsaT10LnBhcmFtcyxzPXQudG91Y2hlcyxyPXQucnRsVHJhbnNsYXRlLG49dC4kd3JhcHBlckVsLGw9dC5zbGlkZXNHcmlkLG89dC5zbmFwR3JpZCxkPWU7aWYoZC5vcmlnaW5hbEV2ZW50JiYoZD1kLm9yaWdpbmFsRXZlbnQpLGEuYWxsb3dUb3VjaENhbGxiYWNrcyYmdC5lbWl0KFwidG91Y2hFbmRcIixkKSxhLmFsbG93VG91Y2hDYWxsYmFja3M9ITEsIWEuaXNUb3VjaGVkKXJldHVybiBhLmlzTW92ZWQmJmkuZ3JhYkN1cnNvciYmdC5zZXRHcmFiQ3Vyc29yKCExKSxhLmlzTW92ZWQ9ITEsdm9pZChhLnN0YXJ0TW92aW5nPSExKTtpLmdyYWJDdXJzb3ImJmEuaXNNb3ZlZCYmYS5pc1RvdWNoZWQmJighMD09PXQuYWxsb3dTbGlkZU5leHR8fCEwPT09dC5hbGxvd1NsaWRlUHJldikmJnQuc2V0R3JhYkN1cnNvcighMSk7dmFyIHAsdT14KCksYz11LWEudG91Y2hTdGFydFRpbWU7aWYodC5hbGxvd0NsaWNrJiYodC51cGRhdGVDbGlja2VkU2xpZGUoZCksdC5lbWl0KFwidGFwIGNsaWNrXCIsZCksYzwzMDAmJnUtYS5sYXN0Q2xpY2tUaW1lPDMwMCYmdC5lbWl0KFwiZG91YmxlVGFwIGRvdWJsZUNsaWNrXCIsZCkpLGEubGFzdENsaWNrVGltZT14KCksRSgoZnVuY3Rpb24oKXt0LmRlc3Ryb3llZHx8KHQuYWxsb3dDbGljaz0hMCl9KSksIWEuaXNUb3VjaGVkfHwhYS5pc01vdmVkfHwhdC5zd2lwZURpcmVjdGlvbnx8MD09PXMuZGlmZnx8YS5jdXJyZW50VHJhbnNsYXRlPT09YS5zdGFydFRyYW5zbGF0ZSlyZXR1cm4gYS5pc1RvdWNoZWQ9ITEsYS5pc01vdmVkPSExLHZvaWQoYS5zdGFydE1vdmluZz0hMSk7aWYoYS5pc1RvdWNoZWQ9ITEsYS5pc01vdmVkPSExLGEuc3RhcnRNb3Zpbmc9ITEscD1pLmZvbGxvd0Zpbmdlcj9yP3QudHJhbnNsYXRlOi10LnRyYW5zbGF0ZTotYS5jdXJyZW50VHJhbnNsYXRlLCFpLmNzc01vZGUpaWYoaS5mcmVlTW9kZSl7aWYocDwtdC5taW5UcmFuc2xhdGUoKSlyZXR1cm4gdm9pZCB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7aWYocD4tdC5tYXhUcmFuc2xhdGUoKSlyZXR1cm4gdm9pZCh0LnNsaWRlcy5sZW5ndGg8by5sZW5ndGg/dC5zbGlkZVRvKG8ubGVuZ3RoLTEpOnQuc2xpZGVUbyh0LnNsaWRlcy5sZW5ndGgtMSkpO2lmKGkuZnJlZU1vZGVNb21lbnR1bSl7aWYoYS52ZWxvY2l0aWVzLmxlbmd0aD4xKXt2YXIgaD1hLnZlbG9jaXRpZXMucG9wKCksdj1hLnZlbG9jaXRpZXMucG9wKCksZj1oLnBvc2l0aW9uLXYucG9zaXRpb24sbT1oLnRpbWUtdi50aW1lO3QudmVsb2NpdHk9Zi9tLHQudmVsb2NpdHkvPTIsTWF0aC5hYnModC52ZWxvY2l0eSk8aS5mcmVlTW9kZU1pbmltdW1WZWxvY2l0eSYmKHQudmVsb2NpdHk9MCksKG0+MTUwfHx4KCktaC50aW1lPjMwMCkmJih0LnZlbG9jaXR5PTApfWVsc2UgdC52ZWxvY2l0eT0wO3QudmVsb2NpdHkqPWkuZnJlZU1vZGVNb21lbnR1bVZlbG9jaXR5UmF0aW8sYS52ZWxvY2l0aWVzLmxlbmd0aD0wO3ZhciBnPTFlMyppLmZyZWVNb2RlTW9tZW50dW1SYXRpbyx5PXQudmVsb2NpdHkqZyx3PXQudHJhbnNsYXRlK3k7ciYmKHc9LXcpO3ZhciBiLFQsQz0hMSxTPTIwKk1hdGguYWJzKHQudmVsb2NpdHkpKmkuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO2lmKHc8dC5tYXhUcmFuc2xhdGUoKSlpLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2U/KHcrdC5tYXhUcmFuc2xhdGUoKTwtUyYmKHc9dC5tYXhUcmFuc2xhdGUoKS1TKSxiPXQubWF4VHJhbnNsYXRlKCksQz0hMCxhLmFsbG93TW9tZW50dW1Cb3VuY2U9ITApOnc9dC5tYXhUcmFuc2xhdGUoKSxpLmxvb3AmJmkuY2VudGVyZWRTbGlkZXMmJihUPSEwKTtlbHNlIGlmKHc+dC5taW5UcmFuc2xhdGUoKSlpLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2U/KHctdC5taW5UcmFuc2xhdGUoKT5TJiYodz10Lm1pblRyYW5zbGF0ZSgpK1MpLGI9dC5taW5UcmFuc2xhdGUoKSxDPSEwLGEuYWxsb3dNb21lbnR1bUJvdW5jZT0hMCk6dz10Lm1pblRyYW5zbGF0ZSgpLGkubG9vcCYmaS5jZW50ZXJlZFNsaWRlcyYmKFQ9ITApO2Vsc2UgaWYoaS5mcmVlTW9kZVN0aWNreSl7Zm9yKHZhciBNLHo9MDt6PG8ubGVuZ3RoO3orPTEpaWYob1t6XT4tdyl7TT16O2JyZWFrfXc9LSh3PU1hdGguYWJzKG9bTV0tdyk8TWF0aC5hYnMob1tNLTFdLXcpfHxcIm5leHRcIj09PXQuc3dpcGVEaXJlY3Rpb24/b1tNXTpvW00tMV0pfWlmKFQmJnQub25jZShcInRyYW5zaXRpb25FbmRcIiwoZnVuY3Rpb24oKXt0Lmxvb3BGaXgoKX0pKSwwIT09dC52ZWxvY2l0eSl7aWYoZz1yP01hdGguYWJzKCgtdy10LnRyYW5zbGF0ZSkvdC52ZWxvY2l0eSk6TWF0aC5hYnMoKHctdC50cmFuc2xhdGUpL3QudmVsb2NpdHkpLGkuZnJlZU1vZGVTdGlja3kpe3ZhciBQPU1hdGguYWJzKChyPy13OncpLXQudHJhbnNsYXRlKSxrPXQuc2xpZGVzU2l6ZXNHcmlkW3QuYWN0aXZlSW5kZXhdO2c9UDxrP2kuc3BlZWQ6UDwyKms/MS41Kmkuc3BlZWQ6Mi41Kmkuc3BlZWR9fWVsc2UgaWYoaS5mcmVlTW9kZVN0aWNreSlyZXR1cm4gdm9pZCB0LnNsaWRlVG9DbG9zZXN0KCk7aS5mcmVlTW9kZU1vbWVudHVtQm91bmNlJiZDPyh0LnVwZGF0ZVByb2dyZXNzKGIpLHQuc2V0VHJhbnNpdGlvbihnKSx0LnNldFRyYW5zbGF0ZSh3KSx0LnRyYW5zaXRpb25TdGFydCghMCx0LnN3aXBlRGlyZWN0aW9uKSx0LmFuaW1hdGluZz0hMCxuLnRyYW5zaXRpb25FbmQoKGZ1bmN0aW9uKCl7dCYmIXQuZGVzdHJveWVkJiZhLmFsbG93TW9tZW50dW1Cb3VuY2UmJih0LmVtaXQoXCJtb21lbnR1bUJvdW5jZVwiKSx0LnNldFRyYW5zaXRpb24oaS5zcGVlZCksc2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnNldFRyYW5zbGF0ZShiKSxuLnRyYW5zaXRpb25FbmQoKGZ1bmN0aW9uKCl7dCYmIXQuZGVzdHJveWVkJiZ0LnRyYW5zaXRpb25FbmQoKX0pKX0pLDApKX0pKSk6dC52ZWxvY2l0eT8odC51cGRhdGVQcm9ncmVzcyh3KSx0LnNldFRyYW5zaXRpb24oZyksdC5zZXRUcmFuc2xhdGUodyksdC50cmFuc2l0aW9uU3RhcnQoITAsdC5zd2lwZURpcmVjdGlvbiksdC5hbmltYXRpbmd8fCh0LmFuaW1hdGluZz0hMCxuLnRyYW5zaXRpb25FbmQoKGZ1bmN0aW9uKCl7dCYmIXQuZGVzdHJveWVkJiZ0LnRyYW5zaXRpb25FbmQoKX0pKSkpOnQudXBkYXRlUHJvZ3Jlc3ModyksdC51cGRhdGVBY3RpdmVJbmRleCgpLHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpfWVsc2UgaWYoaS5mcmVlTW9kZVN0aWNreSlyZXR1cm4gdm9pZCB0LnNsaWRlVG9DbG9zZXN0KCk7KCFpLmZyZWVNb2RlTW9tZW50dW18fGM+PWkubG9uZ1N3aXBlc01zKSYmKHQudXBkYXRlUHJvZ3Jlc3MoKSx0LnVwZGF0ZUFjdGl2ZUluZGV4KCksdC51cGRhdGVTbGlkZXNDbGFzc2VzKCkpfWVsc2V7Zm9yKHZhciBMPTAsJD10LnNsaWRlc1NpemVzR3JpZFswXSxJPTA7STxsLmxlbmd0aDtJKz1JPGkuc2xpZGVzUGVyR3JvdXBTa2lwPzE6aS5zbGlkZXNQZXJHcm91cCl7dmFyIE89STxpLnNsaWRlc1Blckdyb3VwU2tpcC0xPzE6aS5zbGlkZXNQZXJHcm91cDt2b2lkIDAhPT1sW0krT10/cD49bFtJXSYmcDxsW0krT10mJihMPUksJD1sW0krT10tbFtJXSk6cD49bFtJXSYmKEw9SSwkPWxbbC5sZW5ndGgtMV0tbFtsLmxlbmd0aC0yXSl9dmFyIEE9KHAtbFtMXSkvJCxEPUw8aS5zbGlkZXNQZXJHcm91cFNraXAtMT8xOmkuc2xpZGVzUGVyR3JvdXA7aWYoYz5pLmxvbmdTd2lwZXNNcyl7aWYoIWkubG9uZ1N3aXBlcylyZXR1cm4gdm9pZCB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7XCJuZXh0XCI9PT10LnN3aXBlRGlyZWN0aW9uJiYoQT49aS5sb25nU3dpcGVzUmF0aW8/dC5zbGlkZVRvKEwrRCk6dC5zbGlkZVRvKEwpKSxcInByZXZcIj09PXQuc3dpcGVEaXJlY3Rpb24mJihBPjEtaS5sb25nU3dpcGVzUmF0aW8/dC5zbGlkZVRvKEwrRCk6dC5zbGlkZVRvKEwpKX1lbHNle2lmKCFpLnNob3J0U3dpcGVzKXJldHVybiB2b2lkIHQuc2xpZGVUbyh0LmFjdGl2ZUluZGV4KTt0Lm5hdmlnYXRpb24mJihkLnRhcmdldD09PXQubmF2aWdhdGlvbi5uZXh0RWx8fGQudGFyZ2V0PT09dC5uYXZpZ2F0aW9uLnByZXZFbCk/ZC50YXJnZXQ9PT10Lm5hdmlnYXRpb24ubmV4dEVsP3Quc2xpZGVUbyhMK0QpOnQuc2xpZGVUbyhMKTooXCJuZXh0XCI9PT10LnN3aXBlRGlyZWN0aW9uJiZ0LnNsaWRlVG8oTCtEKSxcInByZXZcIj09PXQuc3dpcGVEaXJlY3Rpb24mJnQuc2xpZGVUbyhMKSl9fX1mdW5jdGlvbiBHKCl7dmFyIGU9dGhpcyx0PWUucGFyYW1zLGE9ZS5lbDtpZighYXx8MCE9PWEub2Zmc2V0V2lkdGgpe3QuYnJlYWtwb2ludHMmJmUuc2V0QnJlYWtwb2ludCgpO3ZhciBpPWUuYWxsb3dTbGlkZU5leHQscz1lLmFsbG93U2xpZGVQcmV2LHI9ZS5zbmFwR3JpZDtlLmFsbG93U2xpZGVOZXh0PSEwLGUuYWxsb3dTbGlkZVByZXY9ITAsZS51cGRhdGVTaXplKCksZS51cGRhdGVTbGlkZXMoKSxlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwoXCJhdXRvXCI9PT10LnNsaWRlc1BlclZpZXd8fHQuc2xpZGVzUGVyVmlldz4xKSYmZS5pc0VuZCYmIWUuaXNCZWdpbm5pbmcmJiFlLnBhcmFtcy5jZW50ZXJlZFNsaWRlcz9lLnNsaWRlVG8oZS5zbGlkZXMubGVuZ3RoLTEsMCwhMSwhMCk6ZS5zbGlkZVRvKGUuYWN0aXZlSW5kZXgsMCwhMSwhMCksZS5hdXRvcGxheSYmZS5hdXRvcGxheS5ydW5uaW5nJiZlLmF1dG9wbGF5LnBhdXNlZCYmZS5hdXRvcGxheS5ydW4oKSxlLmFsbG93U2xpZGVQcmV2PXMsZS5hbGxvd1NsaWRlTmV4dD1pLGUucGFyYW1zLndhdGNoT3ZlcmZsb3cmJnIhPT1lLnNuYXBHcmlkJiZlLmNoZWNrT3ZlcmZsb3coKX19ZnVuY3Rpb24gTihlKXt2YXIgdD10aGlzO3QuYWxsb3dDbGlja3x8KHQucGFyYW1zLnByZXZlbnRDbGlja3MmJmUucHJldmVudERlZmF1bHQoKSx0LnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24mJnQuYW5pbWF0aW5nJiYoZS5zdG9wUHJvcGFnYXRpb24oKSxlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpKSl9ZnVuY3Rpb24gQigpe3ZhciBlPXRoaXMsdD1lLndyYXBwZXJFbCxhPWUucnRsVHJhbnNsYXRlO2UucHJldmlvdXNUcmFuc2xhdGU9ZS50cmFuc2xhdGUsZS5pc0hvcml6b250YWwoKT9lLnRyYW5zbGF0ZT1hP3Quc2Nyb2xsV2lkdGgtdC5vZmZzZXRXaWR0aC10LnNjcm9sbExlZnQ6LXQuc2Nyb2xsTGVmdDplLnRyYW5zbGF0ZT0tdC5zY3JvbGxUb3AsLTA9PT1lLnRyYW5zbGF0ZSYmKGUudHJhbnNsYXRlPTApLGUudXBkYXRlQWN0aXZlSW5kZXgoKSxlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTt2YXIgaT1lLm1heFRyYW5zbGF0ZSgpLWUubWluVHJhbnNsYXRlKCk7KDA9PT1pPzA6KGUudHJhbnNsYXRlLWUubWluVHJhbnNsYXRlKCkpL2kpIT09ZS5wcm9ncmVzcyYmZS51cGRhdGVQcm9ncmVzcyhhPy1lLnRyYW5zbGF0ZTplLnRyYW5zbGF0ZSksZS5lbWl0KFwic2V0VHJhbnNsYXRlXCIsZS50cmFuc2xhdGUsITEpfXZhciBIPSExO2Z1bmN0aW9uIFgoKXt9dmFyIFk9e2luaXQ6ITAsZGlyZWN0aW9uOlwiaG9yaXpvbnRhbFwiLHRvdWNoRXZlbnRzVGFyZ2V0OlwiY29udGFpbmVyXCIsaW5pdGlhbFNsaWRlOjAsc3BlZWQ6MzAwLGNzc01vZGU6ITEsdXBkYXRlT25XaW5kb3dSZXNpemU6ITAsbmVzdGVkOiExLHdpZHRoOm51bGwsaGVpZ2h0Om51bGwscHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uOiExLHVzZXJBZ2VudDpudWxsLHVybDpudWxsLGVkZ2VTd2lwZURldGVjdGlvbjohMSxlZGdlU3dpcGVUaHJlc2hvbGQ6MjAsZnJlZU1vZGU6ITEsZnJlZU1vZGVNb21lbnR1bTohMCxmcmVlTW9kZU1vbWVudHVtUmF0aW86MSxmcmVlTW9kZU1vbWVudHVtQm91bmNlOiEwLGZyZWVNb2RlTW9tZW50dW1Cb3VuY2VSYXRpbzoxLGZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvOjEsZnJlZU1vZGVTdGlja3k6ITEsZnJlZU1vZGVNaW5pbXVtVmVsb2NpdHk6LjAyLGF1dG9IZWlnaHQ6ITEsc2V0V3JhcHBlclNpemU6ITEsdmlydHVhbFRyYW5zbGF0ZTohMSxlZmZlY3Q6XCJzbGlkZVwiLGJyZWFrcG9pbnRzOnZvaWQgMCxzcGFjZUJldHdlZW46MCxzbGlkZXNQZXJWaWV3OjEsc2xpZGVzUGVyQ29sdW1uOjEsc2xpZGVzUGVyQ29sdW1uRmlsbDpcImNvbHVtblwiLHNsaWRlc1Blckdyb3VwOjEsc2xpZGVzUGVyR3JvdXBTa2lwOjAsY2VudGVyZWRTbGlkZXM6ITEsY2VudGVyZWRTbGlkZXNCb3VuZHM6ITEsc2xpZGVzT2Zmc2V0QmVmb3JlOjAsc2xpZGVzT2Zmc2V0QWZ0ZXI6MCxub3JtYWxpemVTbGlkZUluZGV4OiEwLGNlbnRlckluc3VmZmljaWVudFNsaWRlczohMSx3YXRjaE92ZXJmbG93OiExLHJvdW5kTGVuZ3RoczohMSx0b3VjaFJhdGlvOjEsdG91Y2hBbmdsZTo0NSxzaW11bGF0ZVRvdWNoOiEwLHNob3J0U3dpcGVzOiEwLGxvbmdTd2lwZXM6ITAsbG9uZ1N3aXBlc1JhdGlvOi41LGxvbmdTd2lwZXNNczozMDAsZm9sbG93RmluZ2VyOiEwLGFsbG93VG91Y2hNb3ZlOiEwLHRocmVzaG9sZDowLHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjohMSx0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ6ITAsdG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQ6ITEsdG91Y2hSZWxlYXNlT25FZGdlczohMSx1bmlxdWVOYXZFbGVtZW50czohMCxyZXNpc3RhbmNlOiEwLHJlc2lzdGFuY2VSYXRpbzouODUsd2F0Y2hTbGlkZXNQcm9ncmVzczohMSx3YXRjaFNsaWRlc1Zpc2liaWxpdHk6ITEsZ3JhYkN1cnNvcjohMSxwcmV2ZW50Q2xpY2tzOiEwLHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjohMCxzbGlkZVRvQ2xpY2tlZFNsaWRlOiExLHByZWxvYWRJbWFnZXM6ITAsdXBkYXRlT25JbWFnZXNSZWFkeTohMCxsb29wOiExLGxvb3BBZGRpdGlvbmFsU2xpZGVzOjAsbG9vcGVkU2xpZGVzOm51bGwsbG9vcEZpbGxHcm91cFdpdGhCbGFuazohMSxsb29wUHJldmVudHNTbGlkZTohMCxhbGxvd1NsaWRlUHJldjohMCxhbGxvd1NsaWRlTmV4dDohMCxzd2lwZUhhbmRsZXI6bnVsbCxub1N3aXBpbmc6ITAsbm9Td2lwaW5nQ2xhc3M6XCJzd2lwZXItbm8tc3dpcGluZ1wiLG5vU3dpcGluZ1NlbGVjdG9yOm51bGwscGFzc2l2ZUxpc3RlbmVyczohMCxjb250YWluZXJNb2RpZmllckNsYXNzOlwic3dpcGVyLWNvbnRhaW5lci1cIixzbGlkZUNsYXNzOlwic3dpcGVyLXNsaWRlXCIsc2xpZGVCbGFua0NsYXNzOlwic3dpcGVyLXNsaWRlLWludmlzaWJsZS1ibGFua1wiLHNsaWRlQWN0aXZlQ2xhc3M6XCJzd2lwZXItc2xpZGUtYWN0aXZlXCIsc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczpcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlXCIsc2xpZGVWaXNpYmxlQ2xhc3M6XCJzd2lwZXItc2xpZGUtdmlzaWJsZVwiLHNsaWRlRHVwbGljYXRlQ2xhc3M6XCJzd2lwZXItc2xpZGUtZHVwbGljYXRlXCIsc2xpZGVOZXh0Q2xhc3M6XCJzd2lwZXItc2xpZGUtbmV4dFwiLHNsaWRlRHVwbGljYXRlTmV4dENsYXNzOlwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1uZXh0XCIsc2xpZGVQcmV2Q2xhc3M6XCJzd2lwZXItc2xpZGUtcHJldlwiLHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOlwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2XCIsd3JhcHBlckNsYXNzOlwic3dpcGVyLXdyYXBwZXJcIixydW5DYWxsYmFja3NPbkluaXQ6ITAsX2VtaXRDbGFzc2VzOiExfSxWPXttb2R1bGFyOnt1c2VQYXJhbXM6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0Lm1vZHVsZXMmJk9iamVjdC5rZXlzKHQubW9kdWxlcykuZm9yRWFjaCgoZnVuY3Rpb24oYSl7dmFyIGk9dC5tb2R1bGVzW2FdO2kucGFyYW1zJiZTKGUsaS5wYXJhbXMpfSkpfSx1c2VNb2R1bGVzOmZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgdD10aGlzO3QubW9kdWxlcyYmT2JqZWN0LmtleXModC5tb2R1bGVzKS5mb3JFYWNoKChmdW5jdGlvbihhKXt2YXIgaT10Lm1vZHVsZXNbYV0scz1lW2FdfHx7fTtpLm9uJiZ0Lm9uJiZPYmplY3Qua2V5cyhpLm9uKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0Lm9uKGUsaS5vbltlXSl9KSksaS5jcmVhdGUmJmkuY3JlYXRlLmJpbmQodCkocyl9KSl9fSxldmVudHNFbWl0dGVyOntvbjpmdW5jdGlvbihlLHQsYSl7dmFyIGk9dGhpcztpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBpO3ZhciBzPWE/XCJ1bnNoaWZ0XCI6XCJwdXNoXCI7cmV0dXJuIGUuc3BsaXQoXCIgXCIpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2kuZXZlbnRzTGlzdGVuZXJzW2VdfHwoaS5ldmVudHNMaXN0ZW5lcnNbZV09W10pLGkuZXZlbnRzTGlzdGVuZXJzW2VdW3NdKHQpfSkpLGl9LG9uY2U6ZnVuY3Rpb24oZSx0LGEpe3ZhciBpPXRoaXM7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm4gaTtmdW5jdGlvbiBzKCl7aS5vZmYoZSxzKSxzLl9fZW1pdHRlclByb3h5JiZkZWxldGUgcy5fX2VtaXR0ZXJQcm94eTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShhKSxuPTA7bjxhO24rKylyW25dPWFyZ3VtZW50c1tuXTt0LmFwcGx5KGkscil9cmV0dXJuIHMuX19lbWl0dGVyUHJveHk9dCxpLm9uKGUscyxhKX0sb25Bbnk6ZnVuY3Rpb24oZSx0KXt2YXIgYT10aGlzO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpcmV0dXJuIGE7dmFyIGk9dD9cInVuc2hpZnRcIjpcInB1c2hcIjtyZXR1cm4gYS5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihlKTwwJiZhLmV2ZW50c0FueUxpc3RlbmVyc1tpXShlKSxhfSxvZmZBbnk6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdC5ldmVudHNBbnlMaXN0ZW5lcnMpcmV0dXJuIHQ7dmFyIGE9dC5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihlKTtyZXR1cm4gYT49MCYmdC5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGEsMSksdH0sb2ZmOmZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpcztyZXR1cm4gYS5ldmVudHNMaXN0ZW5lcnM/KGUuc3BsaXQoXCIgXCIpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZvaWQgMD09PXQ/YS5ldmVudHNMaXN0ZW5lcnNbZV09W106YS5ldmVudHNMaXN0ZW5lcnNbZV0mJmEuZXZlbnRzTGlzdGVuZXJzW2VdLmZvckVhY2goKGZ1bmN0aW9uKGkscyl7KGk9PT10fHxpLl9fZW1pdHRlclByb3h5JiZpLl9fZW1pdHRlclByb3h5PT09dCkmJmEuZXZlbnRzTGlzdGVuZXJzW2VdLnNwbGljZShzLDEpfSkpfSkpLGEpOmF9LGVtaXQ6ZnVuY3Rpb24oKXt2YXIgZSx0LGEsaT10aGlzO2lmKCFpLmV2ZW50c0xpc3RlbmVycylyZXR1cm4gaTtmb3IodmFyIHM9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShzKSxuPTA7bjxzO24rKylyW25dPWFyZ3VtZW50c1tuXTtcInN0cmluZ1wiPT10eXBlb2YgclswXXx8QXJyYXkuaXNBcnJheShyWzBdKT8oZT1yWzBdLHQ9ci5zbGljZSgxLHIubGVuZ3RoKSxhPWkpOihlPXJbMF0uZXZlbnRzLHQ9clswXS5kYXRhLGE9clswXS5jb250ZXh0fHxpKSx0LnVuc2hpZnQoYSk7dmFyIGw9QXJyYXkuaXNBcnJheShlKT9lOmUuc3BsaXQoXCIgXCIpO3JldHVybiBsLmZvckVhY2goKGZ1bmN0aW9uKGUpe2kuZXZlbnRzQW55TGlzdGVuZXJzJiZpLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgmJmkuZXZlbnRzQW55TGlzdGVuZXJzLmZvckVhY2goKGZ1bmN0aW9uKGkpe2kuYXBwbHkoYSxbZV0uY29uY2F0KHQpKX0pKSxpLmV2ZW50c0xpc3RlbmVycyYmaS5ldmVudHNMaXN0ZW5lcnNbZV0mJmkuZXZlbnRzTGlzdGVuZXJzW2VdLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UuYXBwbHkoYSx0KX0pKX0pKSxpfX0sdXBkYXRlOnt1cGRhdGVTaXplOmZ1bmN0aW9uKCl7dmFyIGUsdCxhPXRoaXMsaT1hLiRlbDtlPXZvaWQgMCE9PWEucGFyYW1zLndpZHRoJiZudWxsIT09YS5wYXJhbXMud2lkdGg/YS5wYXJhbXMud2lkdGg6aVswXS5jbGllbnRXaWR0aCx0PXZvaWQgMCE9PWEucGFyYW1zLmhlaWdodCYmbnVsbCE9PWEucGFyYW1zLmhlaWdodD9hLnBhcmFtcy5oZWlnaHQ6aVswXS5jbGllbnRIZWlnaHQsMD09PWUmJmEuaXNIb3Jpem9udGFsKCl8fDA9PT10JiZhLmlzVmVydGljYWwoKXx8KGU9ZS1wYXJzZUludChpLmNzcyhcInBhZGRpbmctbGVmdFwiKXx8MCwxMCktcGFyc2VJbnQoaS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpfHwwLDEwKSx0PXQtcGFyc2VJbnQoaS5jc3MoXCJwYWRkaW5nLXRvcFwiKXx8MCwxMCktcGFyc2VJbnQoaS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKXx8MCwxMCksTnVtYmVyLmlzTmFOKGUpJiYoZT0wKSxOdW1iZXIuaXNOYU4odCkmJih0PTApLFMoYSx7d2lkdGg6ZSxoZWlnaHQ6dCxzaXplOmEuaXNIb3Jpem9udGFsKCk/ZTp0fSkpfSx1cGRhdGVTbGlkZXM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9bCgpLGE9ZS5wYXJhbXMsaT1lLiR3cmFwcGVyRWwscz1lLnNpemUscj1lLnJ0bFRyYW5zbGF0ZSxuPWUud3JvbmdSVEwsbz1lLnZpcnR1YWwmJmEudmlydHVhbC5lbmFibGVkLGQ9bz9lLnZpcnR1YWwuc2xpZGVzLmxlbmd0aDplLnNsaWRlcy5sZW5ndGgscD1pLmNoaWxkcmVuKFwiLlwiK2UucGFyYW1zLnNsaWRlQ2xhc3MpLHU9bz9lLnZpcnR1YWwuc2xpZGVzLmxlbmd0aDpwLmxlbmd0aCxjPVtdLGg9W10sdj1bXTtmdW5jdGlvbiBmKGUsdCl7cmV0dXJuIWEuY3NzTW9kZXx8dCE9PXAubGVuZ3RoLTF9dmFyIG09YS5zbGlkZXNPZmZzZXRCZWZvcmU7XCJmdW5jdGlvblwiPT10eXBlb2YgbSYmKG09YS5zbGlkZXNPZmZzZXRCZWZvcmUuY2FsbChlKSk7dmFyIGc9YS5zbGlkZXNPZmZzZXRBZnRlcjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBnJiYoZz1hLnNsaWRlc09mZnNldEFmdGVyLmNhbGwoZSkpO3ZhciB5PWUuc25hcEdyaWQubGVuZ3RoLHc9ZS5zbGlkZXNHcmlkLmxlbmd0aCxiPWEuc3BhY2VCZXR3ZWVuLEU9LW0seD0wLFQ9MDtpZih2b2lkIDAhPT1zKXt2YXIgQyxNO1wic3RyaW5nXCI9PXR5cGVvZiBiJiZiLmluZGV4T2YoXCIlXCIpPj0wJiYoYj1wYXJzZUZsb2F0KGIucmVwbGFjZShcIiVcIixcIlwiKSkvMTAwKnMpLGUudmlydHVhbFNpemU9LWIscj9wLmNzcyh7bWFyZ2luTGVmdDpcIlwiLG1hcmdpblRvcDpcIlwifSk6cC5jc3Moe21hcmdpblJpZ2h0OlwiXCIsbWFyZ2luQm90dG9tOlwiXCJ9KSxhLnNsaWRlc1BlckNvbHVtbj4xJiYoQz1NYXRoLmZsb29yKHUvYS5zbGlkZXNQZXJDb2x1bW4pPT09dS9lLnBhcmFtcy5zbGlkZXNQZXJDb2x1bW4/dTpNYXRoLmNlaWwodS9hLnNsaWRlc1BlckNvbHVtbikqYS5zbGlkZXNQZXJDb2x1bW4sXCJhdXRvXCIhPT1hLnNsaWRlc1BlclZpZXcmJlwicm93XCI9PT1hLnNsaWRlc1BlckNvbHVtbkZpbGwmJihDPU1hdGgubWF4KEMsYS5zbGlkZXNQZXJWaWV3KmEuc2xpZGVzUGVyQ29sdW1uKSkpO2Zvcih2YXIgeixQPWEuc2xpZGVzUGVyQ29sdW1uLGs9Qy9QLEw9TWF0aC5mbG9vcih1L2Euc2xpZGVzUGVyQ29sdW1uKSwkPTA7JDx1OyQrPTEpe009MDt2YXIgST1wLmVxKCQpO2lmKGEuc2xpZGVzUGVyQ29sdW1uPjEpe3ZhciBPPXZvaWQgMCxBPXZvaWQgMCxEPXZvaWQgMDtpZihcInJvd1wiPT09YS5zbGlkZXNQZXJDb2x1bW5GaWxsJiZhLnNsaWRlc1Blckdyb3VwPjEpe3ZhciBHPU1hdGguZmxvb3IoJC8oYS5zbGlkZXNQZXJHcm91cCphLnNsaWRlc1BlckNvbHVtbikpLE49JC1hLnNsaWRlc1BlckNvbHVtbiphLnNsaWRlc1Blckdyb3VwKkcsQj0wPT09Rz9hLnNsaWRlc1Blckdyb3VwOk1hdGgubWluKE1hdGguY2VpbCgodS1HKlAqYS5zbGlkZXNQZXJHcm91cCkvUCksYS5zbGlkZXNQZXJHcm91cCk7Tz0oQT1OLShEPU1hdGguZmxvb3IoTi9CKSkqQitHKmEuc2xpZGVzUGVyR3JvdXApK0QqQy9QLEkuY3NzKHtcIi13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXBcIjpPLFwiLW1vei1ib3gtb3JkaW5hbC1ncm91cFwiOk8sXCItbXMtZmxleC1vcmRlclwiOk8sXCItd2Via2l0LW9yZGVyXCI6TyxvcmRlcjpPfSl9ZWxzZVwiY29sdW1uXCI9PT1hLnNsaWRlc1BlckNvbHVtbkZpbGw/KEQ9JC0oQT1NYXRoLmZsb29yKCQvUCkpKlAsKEE+THx8QT09PUwmJkQ9PT1QLTEpJiYoRCs9MSk+PVAmJihEPTAsQSs9MSkpOkE9JC0oRD1NYXRoLmZsb29yKCQvaykpKms7SS5jc3MoXCJtYXJnaW4tXCIrKGUuaXNIb3Jpem9udGFsKCk/XCJ0b3BcIjpcImxlZnRcIiksMCE9PUQmJmEuc3BhY2VCZXR3ZWVuJiZhLnNwYWNlQmV0d2VlbitcInB4XCIpfWlmKFwibm9uZVwiIT09SS5jc3MoXCJkaXNwbGF5XCIpKXtpZihcImF1dG9cIj09PWEuc2xpZGVzUGVyVmlldyl7dmFyIEg9dC5nZXRDb21wdXRlZFN0eWxlKElbMF0sbnVsbCksWD1JWzBdLnN0eWxlLnRyYW5zZm9ybSxZPUlbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtO2lmKFgmJihJWzBdLnN0eWxlLnRyYW5zZm9ybT1cIm5vbmVcIiksWSYmKElbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtPVwibm9uZVwiKSxhLnJvdW5kTGVuZ3RocylNPWUuaXNIb3Jpem9udGFsKCk/SS5vdXRlcldpZHRoKCEwKTpJLm91dGVySGVpZ2h0KCEwKTtlbHNlIGlmKGUuaXNIb3Jpem9udGFsKCkpe3ZhciBWPXBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIil8fDApLEY9cGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWxlZnRcIil8fDApLFI9cGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLXJpZ2h0XCIpfHwwKSxXPXBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWxlZnRcIil8fDApLHE9cGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tcmlnaHRcIil8fDApLGo9SC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTtpZihqJiZcImJvcmRlci1ib3hcIj09PWopTT1WK1crcTtlbHNle3ZhciBfPUlbMF0sVT1fLmNsaWVudFdpZHRoO009VitGK1IrVytxKyhfLm9mZnNldFdpZHRoLVUpfX1lbHNle3ZhciBLPXBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpfHwwKSxaPXBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy10b3BcIil8fDApLEo9cGFyc2VGbG9hdChILmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWJvdHRvbVwiKXx8MCksUT1wYXJzZUZsb2F0KEguZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi10b3BcIil8fDApLGVlPXBhcnNlRmxvYXQoSC5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWJvdHRvbVwiKXx8MCksdGU9SC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTtpZih0ZSYmXCJib3JkZXItYm94XCI9PT10ZSlNPUsrUStlZTtlbHNle3ZhciBhZT1JWzBdLGllPWFlLmNsaWVudEhlaWdodDtNPUsrWitKK1ErZWUrKGFlLm9mZnNldEhlaWdodC1pZSl9fVgmJihJWzBdLnN0eWxlLnRyYW5zZm9ybT1YKSxZJiYoSVswXS5zdHlsZS53ZWJraXRUcmFuc2Zvcm09WSksYS5yb3VuZExlbmd0aHMmJihNPU1hdGguZmxvb3IoTSkpfWVsc2UgTT0ocy0oYS5zbGlkZXNQZXJWaWV3LTEpKmIpL2Euc2xpZGVzUGVyVmlldyxhLnJvdW5kTGVuZ3RocyYmKE09TWF0aC5mbG9vcihNKSkscFskXSYmKGUuaXNIb3Jpem9udGFsKCk/cFskXS5zdHlsZS53aWR0aD1NK1wicHhcIjpwWyRdLnN0eWxlLmhlaWdodD1NK1wicHhcIik7cFskXSYmKHBbJF0uc3dpcGVyU2xpZGVTaXplPU0pLHYucHVzaChNKSxhLmNlbnRlcmVkU2xpZGVzPyhFPUUrTS8yK3gvMitiLDA9PT14JiYwIT09JCYmKEU9RS1zLzItYiksMD09PSQmJihFPUUtcy8yLWIpLE1hdGguYWJzKEUpPC4wMDEmJihFPTApLGEucm91bmRMZW5ndGhzJiYoRT1NYXRoLmZsb29yKEUpKSxUJWEuc2xpZGVzUGVyR3JvdXA9PTAmJmMucHVzaChFKSxoLnB1c2goRSkpOihhLnJvdW5kTGVuZ3RocyYmKEU9TWF0aC5mbG9vcihFKSksKFQtTWF0aC5taW4oZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLFQpKSVlLnBhcmFtcy5zbGlkZXNQZXJHcm91cD09MCYmYy5wdXNoKEUpLGgucHVzaChFKSxFPUUrTStiKSxlLnZpcnR1YWxTaXplKz1NK2IseD1NLFQrPTF9fWlmKGUudmlydHVhbFNpemU9TWF0aC5tYXgoZS52aXJ0dWFsU2l6ZSxzKStnLHImJm4mJihcInNsaWRlXCI9PT1hLmVmZmVjdHx8XCJjb3ZlcmZsb3dcIj09PWEuZWZmZWN0KSYmaS5jc3Moe3dpZHRoOmUudmlydHVhbFNpemUrYS5zcGFjZUJldHdlZW4rXCJweFwifSksYS5zZXRXcmFwcGVyU2l6ZSYmKGUuaXNIb3Jpem9udGFsKCk/aS5jc3Moe3dpZHRoOmUudmlydHVhbFNpemUrYS5zcGFjZUJldHdlZW4rXCJweFwifSk6aS5jc3Moe2hlaWdodDplLnZpcnR1YWxTaXplK2Euc3BhY2VCZXR3ZWVuK1wicHhcIn0pKSxhLnNsaWRlc1BlckNvbHVtbj4xJiYoZS52aXJ0dWFsU2l6ZT0oTSthLnNwYWNlQmV0d2VlbikqQyxlLnZpcnR1YWxTaXplPU1hdGguY2VpbChlLnZpcnR1YWxTaXplL2Euc2xpZGVzUGVyQ29sdW1uKS1hLnNwYWNlQmV0d2VlbixlLmlzSG9yaXpvbnRhbCgpP2kuY3NzKHt3aWR0aDplLnZpcnR1YWxTaXplK2Euc3BhY2VCZXR3ZWVuK1wicHhcIn0pOmkuY3NzKHtoZWlnaHQ6ZS52aXJ0dWFsU2l6ZSthLnNwYWNlQmV0d2VlbitcInB4XCJ9KSxhLmNlbnRlcmVkU2xpZGVzKSl7ej1bXTtmb3IodmFyIHNlPTA7c2U8Yy5sZW5ndGg7c2UrPTEpe3ZhciByZT1jW3NlXTthLnJvdW5kTGVuZ3RocyYmKHJlPU1hdGguZmxvb3IocmUpKSxjW3NlXTxlLnZpcnR1YWxTaXplK2NbMF0mJnoucHVzaChyZSl9Yz16fWlmKCFhLmNlbnRlcmVkU2xpZGVzKXt6PVtdO2Zvcih2YXIgbmU9MDtuZTxjLmxlbmd0aDtuZSs9MSl7dmFyIGxlPWNbbmVdO2Eucm91bmRMZW5ndGhzJiYobGU9TWF0aC5mbG9vcihsZSkpLGNbbmVdPD1lLnZpcnR1YWxTaXplLXMmJnoucHVzaChsZSl9Yz16LE1hdGguZmxvb3IoZS52aXJ0dWFsU2l6ZS1zKS1NYXRoLmZsb29yKGNbYy5sZW5ndGgtMV0pPjEmJmMucHVzaChlLnZpcnR1YWxTaXplLXMpfWlmKDA9PT1jLmxlbmd0aCYmKGM9WzBdKSwwIT09YS5zcGFjZUJldHdlZW4mJihlLmlzSG9yaXpvbnRhbCgpP3I/cC5maWx0ZXIoZikuY3NzKHttYXJnaW5MZWZ0OmIrXCJweFwifSk6cC5maWx0ZXIoZikuY3NzKHttYXJnaW5SaWdodDpiK1wicHhcIn0pOnAuZmlsdGVyKGYpLmNzcyh7bWFyZ2luQm90dG9tOmIrXCJweFwifSkpLGEuY2VudGVyZWRTbGlkZXMmJmEuY2VudGVyZWRTbGlkZXNCb3VuZHMpe3ZhciBvZT0wO3YuZm9yRWFjaCgoZnVuY3Rpb24oZSl7b2UrPWUrKGEuc3BhY2VCZXR3ZWVuP2Euc3BhY2VCZXR3ZWVuOjApfSkpO3ZhciBkZT0ob2UtPWEuc3BhY2VCZXR3ZWVuKS1zO2M9Yy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlPDA/LW06ZT5kZT9kZStnOmV9KSl9aWYoYS5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpe3ZhciBwZT0wO2lmKHYuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cGUrPWUrKGEuc3BhY2VCZXR3ZWVuP2Euc3BhY2VCZXR3ZWVuOjApfSkpLChwZS09YS5zcGFjZUJldHdlZW4pPHMpe3ZhciB1ZT0ocy1wZSkvMjtjLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7Y1t0XT1lLXVlfSkpLGguZm9yRWFjaCgoZnVuY3Rpb24oZSx0KXtoW3RdPWUrdWV9KSl9fVMoZSx7c2xpZGVzOnAsc25hcEdyaWQ6YyxzbGlkZXNHcmlkOmgsc2xpZGVzU2l6ZXNHcmlkOnZ9KSx1IT09ZCYmZS5lbWl0KFwic2xpZGVzTGVuZ3RoQ2hhbmdlXCIpLGMubGVuZ3RoIT09eSYmKGUucGFyYW1zLndhdGNoT3ZlcmZsb3cmJmUuY2hlY2tPdmVyZmxvdygpLGUuZW1pdChcInNuYXBHcmlkTGVuZ3RoQ2hhbmdlXCIpKSxoLmxlbmd0aCE9PXcmJmUuZW1pdChcInNsaWRlc0dyaWRMZW5ndGhDaGFuZ2VcIiksKGEud2F0Y2hTbGlkZXNQcm9ncmVzc3x8YS53YXRjaFNsaWRlc1Zpc2liaWxpdHkpJiZlLnVwZGF0ZVNsaWRlc09mZnNldCgpfX0sdXBkYXRlQXV0b0hlaWdodDpmdW5jdGlvbihlKXt2YXIgdCxhPXRoaXMsaT1bXSxzPTA7aWYoXCJudW1iZXJcIj09dHlwZW9mIGU/YS5zZXRUcmFuc2l0aW9uKGUpOiEwPT09ZSYmYS5zZXRUcmFuc2l0aW9uKGEucGFyYW1zLnNwZWVkKSxcImF1dG9cIiE9PWEucGFyYW1zLnNsaWRlc1BlclZpZXcmJmEucGFyYW1zLnNsaWRlc1BlclZpZXc+MSlpZihhLnBhcmFtcy5jZW50ZXJlZFNsaWRlcylhLnZpc2libGVTbGlkZXMuZWFjaCgoZnVuY3Rpb24oZSl7aS5wdXNoKGUpfSkpO2Vsc2UgZm9yKHQ9MDt0PE1hdGguY2VpbChhLnBhcmFtcy5zbGlkZXNQZXJWaWV3KTt0Kz0xKXt2YXIgcj1hLmFjdGl2ZUluZGV4K3Q7aWYocj5hLnNsaWRlcy5sZW5ndGgpYnJlYWs7aS5wdXNoKGEuc2xpZGVzLmVxKHIpWzBdKX1lbHNlIGkucHVzaChhLnNsaWRlcy5lcShhLmFjdGl2ZUluZGV4KVswXSk7Zm9yKHQ9MDt0PGkubGVuZ3RoO3QrPTEpaWYodm9pZCAwIT09aVt0XSl7dmFyIG49aVt0XS5vZmZzZXRIZWlnaHQ7cz1uPnM/bjpzfXMmJmEuJHdyYXBwZXJFbC5jc3MoXCJoZWlnaHRcIixzK1wicHhcIil9LHVwZGF0ZVNsaWRlc09mZnNldDpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLnNsaWRlcyx0PTA7dDxlLmxlbmd0aDt0Kz0xKWVbdF0uc3dpcGVyU2xpZGVPZmZzZXQ9dGhpcy5pc0hvcml6b250YWwoKT9lW3RdLm9mZnNldExlZnQ6ZVt0XS5vZmZzZXRUb3B9LHVwZGF0ZVNsaWRlc1Byb2dyZXNzOmZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUmJihlPXRoaXMmJnRoaXMudHJhbnNsYXRlfHwwKTt2YXIgdD10aGlzLGE9dC5wYXJhbXMsaT10LnNsaWRlcyxzPXQucnRsVHJhbnNsYXRlO2lmKDAhPT1pLmxlbmd0aCl7dm9pZCAwPT09aVswXS5zd2lwZXJTbGlkZU9mZnNldCYmdC51cGRhdGVTbGlkZXNPZmZzZXQoKTt2YXIgcj0tZTtzJiYocj1lKSxpLnJlbW92ZUNsYXNzKGEuc2xpZGVWaXNpYmxlQ2xhc3MpLHQudmlzaWJsZVNsaWRlc0luZGV4ZXM9W10sdC52aXNpYmxlU2xpZGVzPVtdO2Zvcih2YXIgbj0wO248aS5sZW5ndGg7bis9MSl7dmFyIGw9aVtuXSxvPShyKyhhLmNlbnRlcmVkU2xpZGVzP3QubWluVHJhbnNsYXRlKCk6MCktbC5zd2lwZXJTbGlkZU9mZnNldCkvKGwuc3dpcGVyU2xpZGVTaXplK2Euc3BhY2VCZXR3ZWVuKTtpZihhLndhdGNoU2xpZGVzVmlzaWJpbGl0eXx8YS5jZW50ZXJlZFNsaWRlcyYmYS5hdXRvSGVpZ2h0KXt2YXIgZD0tKHItbC5zd2lwZXJTbGlkZU9mZnNldCkscD1kK3Quc2xpZGVzU2l6ZXNHcmlkW25dOyhkPj0wJiZkPHQuc2l6ZS0xfHxwPjEmJnA8PXQuc2l6ZXx8ZDw9MCYmcD49dC5zaXplKSYmKHQudmlzaWJsZVNsaWRlcy5wdXNoKGwpLHQudmlzaWJsZVNsaWRlc0luZGV4ZXMucHVzaChuKSxpLmVxKG4pLmFkZENsYXNzKGEuc2xpZGVWaXNpYmxlQ2xhc3MpKX1sLnByb2dyZXNzPXM/LW86b310LnZpc2libGVTbGlkZXM9bSh0LnZpc2libGVTbGlkZXMpfX0sdXBkYXRlUHJvZ3Jlc3M6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih2b2lkIDA9PT1lKXt2YXIgYT10LnJ0bFRyYW5zbGF0ZT8tMToxO2U9dCYmdC50cmFuc2xhdGUmJnQudHJhbnNsYXRlKmF8fDB9dmFyIGk9dC5wYXJhbXMscz10Lm1heFRyYW5zbGF0ZSgpLXQubWluVHJhbnNsYXRlKCkscj10LnByb2dyZXNzLG49dC5pc0JlZ2lubmluZyxsPXQuaXNFbmQsbz1uLGQ9bDswPT09cz8ocj0wLG49ITAsbD0hMCk6KG49KHI9KGUtdC5taW5UcmFuc2xhdGUoKSkvcyk8PTAsbD1yPj0xKSxTKHQse3Byb2dyZXNzOnIsaXNCZWdpbm5pbmc6bixpc0VuZDpsfSksKGkud2F0Y2hTbGlkZXNQcm9ncmVzc3x8aS53YXRjaFNsaWRlc1Zpc2liaWxpdHl8fGkuY2VudGVyZWRTbGlkZXMmJmkuYXV0b0hlaWdodCkmJnQudXBkYXRlU2xpZGVzUHJvZ3Jlc3MoZSksbiYmIW8mJnQuZW1pdChcInJlYWNoQmVnaW5uaW5nIHRvRWRnZVwiKSxsJiYhZCYmdC5lbWl0KFwicmVhY2hFbmQgdG9FZGdlXCIpLChvJiYhbnx8ZCYmIWwpJiZ0LmVtaXQoXCJmcm9tRWRnZVwiKSx0LmVtaXQoXCJwcm9ncmVzc1wiLHIpfSx1cGRhdGVTbGlkZXNDbGFzc2VzOmZ1bmN0aW9uKCl7dmFyIGUsdD10aGlzLGE9dC5zbGlkZXMsaT10LnBhcmFtcyxzPXQuJHdyYXBwZXJFbCxyPXQuYWN0aXZlSW5kZXgsbj10LnJlYWxJbmRleCxsPXQudmlydHVhbCYmaS52aXJ0dWFsLmVuYWJsZWQ7YS5yZW1vdmVDbGFzcyhpLnNsaWRlQWN0aXZlQ2xhc3MrXCIgXCIraS5zbGlkZU5leHRDbGFzcytcIiBcIitpLnNsaWRlUHJldkNsYXNzK1wiIFwiK2kuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcytcIiBcIitpLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzK1wiIFwiK2kuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpLChlPWw/dC4kd3JhcHBlckVsLmZpbmQoXCIuXCIraS5zbGlkZUNsYXNzKydbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInK3IrJ1wiXScpOmEuZXEocikpLmFkZENsYXNzKGkuc2xpZGVBY3RpdmVDbGFzcyksaS5sb29wJiYoZS5oYXNDbGFzcyhpLnNsaWRlRHVwbGljYXRlQ2xhc3MpP3MuY2hpbGRyZW4oXCIuXCIraS5zbGlkZUNsYXNzK1wiOm5vdCguXCIraS5zbGlkZUR1cGxpY2F0ZUNsYXNzKycpW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytuKydcIl0nKS5hZGRDbGFzcyhpLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpOnMuY2hpbGRyZW4oXCIuXCIraS5zbGlkZUNsYXNzK1wiLlwiK2kuc2xpZGVEdXBsaWNhdGVDbGFzcysnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytuKydcIl0nKS5hZGRDbGFzcyhpLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpKTt2YXIgbz1lLm5leHRBbGwoXCIuXCIraS5zbGlkZUNsYXNzKS5lcSgwKS5hZGRDbGFzcyhpLnNsaWRlTmV4dENsYXNzKTtpLmxvb3AmJjA9PT1vLmxlbmd0aCYmKG89YS5lcSgwKSkuYWRkQ2xhc3MoaS5zbGlkZU5leHRDbGFzcyk7dmFyIGQ9ZS5wcmV2QWxsKFwiLlwiK2kuc2xpZGVDbGFzcykuZXEoMCkuYWRkQ2xhc3MoaS5zbGlkZVByZXZDbGFzcyk7aS5sb29wJiYwPT09ZC5sZW5ndGgmJihkPWEuZXEoLTEpKS5hZGRDbGFzcyhpLnNsaWRlUHJldkNsYXNzKSxpLmxvb3AmJihvLmhhc0NsYXNzKGkuc2xpZGVEdXBsaWNhdGVDbGFzcyk/cy5jaGlsZHJlbihcIi5cIitpLnNsaWRlQ2xhc3MrXCI6bm90KC5cIitpLnNsaWRlRHVwbGljYXRlQ2xhc3MrJylbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInK28uYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpKydcIl0nKS5hZGRDbGFzcyhpLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKTpzLmNoaWxkcmVuKFwiLlwiK2kuc2xpZGVDbGFzcytcIi5cIitpLnNsaWRlRHVwbGljYXRlQ2xhc3MrJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrby5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikrJ1wiXScpLmFkZENsYXNzKGkuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpLGQuaGFzQ2xhc3MoaS5zbGlkZUR1cGxpY2F0ZUNsYXNzKT9zLmNoaWxkcmVuKFwiLlwiK2kuc2xpZGVDbGFzcytcIjpub3QoLlwiK2kuc2xpZGVEdXBsaWNhdGVDbGFzcysnKVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrZC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikrJ1wiXScpLmFkZENsYXNzKGkuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpOnMuY2hpbGRyZW4oXCIuXCIraS5zbGlkZUNsYXNzK1wiLlwiK2kuc2xpZGVEdXBsaWNhdGVDbGFzcysnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytkLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSsnXCJdJykuYWRkQ2xhc3MoaS5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcykpLHQuZW1pdFNsaWRlc0NsYXNzZXMoKX0sdXBkYXRlQWN0aXZlSW5kZXg6ZnVuY3Rpb24oZSl7dmFyIHQsYT10aGlzLGk9YS5ydGxUcmFuc2xhdGU/YS50cmFuc2xhdGU6LWEudHJhbnNsYXRlLHM9YS5zbGlkZXNHcmlkLHI9YS5zbmFwR3JpZCxuPWEucGFyYW1zLGw9YS5hY3RpdmVJbmRleCxvPWEucmVhbEluZGV4LGQ9YS5zbmFwSW5kZXgscD1lO2lmKHZvaWQgMD09PXApe2Zvcih2YXIgdT0wO3U8cy5sZW5ndGg7dSs9MSl2b2lkIDAhPT1zW3UrMV0/aT49c1t1XSYmaTxzW3UrMV0tKHNbdSsxXS1zW3VdKS8yP3A9dTppPj1zW3VdJiZpPHNbdSsxXSYmKHA9dSsxKTppPj1zW3VdJiYocD11KTtuLm5vcm1hbGl6ZVNsaWRlSW5kZXgmJihwPDB8fHZvaWQgMD09PXApJiYocD0wKX1pZihyLmluZGV4T2YoaSk+PTApdD1yLmluZGV4T2YoaSk7ZWxzZXt2YXIgYz1NYXRoLm1pbihuLnNsaWRlc1Blckdyb3VwU2tpcCxwKTt0PWMrTWF0aC5mbG9vcigocC1jKS9uLnNsaWRlc1Blckdyb3VwKX1pZih0Pj1yLmxlbmd0aCYmKHQ9ci5sZW5ndGgtMSkscCE9PWwpe3ZhciBoPXBhcnNlSW50KGEuc2xpZGVzLmVxKHApLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKXx8cCwxMCk7UyhhLHtzbmFwSW5kZXg6dCxyZWFsSW5kZXg6aCxwcmV2aW91c0luZGV4OmwsYWN0aXZlSW5kZXg6cH0pLGEuZW1pdChcImFjdGl2ZUluZGV4Q2hhbmdlXCIpLGEuZW1pdChcInNuYXBJbmRleENoYW5nZVwiKSxvIT09aCYmYS5lbWl0KFwicmVhbEluZGV4Q2hhbmdlXCIpLChhLmluaXRpYWxpemVkfHxhLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpJiZhLmVtaXQoXCJzbGlkZUNoYW5nZVwiKX1lbHNlIHQhPT1kJiYoYS5zbmFwSW5kZXg9dCxhLmVtaXQoXCJzbmFwSW5kZXhDaGFuZ2VcIikpfSx1cGRhdGVDbGlja2VkU2xpZGU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQucGFyYW1zLGk9bShlLnRhcmdldCkuY2xvc2VzdChcIi5cIithLnNsaWRlQ2xhc3MpWzBdLHM9ITE7aWYoaSlmb3IodmFyIHI9MDtyPHQuc2xpZGVzLmxlbmd0aDtyKz0xKXQuc2xpZGVzW3JdPT09aSYmKHM9ITApO2lmKCFpfHwhcylyZXR1cm4gdC5jbGlja2VkU2xpZGU9dm9pZCAwLHZvaWQodC5jbGlja2VkSW5kZXg9dm9pZCAwKTt0LmNsaWNrZWRTbGlkZT1pLHQudmlydHVhbCYmdC5wYXJhbXMudmlydHVhbC5lbmFibGVkP3QuY2xpY2tlZEluZGV4PXBhcnNlSW50KG0oaSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLDEwKTp0LmNsaWNrZWRJbmRleD1tKGkpLmluZGV4KCksYS5zbGlkZVRvQ2xpY2tlZFNsaWRlJiZ2b2lkIDAhPT10LmNsaWNrZWRJbmRleCYmdC5jbGlja2VkSW5kZXghPT10LmFjdGl2ZUluZGV4JiZ0LnNsaWRlVG9DbGlja2VkU2xpZGUoKX19LHRyYW5zbGF0ZTp7Z2V0VHJhbnNsYXRlOmZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUmJihlPXRoaXMuaXNIb3Jpem9udGFsKCk/XCJ4XCI6XCJ5XCIpO3ZhciB0PXRoaXMsYT10LnBhcmFtcyxpPXQucnRsVHJhbnNsYXRlLHM9dC50cmFuc2xhdGUscj10LiR3cmFwcGVyRWw7aWYoYS52aXJ0dWFsVHJhbnNsYXRlKXJldHVybiBpPy1zOnM7aWYoYS5jc3NNb2RlKXJldHVybiBzO3ZhciBuPVQoclswXSxlKTtyZXR1cm4gaSYmKG49LW4pLG58fDB9LHNldFRyYW5zbGF0ZTpmdW5jdGlvbihlLHQpe3ZhciBhPXRoaXMsaT1hLnJ0bFRyYW5zbGF0ZSxzPWEucGFyYW1zLHI9YS4kd3JhcHBlckVsLG49YS53cmFwcGVyRWwsbD1hLnByb2dyZXNzLG89MCxkPTA7YS5pc0hvcml6b250YWwoKT9vPWk/LWU6ZTpkPWUscy5yb3VuZExlbmd0aHMmJihvPU1hdGguZmxvb3IobyksZD1NYXRoLmZsb29yKGQpKSxzLmNzc01vZGU/blthLmlzSG9yaXpvbnRhbCgpP1wic2Nyb2xsTGVmdFwiOlwic2Nyb2xsVG9wXCJdPWEuaXNIb3Jpem9udGFsKCk/LW86LWQ6cy52aXJ0dWFsVHJhbnNsYXRlfHxyLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiK28rXCJweCwgXCIrZCtcInB4LCAwcHgpXCIpLGEucHJldmlvdXNUcmFuc2xhdGU9YS50cmFuc2xhdGUsYS50cmFuc2xhdGU9YS5pc0hvcml6b250YWwoKT9vOmQ7dmFyIHA9YS5tYXhUcmFuc2xhdGUoKS1hLm1pblRyYW5zbGF0ZSgpOygwPT09cD8wOihlLWEubWluVHJhbnNsYXRlKCkpL3ApIT09bCYmYS51cGRhdGVQcm9ncmVzcyhlKSxhLmVtaXQoXCJzZXRUcmFuc2xhdGVcIixhLnRyYW5zbGF0ZSx0KX0sbWluVHJhbnNsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuLXRoaXMuc25hcEdyaWRbMF19LG1heFRyYW5zbGF0ZTpmdW5jdGlvbigpe3JldHVybi10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoLTFdfSx0cmFuc2xhdGVUbzpmdW5jdGlvbihlLHQsYSxpLHMpe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PXQmJih0PXRoaXMucGFyYW1zLnNwZWVkKSx2b2lkIDA9PT1hJiYoYT0hMCksdm9pZCAwPT09aSYmKGk9ITApO3ZhciByPXRoaXMsbj1yLnBhcmFtcyxsPXIud3JhcHBlckVsO2lmKHIuYW5pbWF0aW5nJiZuLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbilyZXR1cm4hMTt2YXIgbyxkPXIubWluVHJhbnNsYXRlKCkscD1yLm1heFRyYW5zbGF0ZSgpO2lmKG89aSYmZT5kP2Q6aSYmZTxwP3A6ZSxyLnVwZGF0ZVByb2dyZXNzKG8pLG4uY3NzTW9kZSl7dmFyIHUsYz1yLmlzSG9yaXpvbnRhbCgpO2lmKDA9PT10KWxbYz9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT0tbztlbHNlIGlmKGwuc2Nyb2xsVG8pbC5zY3JvbGxUbygoKHU9e30pW2M/XCJsZWZ0XCI6XCJ0b3BcIl09LW8sdS5iZWhhdmlvcj1cInNtb290aFwiLHUpKTtlbHNlIGxbYz9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT0tbztyZXR1cm4hMH1yZXR1cm4gMD09PXQ/KHIuc2V0VHJhbnNpdGlvbigwKSxyLnNldFRyYW5zbGF0ZShvKSxhJiYoci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsdCxzKSxyLmVtaXQoXCJ0cmFuc2l0aW9uRW5kXCIpKSk6KHIuc2V0VHJhbnNpdGlvbih0KSxyLnNldFRyYW5zbGF0ZShvKSxhJiYoci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsdCxzKSxyLmVtaXQoXCJ0cmFuc2l0aW9uU3RhcnRcIikpLHIuYW5pbWF0aW5nfHwoci5hbmltYXRpbmc9ITAsci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmR8fChyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZD1mdW5jdGlvbihlKXtyJiYhci5kZXN0cm95ZWQmJmUudGFyZ2V0PT09dGhpcyYmKHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSxyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIixyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCksci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ9bnVsbCxkZWxldGUgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQsYSYmci5lbWl0KFwidHJhbnNpdGlvbkVuZFwiKSl9KSxyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIixyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCksci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpKSksITB9fSx0cmFuc2l0aW9uOntzZXRUcmFuc2l0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpczthLnBhcmFtcy5jc3NNb2RlfHxhLiR3cmFwcGVyRWwudHJhbnNpdGlvbihlKSxhLmVtaXQoXCJzZXRUcmFuc2l0aW9uXCIsZSx0KX0sdHJhbnNpdGlvblN0YXJ0OmZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09ZSYmKGU9ITApO3ZhciBhPXRoaXMsaT1hLmFjdGl2ZUluZGV4LHM9YS5wYXJhbXMscj1hLnByZXZpb3VzSW5kZXg7aWYoIXMuY3NzTW9kZSl7cy5hdXRvSGVpZ2h0JiZhLnVwZGF0ZUF1dG9IZWlnaHQoKTt2YXIgbj10O2lmKG58fChuPWk+cj9cIm5leHRcIjppPHI/XCJwcmV2XCI6XCJyZXNldFwiKSxhLmVtaXQoXCJ0cmFuc2l0aW9uU3RhcnRcIiksZSYmaSE9PXIpe2lmKFwicmVzZXRcIj09PW4pcmV0dXJuIHZvaWQgYS5lbWl0KFwic2xpZGVSZXNldFRyYW5zaXRpb25TdGFydFwiKTthLmVtaXQoXCJzbGlkZUNoYW5nZVRyYW5zaXRpb25TdGFydFwiKSxcIm5leHRcIj09PW4/YS5lbWl0KFwic2xpZGVOZXh0VHJhbnNpdGlvblN0YXJ0XCIpOmEuZW1pdChcInNsaWRlUHJldlRyYW5zaXRpb25TdGFydFwiKX19fSx0cmFuc2l0aW9uRW5kOmZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09ZSYmKGU9ITApO3ZhciBhPXRoaXMsaT1hLmFjdGl2ZUluZGV4LHM9YS5wcmV2aW91c0luZGV4LHI9YS5wYXJhbXM7aWYoYS5hbmltYXRpbmc9ITEsIXIuY3NzTW9kZSl7YS5zZXRUcmFuc2l0aW9uKDApO3ZhciBuPXQ7aWYobnx8KG49aT5zP1wibmV4dFwiOmk8cz9cInByZXZcIjpcInJlc2V0XCIpLGEuZW1pdChcInRyYW5zaXRpb25FbmRcIiksZSYmaSE9PXMpe2lmKFwicmVzZXRcIj09PW4pcmV0dXJuIHZvaWQgYS5lbWl0KFwic2xpZGVSZXNldFRyYW5zaXRpb25FbmRcIik7YS5lbWl0KFwic2xpZGVDaGFuZ2VUcmFuc2l0aW9uRW5kXCIpLFwibmV4dFwiPT09bj9hLmVtaXQoXCJzbGlkZU5leHRUcmFuc2l0aW9uRW5kXCIpOmEuZW1pdChcInNsaWRlUHJldlRyYW5zaXRpb25FbmRcIil9fX19LHNsaWRlOntzbGlkZVRvOmZ1bmN0aW9uKGUsdCxhLGkpe2lmKHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PXQmJih0PXRoaXMucGFyYW1zLnNwZWVkKSx2b2lkIDA9PT1hJiYoYT0hMCksXCJudW1iZXJcIiE9dHlwZW9mIGUmJlwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIlRoZSAnaW5kZXgnIGFyZ3VtZW50IGNhbm5vdCBoYXZlIHR5cGUgb3RoZXIgdGhhbiAnbnVtYmVyJyBvciAnc3RyaW5nJy4gW1wiK3R5cGVvZiBlK1wiXSBnaXZlbi5cIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBzPXBhcnNlSW50KGUsMTApO2lmKCFpc0Zpbml0ZShzKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFzc2VkLWluICdpbmRleCcgKHN0cmluZykgY291bGRuJ3QgYmUgY29udmVydGVkIHRvICdudW1iZXInLiBbXCIrZStcIl0gZ2l2ZW4uXCIpO2U9c312YXIgcj10aGlzLG49ZTtuPDAmJihuPTApO3ZhciBsPXIucGFyYW1zLG89ci5zbmFwR3JpZCxkPXIuc2xpZGVzR3JpZCxwPXIucHJldmlvdXNJbmRleCx1PXIuYWN0aXZlSW5kZXgsYz1yLnJ0bFRyYW5zbGF0ZSxoPXIud3JhcHBlckVsO2lmKHIuYW5pbWF0aW5nJiZsLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbilyZXR1cm4hMTt2YXIgdj1NYXRoLm1pbihyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsbiksZj12K01hdGguZmxvb3IoKG4tdikvci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO2Y+PW8ubGVuZ3RoJiYoZj1vLmxlbmd0aC0xKSwodXx8bC5pbml0aWFsU2xpZGV8fDApPT09KHB8fDApJiZhJiZyLmVtaXQoXCJiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0XCIpO3ZhciBtLGc9LW9bZl07aWYoci51cGRhdGVQcm9ncmVzcyhnKSxsLm5vcm1hbGl6ZVNsaWRlSW5kZXgpZm9yKHZhciB5PTA7eTxkLmxlbmd0aDt5Kz0xKS1NYXRoLmZsb29yKDEwMCpnKT49TWF0aC5mbG9vcigxMDAqZFt5XSkmJihuPXkpO2lmKHIuaW5pdGlhbGl6ZWQmJm4hPT11KXtpZighci5hbGxvd1NsaWRlTmV4dCYmZzxyLnRyYW5zbGF0ZSYmZzxyLm1pblRyYW5zbGF0ZSgpKXJldHVybiExO2lmKCFyLmFsbG93U2xpZGVQcmV2JiZnPnIudHJhbnNsYXRlJiZnPnIubWF4VHJhbnNsYXRlKCkmJih1fHwwKSE9PW4pcmV0dXJuITF9aWYobT1uPnU/XCJuZXh0XCI6bjx1P1wicHJldlwiOlwicmVzZXRcIixjJiYtZz09PXIudHJhbnNsYXRlfHwhYyYmZz09PXIudHJhbnNsYXRlKXJldHVybiByLnVwZGF0ZUFjdGl2ZUluZGV4KG4pLGwuYXV0b0hlaWdodCYmci51cGRhdGVBdXRvSGVpZ2h0KCksci51cGRhdGVTbGlkZXNDbGFzc2VzKCksXCJzbGlkZVwiIT09bC5lZmZlY3QmJnIuc2V0VHJhbnNsYXRlKGcpLFwicmVzZXRcIiE9PW0mJihyLnRyYW5zaXRpb25TdGFydChhLG0pLHIudHJhbnNpdGlvbkVuZChhLG0pKSwhMTtpZihsLmNzc01vZGUpe3ZhciB3LGI9ci5pc0hvcml6b250YWwoKSxFPS1nO2lmKGMmJihFPWguc2Nyb2xsV2lkdGgtaC5vZmZzZXRXaWR0aC1FKSwwPT09dCloW2I/XCJzY3JvbGxMZWZ0XCI6XCJzY3JvbGxUb3BcIl09RTtlbHNlIGlmKGguc2Nyb2xsVG8paC5zY3JvbGxUbygoKHc9e30pW2I/XCJsZWZ0XCI6XCJ0b3BcIl09RSx3LmJlaGF2aW9yPVwic21vb3RoXCIsdykpO2Vsc2UgaFtiP1wic2Nyb2xsTGVmdFwiOlwic2Nyb2xsVG9wXCJdPUU7cmV0dXJuITB9cmV0dXJuIDA9PT10PyhyLnNldFRyYW5zaXRpb24oMCksci5zZXRUcmFuc2xhdGUoZyksci51cGRhdGVBY3RpdmVJbmRleChuKSxyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSxyLmVtaXQoXCJiZWZvcmVUcmFuc2l0aW9uU3RhcnRcIix0LGkpLHIudHJhbnNpdGlvblN0YXJ0KGEsbSksci50cmFuc2l0aW9uRW5kKGEsbSkpOihyLnNldFRyYW5zaXRpb24odCksci5zZXRUcmFuc2xhdGUoZyksci51cGRhdGVBY3RpdmVJbmRleChuKSxyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSxyLmVtaXQoXCJiZWZvcmVUcmFuc2l0aW9uU3RhcnRcIix0LGkpLHIudHJhbnNpdGlvblN0YXJ0KGEsbSksci5hbmltYXRpbmd8fChyLmFuaW1hdGluZz0hMCxyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kfHwoci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZD1mdW5jdGlvbihlKXtyJiYhci5kZXN0cm95ZWQmJmUudGFyZ2V0PT09dGhpcyYmKHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ9bnVsbCxkZWxldGUgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCxyLnRyYW5zaXRpb25FbmQoYSxtKSl9KSxyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIixyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSxyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIixyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSkpLCEwfSxzbGlkZVRvTG9vcDpmdW5jdGlvbihlLHQsYSxpKXt2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT10JiYodD10aGlzLnBhcmFtcy5zcGVlZCksdm9pZCAwPT09YSYmKGE9ITApO3ZhciBzPXRoaXMscj1lO3JldHVybiBzLnBhcmFtcy5sb29wJiYocis9cy5sb29wZWRTbGlkZXMpLHMuc2xpZGVUbyhyLHQsYSxpKX0sc2xpZGVOZXh0OmZ1bmN0aW9uKGUsdCxhKXt2b2lkIDA9PT1lJiYoZT10aGlzLnBhcmFtcy5zcGVlZCksdm9pZCAwPT09dCYmKHQ9ITApO3ZhciBpPXRoaXMscz1pLnBhcmFtcyxyPWkuYW5pbWF0aW5nLG49aS5hY3RpdmVJbmRleDxzLnNsaWRlc1Blckdyb3VwU2tpcD8xOnMuc2xpZGVzUGVyR3JvdXA7aWYocy5sb29wKXtpZihyJiZzLmxvb3BQcmV2ZW50c1NsaWRlKXJldHVybiExO2kubG9vcEZpeCgpLGkuX2NsaWVudExlZnQ9aS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnR9cmV0dXJuIGkuc2xpZGVUbyhpLmFjdGl2ZUluZGV4K24sZSx0LGEpfSxzbGlkZVByZXY6ZnVuY3Rpb24oZSx0LGEpe3ZvaWQgMD09PWUmJihlPXRoaXMucGFyYW1zLnNwZWVkKSx2b2lkIDA9PT10JiYodD0hMCk7dmFyIGk9dGhpcyxzPWkucGFyYW1zLHI9aS5hbmltYXRpbmcsbj1pLnNuYXBHcmlkLGw9aS5zbGlkZXNHcmlkLG89aS5ydGxUcmFuc2xhdGU7aWYocy5sb29wKXtpZihyJiZzLmxvb3BQcmV2ZW50c1NsaWRlKXJldHVybiExO2kubG9vcEZpeCgpLGkuX2NsaWVudExlZnQ9aS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnR9ZnVuY3Rpb24gZChlKXtyZXR1cm4gZTwwPy1NYXRoLmZsb29yKE1hdGguYWJzKGUpKTpNYXRoLmZsb29yKGUpfXZhciBwLHU9ZChvP2kudHJhbnNsYXRlOi1pLnRyYW5zbGF0ZSksYz1uLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGQoZSl9KSksaD0obltjLmluZGV4T2YodSldLG5bYy5pbmRleE9mKHUpLTFdKTtyZXR1cm4gdm9pZCAwPT09aCYmcy5jc3NNb2RlJiZuLmZvckVhY2goKGZ1bmN0aW9uKGUpeyFoJiZ1Pj1lJiYoaD1lKX0pKSx2b2lkIDAhPT1oJiYocD1sLmluZGV4T2YoaCkpPDAmJihwPWkuYWN0aXZlSW5kZXgtMSksaS5zbGlkZVRvKHAsZSx0LGEpfSxzbGlkZVJlc2V0OmZ1bmN0aW9uKGUsdCxhKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9dGhpcy5wYXJhbXMuc3BlZWQpLHZvaWQgMD09PXQmJih0PSEwKSx0aGlzLnNsaWRlVG8odGhpcy5hY3RpdmVJbmRleCxlLHQsYSl9LHNsaWRlVG9DbG9zZXN0OmZ1bmN0aW9uKGUsdCxhLGkpe3ZvaWQgMD09PWUmJihlPXRoaXMucGFyYW1zLnNwZWVkKSx2b2lkIDA9PT10JiYodD0hMCksdm9pZCAwPT09aSYmKGk9LjUpO3ZhciBzPXRoaXMscj1zLmFjdGl2ZUluZGV4LG49TWF0aC5taW4ocy5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLHIpLGw9bitNYXRoLmZsb29yKChyLW4pL3MucGFyYW1zLnNsaWRlc1Blckdyb3VwKSxvPXMucnRsVHJhbnNsYXRlP3MudHJhbnNsYXRlOi1zLnRyYW5zbGF0ZTtpZihvPj1zLnNuYXBHcmlkW2xdKXt2YXIgZD1zLnNuYXBHcmlkW2xdO28tZD4ocy5zbmFwR3JpZFtsKzFdLWQpKmkmJihyKz1zLnBhcmFtcy5zbGlkZXNQZXJHcm91cCl9ZWxzZXt2YXIgcD1zLnNuYXBHcmlkW2wtMV07by1wPD0ocy5zbmFwR3JpZFtsXS1wKSppJiYoci09cy5wYXJhbXMuc2xpZGVzUGVyR3JvdXApfXJldHVybiByPU1hdGgubWF4KHIsMCkscj1NYXRoLm1pbihyLHMuc2xpZGVzR3JpZC5sZW5ndGgtMSkscy5zbGlkZVRvKHIsZSx0LGEpfSxzbGlkZVRvQ2xpY2tlZFNsaWRlOmZ1bmN0aW9uKCl7dmFyIGUsdD10aGlzLGE9dC5wYXJhbXMsaT10LiR3cmFwcGVyRWwscz1cImF1dG9cIj09PWEuc2xpZGVzUGVyVmlldz90LnNsaWRlc1BlclZpZXdEeW5hbWljKCk6YS5zbGlkZXNQZXJWaWV3LHI9dC5jbGlja2VkSW5kZXg7aWYoYS5sb29wKXtpZih0LmFuaW1hdGluZylyZXR1cm47ZT1wYXJzZUludChtKHQuY2xpY2tlZFNsaWRlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksMTApLGEuY2VudGVyZWRTbGlkZXM/cjx0Lmxvb3BlZFNsaWRlcy1zLzJ8fHI+dC5zbGlkZXMubGVuZ3RoLXQubG9vcGVkU2xpZGVzK3MvMj8odC5sb29wRml4KCkscj1pLmNoaWxkcmVuKFwiLlwiK2Euc2xpZGVDbGFzcysnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytlKydcIl06bm90KC4nK2Euc2xpZGVEdXBsaWNhdGVDbGFzcytcIilcIikuZXEoMCkuaW5kZXgoKSxFKChmdW5jdGlvbigpe3Quc2xpZGVUbyhyKX0pKSk6dC5zbGlkZVRvKHIpOnI+dC5zbGlkZXMubGVuZ3RoLXM/KHQubG9vcEZpeCgpLHI9aS5jaGlsZHJlbihcIi5cIithLnNsaWRlQ2xhc3MrJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrZSsnXCJdOm5vdCguJythLnNsaWRlRHVwbGljYXRlQ2xhc3MrXCIpXCIpLmVxKDApLmluZGV4KCksRSgoZnVuY3Rpb24oKXt0LnNsaWRlVG8ocil9KSkpOnQuc2xpZGVUbyhyKX1lbHNlIHQuc2xpZGVUbyhyKX19LGxvb3A6e2xvb3BDcmVhdGU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9cigpLGE9ZS5wYXJhbXMsaT1lLiR3cmFwcGVyRWw7aS5jaGlsZHJlbihcIi5cIithLnNsaWRlQ2xhc3MrXCIuXCIrYS5zbGlkZUR1cGxpY2F0ZUNsYXNzKS5yZW1vdmUoKTt2YXIgcz1pLmNoaWxkcmVuKFwiLlwiK2Euc2xpZGVDbGFzcyk7aWYoYS5sb29wRmlsbEdyb3VwV2l0aEJsYW5rKXt2YXIgbj1hLnNsaWRlc1Blckdyb3VwLXMubGVuZ3RoJWEuc2xpZGVzUGVyR3JvdXA7aWYobiE9PWEuc2xpZGVzUGVyR3JvdXApe2Zvcih2YXIgbD0wO2w8bjtsKz0xKXt2YXIgbz1tKHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYWRkQ2xhc3MoYS5zbGlkZUNsYXNzK1wiIFwiK2Euc2xpZGVCbGFua0NsYXNzKTtpLmFwcGVuZChvKX1zPWkuY2hpbGRyZW4oXCIuXCIrYS5zbGlkZUNsYXNzKX19XCJhdXRvXCIhPT1hLnNsaWRlc1BlclZpZXd8fGEubG9vcGVkU2xpZGVzfHwoYS5sb29wZWRTbGlkZXM9cy5sZW5ndGgpLGUubG9vcGVkU2xpZGVzPU1hdGguY2VpbChwYXJzZUZsb2F0KGEubG9vcGVkU2xpZGVzfHxhLnNsaWRlc1BlclZpZXcsMTApKSxlLmxvb3BlZFNsaWRlcys9YS5sb29wQWRkaXRpb25hbFNsaWRlcyxlLmxvb3BlZFNsaWRlcz5zLmxlbmd0aCYmKGUubG9vcGVkU2xpZGVzPXMubGVuZ3RoKTt2YXIgZD1bXSxwPVtdO3MuZWFjaCgoZnVuY3Rpb24odCxhKXt2YXIgaT1tKHQpO2E8ZS5sb29wZWRTbGlkZXMmJnAucHVzaCh0KSxhPHMubGVuZ3RoJiZhPj1zLmxlbmd0aC1lLmxvb3BlZFNsaWRlcyYmZC5wdXNoKHQpLGkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIsYSl9KSk7Zm9yKHZhciB1PTA7dTxwLmxlbmd0aDt1Kz0xKWkuYXBwZW5kKG0ocFt1XS5jbG9uZU5vZGUoITApKS5hZGRDbGFzcyhhLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtmb3IodmFyIGM9ZC5sZW5ndGgtMTtjPj0wO2MtPTEpaS5wcmVwZW5kKG0oZFtjXS5jbG9uZU5vZGUoITApKS5hZGRDbGFzcyhhLnNsaWRlRHVwbGljYXRlQ2xhc3MpKX0sbG9vcEZpeDpmdW5jdGlvbigpe3ZhciBlPXRoaXM7ZS5lbWl0KFwiYmVmb3JlTG9vcEZpeFwiKTt2YXIgdCxhPWUuYWN0aXZlSW5kZXgsaT1lLnNsaWRlcyxzPWUubG9vcGVkU2xpZGVzLHI9ZS5hbGxvd1NsaWRlUHJldixuPWUuYWxsb3dTbGlkZU5leHQsbD1lLnNuYXBHcmlkLG89ZS5ydGxUcmFuc2xhdGU7ZS5hbGxvd1NsaWRlUHJldj0hMCxlLmFsbG93U2xpZGVOZXh0PSEwO3ZhciBkPS1sW2FdLWUuZ2V0VHJhbnNsYXRlKCk7aWYoYTxzKXQ9aS5sZW5ndGgtMypzK2EsdCs9cyxlLnNsaWRlVG8odCwwLCExLCEwKSYmMCE9PWQmJmUuc2V0VHJhbnNsYXRlKChvPy1lLnRyYW5zbGF0ZTplLnRyYW5zbGF0ZSktZCk7ZWxzZSBpZihhPj1pLmxlbmd0aC1zKXt0PS1pLmxlbmd0aCthK3MsdCs9cyxlLnNsaWRlVG8odCwwLCExLCEwKSYmMCE9PWQmJmUuc2V0VHJhbnNsYXRlKChvPy1lLnRyYW5zbGF0ZTplLnRyYW5zbGF0ZSktZCl9ZS5hbGxvd1NsaWRlUHJldj1yLGUuYWxsb3dTbGlkZU5leHQ9bixlLmVtaXQoXCJsb29wRml4XCIpfSxsb29wRGVzdHJveTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLiR3cmFwcGVyRWwsYT1lLnBhcmFtcyxpPWUuc2xpZGVzO3QuY2hpbGRyZW4oXCIuXCIrYS5zbGlkZUNsYXNzK1wiLlwiK2Euc2xpZGVEdXBsaWNhdGVDbGFzcytcIiwuXCIrYS5zbGlkZUNsYXNzK1wiLlwiK2Euc2xpZGVCbGFua0NsYXNzKS5yZW1vdmUoKSxpLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKX19LGdyYWJDdXJzb3I6e3NldEdyYWJDdXJzb3I6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighKHQuc3VwcG9ydC50b3VjaHx8IXQucGFyYW1zLnNpbXVsYXRlVG91Y2h8fHQucGFyYW1zLndhdGNoT3ZlcmZsb3cmJnQuaXNMb2NrZWR8fHQucGFyYW1zLmNzc01vZGUpKXt2YXIgYT10LmVsO2Euc3R5bGUuY3Vyc29yPVwibW92ZVwiLGEuc3R5bGUuY3Vyc29yPWU/XCItd2Via2l0LWdyYWJiaW5nXCI6XCItd2Via2l0LWdyYWJcIixhLnN0eWxlLmN1cnNvcj1lP1wiLW1vei1ncmFiYmluXCI6XCItbW96LWdyYWJcIixhLnN0eWxlLmN1cnNvcj1lP1wiZ3JhYmJpbmdcIjpcImdyYWJcIn19LHVuc2V0R3JhYkN1cnNvcjpmdW5jdGlvbigpe3ZhciBlPXRoaXM7ZS5zdXBwb3J0LnRvdWNofHxlLnBhcmFtcy53YXRjaE92ZXJmbG93JiZlLmlzTG9ja2VkfHxlLnBhcmFtcy5jc3NNb2RlfHwoZS5lbC5zdHlsZS5jdXJzb3I9XCJcIil9fSxtYW5pcHVsYXRpb246e2FwcGVuZFNsaWRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10LiR3cmFwcGVyRWwsaT10LnBhcmFtcztpZihpLmxvb3AmJnQubG9vcERlc3Ryb3koKSxcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJsZW5ndGhcImluIGUpZm9yKHZhciBzPTA7czxlLmxlbmd0aDtzKz0xKWVbc10mJmEuYXBwZW5kKGVbc10pO2Vsc2UgYS5hcHBlbmQoZSk7aS5sb29wJiZ0Lmxvb3BDcmVhdGUoKSxpLm9ic2VydmVyJiZ0LnN1cHBvcnQub2JzZXJ2ZXJ8fHQudXBkYXRlKCl9LHByZXBlbmRTbGlkZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dC5wYXJhbXMsaT10LiR3cmFwcGVyRWwscz10LmFjdGl2ZUluZGV4O2EubG9vcCYmdC5sb29wRGVzdHJveSgpO3ZhciByPXMrMTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJsZW5ndGhcImluIGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bis9MSllW25dJiZpLnByZXBlbmQoZVtuXSk7cj1zK2UubGVuZ3RofWVsc2UgaS5wcmVwZW5kKGUpO2EubG9vcCYmdC5sb29wQ3JlYXRlKCksYS5vYnNlcnZlciYmdC5zdXBwb3J0Lm9ic2VydmVyfHx0LnVwZGF0ZSgpLHQuc2xpZGVUbyhyLDAsITEpfSxhZGRTbGlkZTpmdW5jdGlvbihlLHQpe3ZhciBhPXRoaXMsaT1hLiR3cmFwcGVyRWwscz1hLnBhcmFtcyxyPWEuYWN0aXZlSW5kZXg7cy5sb29wJiYoci09YS5sb29wZWRTbGlkZXMsYS5sb29wRGVzdHJveSgpLGEuc2xpZGVzPWkuY2hpbGRyZW4oXCIuXCIrcy5zbGlkZUNsYXNzKSk7dmFyIG49YS5zbGlkZXMubGVuZ3RoO2lmKGU8PTApYS5wcmVwZW5kU2xpZGUodCk7ZWxzZSBpZihlPj1uKWEuYXBwZW5kU2xpZGUodCk7ZWxzZXtmb3IodmFyIGw9cj5lP3IrMTpyLG89W10sZD1uLTE7ZD49ZTtkLT0xKXt2YXIgcD1hLnNsaWRlcy5lcShkKTtwLnJlbW92ZSgpLG8udW5zaGlmdChwKX1pZihcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJsZW5ndGhcImluIHQpe2Zvcih2YXIgdT0wO3U8dC5sZW5ndGg7dSs9MSl0W3VdJiZpLmFwcGVuZCh0W3VdKTtsPXI+ZT9yK3QubGVuZ3RoOnJ9ZWxzZSBpLmFwcGVuZCh0KTtmb3IodmFyIGM9MDtjPG8ubGVuZ3RoO2MrPTEpaS5hcHBlbmQob1tjXSk7cy5sb29wJiZhLmxvb3BDcmVhdGUoKSxzLm9ic2VydmVyJiZhLnN1cHBvcnQub2JzZXJ2ZXJ8fGEudXBkYXRlKCkscy5sb29wP2Euc2xpZGVUbyhsK2EubG9vcGVkU2xpZGVzLDAsITEpOmEuc2xpZGVUbyhsLDAsITEpfX0scmVtb3ZlU2xpZGU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQucGFyYW1zLGk9dC4kd3JhcHBlckVsLHM9dC5hY3RpdmVJbmRleDthLmxvb3AmJihzLT10Lmxvb3BlZFNsaWRlcyx0Lmxvb3BEZXN0cm95KCksdC5zbGlkZXM9aS5jaGlsZHJlbihcIi5cIithLnNsaWRlQ2xhc3MpKTt2YXIgcixuPXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJlwibGVuZ3RoXCJpbiBlKXtmb3IodmFyIGw9MDtsPGUubGVuZ3RoO2wrPTEpcj1lW2xdLHQuc2xpZGVzW3JdJiZ0LnNsaWRlcy5lcShyKS5yZW1vdmUoKSxyPG4mJihuLT0xKTtuPU1hdGgubWF4KG4sMCl9ZWxzZSByPWUsdC5zbGlkZXNbcl0mJnQuc2xpZGVzLmVxKHIpLnJlbW92ZSgpLHI8biYmKG4tPTEpLG49TWF0aC5tYXgobiwwKTthLmxvb3AmJnQubG9vcENyZWF0ZSgpLGEub2JzZXJ2ZXImJnQuc3VwcG9ydC5vYnNlcnZlcnx8dC51cGRhdGUoKSxhLmxvb3A/dC5zbGlkZVRvKG4rdC5sb29wZWRTbGlkZXMsMCwhMSk6dC5zbGlkZVRvKG4sMCwhMSl9LHJlbW92ZUFsbFNsaWRlczpmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDx0aGlzLnNsaWRlcy5sZW5ndGg7dCs9MSllLnB1c2godCk7dGhpcy5yZW1vdmVTbGlkZShlKX19LGV2ZW50czp7YXR0YWNoRXZlbnRzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXIoKSxhPWUucGFyYW1zLGk9ZS50b3VjaEV2ZW50cyxzPWUuZWwsbj1lLndyYXBwZXJFbCxsPWUuZGV2aWNlLG89ZS5zdXBwb3J0O2Uub25Ub3VjaFN0YXJ0PU8uYmluZChlKSxlLm9uVG91Y2hNb3ZlPUEuYmluZChlKSxlLm9uVG91Y2hFbmQ9RC5iaW5kKGUpLGEuY3NzTW9kZSYmKGUub25TY3JvbGw9Qi5iaW5kKGUpKSxlLm9uQ2xpY2s9Ti5iaW5kKGUpO3ZhciBkPSEhYS5uZXN0ZWQ7aWYoIW8udG91Y2gmJm8ucG9pbnRlckV2ZW50cylzLmFkZEV2ZW50TGlzdGVuZXIoaS5zdGFydCxlLm9uVG91Y2hTdGFydCwhMSksdC5hZGRFdmVudExpc3RlbmVyKGkubW92ZSxlLm9uVG91Y2hNb3ZlLGQpLHQuYWRkRXZlbnRMaXN0ZW5lcihpLmVuZCxlLm9uVG91Y2hFbmQsITEpO2Vsc2V7aWYoby50b3VjaCl7dmFyIHA9IShcInRvdWNoc3RhcnRcIiE9PWkuc3RhcnR8fCFvLnBhc3NpdmVMaXN0ZW5lcnx8IWEucGFzc2l2ZUxpc3RlbmVycykmJntwYXNzaXZlOiEwLGNhcHR1cmU6ITF9O3MuYWRkRXZlbnRMaXN0ZW5lcihpLnN0YXJ0LGUub25Ub3VjaFN0YXJ0LHApLHMuYWRkRXZlbnRMaXN0ZW5lcihpLm1vdmUsZS5vblRvdWNoTW92ZSxvLnBhc3NpdmVMaXN0ZW5lcj97cGFzc2l2ZTohMSxjYXB0dXJlOmR9OmQpLHMuYWRkRXZlbnRMaXN0ZW5lcihpLmVuZCxlLm9uVG91Y2hFbmQscCksaS5jYW5jZWwmJnMuYWRkRXZlbnRMaXN0ZW5lcihpLmNhbmNlbCxlLm9uVG91Y2hFbmQscCksSHx8KHQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixYKSxIPSEwKX0oYS5zaW11bGF0ZVRvdWNoJiYhbC5pb3MmJiFsLmFuZHJvaWR8fGEuc2ltdWxhdGVUb3VjaCYmIW8udG91Y2gmJmwuaW9zKSYmKHMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGUub25Ub3VjaFN0YXJ0LCExKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixlLm9uVG91Y2hNb3ZlLGQpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixlLm9uVG91Y2hFbmQsITEpKX0oYS5wcmV2ZW50Q2xpY2tzfHxhLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikmJnMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZS5vbkNsaWNrLCEwKSxhLmNzc01vZGUmJm4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGUub25TY3JvbGwpLGEudXBkYXRlT25XaW5kb3dSZXNpemU/ZS5vbihsLmlvc3x8bC5hbmRyb2lkP1wicmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlXCI6XCJyZXNpemUgb2JzZXJ2ZXJVcGRhdGVcIixHLCEwKTplLm9uKFwib2JzZXJ2ZXJVcGRhdGVcIixHLCEwKX0sZGV0YWNoRXZlbnRzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXIoKSxhPWUucGFyYW1zLGk9ZS50b3VjaEV2ZW50cyxzPWUuZWwsbj1lLndyYXBwZXJFbCxsPWUuZGV2aWNlLG89ZS5zdXBwb3J0LGQ9ISFhLm5lc3RlZDtpZighby50b3VjaCYmby5wb2ludGVyRXZlbnRzKXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLnN0YXJ0LGUub25Ub3VjaFN0YXJ0LCExKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5tb3ZlLGUub25Ub3VjaE1vdmUsZCksdC5yZW1vdmVFdmVudExpc3RlbmVyKGkuZW5kLGUub25Ub3VjaEVuZCwhMSk7ZWxzZXtpZihvLnRvdWNoKXt2YXIgcD0hKFwib25Ub3VjaFN0YXJ0XCIhPT1pLnN0YXJ0fHwhby5wYXNzaXZlTGlzdGVuZXJ8fCFhLnBhc3NpdmVMaXN0ZW5lcnMpJiZ7cGFzc2l2ZTohMCxjYXB0dXJlOiExfTtzLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5zdGFydCxlLm9uVG91Y2hTdGFydCxwKSxzLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5tb3ZlLGUub25Ub3VjaE1vdmUsZCkscy5yZW1vdmVFdmVudExpc3RlbmVyKGkuZW5kLGUub25Ub3VjaEVuZCxwKSxpLmNhbmNlbCYmcy5yZW1vdmVFdmVudExpc3RlbmVyKGkuY2FuY2VsLGUub25Ub3VjaEVuZCxwKX0oYS5zaW11bGF0ZVRvdWNoJiYhbC5pb3MmJiFsLmFuZHJvaWR8fGEuc2ltdWxhdGVUb3VjaCYmIW8udG91Y2gmJmwuaW9zKSYmKHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGUub25Ub3VjaFN0YXJ0LCExKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixlLm9uVG91Y2hNb3ZlLGQpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixlLm9uVG91Y2hFbmQsITEpKX0oYS5wcmV2ZW50Q2xpY2tzfHxhLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikmJnMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZS5vbkNsaWNrLCEwKSxhLmNzc01vZGUmJm4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGUub25TY3JvbGwpLGUub2ZmKGwuaW9zfHxsLmFuZHJvaWQ/XCJyZXNpemUgb3JpZW50YXRpb25jaGFuZ2Ugb2JzZXJ2ZXJVcGRhdGVcIjpcInJlc2l6ZSBvYnNlcnZlclVwZGF0ZVwiLEcpfX0sYnJlYWtwb2ludHM6e3NldEJyZWFrcG9pbnQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS5hY3RpdmVJbmRleCxhPWUuaW5pdGlhbGl6ZWQsaT1lLmxvb3BlZFNsaWRlcyxzPXZvaWQgMD09PWk/MDppLHI9ZS5wYXJhbXMsbj1lLiRlbCxsPXIuYnJlYWtwb2ludHM7aWYobCYmKCFsfHwwIT09T2JqZWN0LmtleXMobCkubGVuZ3RoKSl7dmFyIG89ZS5nZXRCcmVha3BvaW50KGwpO2lmKG8mJmUuY3VycmVudEJyZWFrcG9pbnQhPT1vKXt2YXIgZD1vIGluIGw/bFtvXTp2b2lkIDA7ZCYmW1wic2xpZGVzUGVyVmlld1wiLFwic3BhY2VCZXR3ZWVuXCIsXCJzbGlkZXNQZXJHcm91cFwiLFwic2xpZGVzUGVyR3JvdXBTa2lwXCIsXCJzbGlkZXNQZXJDb2x1bW5cIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZFtlXTt2b2lkIDAhPT10JiYoZFtlXT1cInNsaWRlc1BlclZpZXdcIiE9PWV8fFwiQVVUT1wiIT09dCYmXCJhdXRvXCIhPT10P1wic2xpZGVzUGVyVmlld1wiPT09ZT9wYXJzZUZsb2F0KHQpOnBhcnNlSW50KHQsMTApOlwiYXV0b1wiKX0pKTt2YXIgcD1kfHxlLm9yaWdpbmFsUGFyYW1zLHU9ci5zbGlkZXNQZXJDb2x1bW4+MSxjPXAuc2xpZGVzUGVyQ29sdW1uPjE7dSYmIWM/KG4ucmVtb3ZlQ2xhc3Moci5jb250YWluZXJNb2RpZmllckNsYXNzK1wibXVsdGlyb3cgXCIrci5jb250YWluZXJNb2RpZmllckNsYXNzK1wibXVsdGlyb3ctY29sdW1uXCIpLGUuZW1pdENvbnRhaW5lckNsYXNzZXMoKSk6IXUmJmMmJihuLmFkZENsYXNzKHIuY29udGFpbmVyTW9kaWZpZXJDbGFzcytcIm11bHRpcm93XCIpLFwiY29sdW1uXCI9PT1wLnNsaWRlc1BlckNvbHVtbkZpbGwmJm4uYWRkQ2xhc3Moci5jb250YWluZXJNb2RpZmllckNsYXNzK1wibXVsdGlyb3ctY29sdW1uXCIpLGUuZW1pdENvbnRhaW5lckNsYXNzZXMoKSk7dmFyIGg9cC5kaXJlY3Rpb24mJnAuZGlyZWN0aW9uIT09ci5kaXJlY3Rpb24sdj1yLmxvb3AmJihwLnNsaWRlc1BlclZpZXchPT1yLnNsaWRlc1BlclZpZXd8fGgpO2gmJmEmJmUuY2hhbmdlRGlyZWN0aW9uKCksUyhlLnBhcmFtcyxwKSxTKGUse2FsbG93VG91Y2hNb3ZlOmUucGFyYW1zLmFsbG93VG91Y2hNb3ZlLGFsbG93U2xpZGVOZXh0OmUucGFyYW1zLmFsbG93U2xpZGVOZXh0LGFsbG93U2xpZGVQcmV2OmUucGFyYW1zLmFsbG93U2xpZGVQcmV2fSksZS5jdXJyZW50QnJlYWtwb2ludD1vLGUuZW1pdChcIl9iZWZvcmVCcmVha3BvaW50XCIscCksdiYmYSYmKGUubG9vcERlc3Ryb3koKSxlLmxvb3BDcmVhdGUoKSxlLnVwZGF0ZVNsaWRlcygpLGUuc2xpZGVUbyh0LXMrZS5sb29wZWRTbGlkZXMsMCwhMSkpLGUuZW1pdChcImJyZWFrcG9pbnRcIixwKX19fSxnZXRCcmVha3BvaW50OmZ1bmN0aW9uKGUpe3ZhciB0PWwoKTtpZihlKXt2YXIgYT0hMSxpPU9iamVjdC5rZXlzKGUpLm1hcCgoZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJjA9PT1lLmluZGV4T2YoXCJAXCIpKXt2YXIgYT1wYXJzZUZsb2F0KGUuc3Vic3RyKDEpKTtyZXR1cm57dmFsdWU6dC5pbm5lckhlaWdodCphLHBvaW50OmV9fXJldHVybnt2YWx1ZTplLHBvaW50OmV9fSkpO2kuc29ydCgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gcGFyc2VJbnQoZS52YWx1ZSwxMCktcGFyc2VJbnQodC52YWx1ZSwxMCl9KSk7Zm9yKHZhciBzPTA7czxpLmxlbmd0aDtzKz0xKXt2YXIgcj1pW3NdLG49ci5wb2ludDtyLnZhbHVlPD10LmlubmVyV2lkdGgmJihhPW4pfXJldHVybiBhfHxcIm1heFwifX19LGNoZWNrT3ZlcmZsb3c6e2NoZWNrT3ZlcmZsb3c6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS5wYXJhbXMsYT1lLmlzTG9ja2VkLGk9ZS5zbGlkZXMubGVuZ3RoPjAmJnQuc2xpZGVzT2Zmc2V0QmVmb3JlK3Quc3BhY2VCZXR3ZWVuKihlLnNsaWRlcy5sZW5ndGgtMSkrZS5zbGlkZXNbMF0ub2Zmc2V0V2lkdGgqZS5zbGlkZXMubGVuZ3RoO3Quc2xpZGVzT2Zmc2V0QmVmb3JlJiZ0LnNsaWRlc09mZnNldEFmdGVyJiZpP2UuaXNMb2NrZWQ9aTw9ZS5zaXplOmUuaXNMb2NrZWQ9MT09PWUuc25hcEdyaWQubGVuZ3RoLGUuYWxsb3dTbGlkZU5leHQ9IWUuaXNMb2NrZWQsZS5hbGxvd1NsaWRlUHJldj0hZS5pc0xvY2tlZCxhIT09ZS5pc0xvY2tlZCYmZS5lbWl0KGUuaXNMb2NrZWQ/XCJsb2NrXCI6XCJ1bmxvY2tcIiksYSYmYSE9PWUuaXNMb2NrZWQmJihlLmlzRW5kPSExLGUubmF2aWdhdGlvbiYmZS5uYXZpZ2F0aW9uLnVwZGF0ZSgpKX19LGNsYXNzZXM6e2FkZENsYXNzZXM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS5jbGFzc05hbWVzLGE9ZS5wYXJhbXMsaT1lLnJ0bCxzPWUuJGVsLHI9ZS5kZXZpY2Usbj1bXTtuLnB1c2goXCJpbml0aWFsaXplZFwiKSxuLnB1c2goYS5kaXJlY3Rpb24pLGEuZnJlZU1vZGUmJm4ucHVzaChcImZyZWUtbW9kZVwiKSxhLmF1dG9IZWlnaHQmJm4ucHVzaChcImF1dG9oZWlnaHRcIiksaSYmbi5wdXNoKFwicnRsXCIpLGEuc2xpZGVzUGVyQ29sdW1uPjEmJihuLnB1c2goXCJtdWx0aXJvd1wiKSxcImNvbHVtblwiPT09YS5zbGlkZXNQZXJDb2x1bW5GaWxsJiZuLnB1c2goXCJtdWx0aXJvdy1jb2x1bW5cIikpLHIuYW5kcm9pZCYmbi5wdXNoKFwiYW5kcm9pZFwiKSxyLmlvcyYmbi5wdXNoKFwiaW9zXCIpLGEuY3NzTW9kZSYmbi5wdXNoKFwiY3NzLW1vZGVcIiksbi5mb3JFYWNoKChmdW5jdGlvbihlKXt0LnB1c2goYS5jb250YWluZXJNb2RpZmllckNsYXNzK2UpfSkpLHMuYWRkQ2xhc3ModC5qb2luKFwiIFwiKSksZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpfSxyZW1vdmVDbGFzc2VzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWUuJGVsLGE9ZS5jbGFzc05hbWVzO3QucmVtb3ZlQ2xhc3MoYS5qb2luKFwiIFwiKSksZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpfX0saW1hZ2VzOntsb2FkSW1hZ2U6ZnVuY3Rpb24oZSx0LGEsaSxzLHIpe3ZhciBuLG89bCgpO2Z1bmN0aW9uIGQoKXtyJiZyKCl9bShlKS5wYXJlbnQoXCJwaWN0dXJlXCIpWzBdfHxlLmNvbXBsZXRlJiZzP2QoKTp0Pygobj1uZXcgby5JbWFnZSkub25sb2FkPWQsbi5vbmVycm9yPWQsaSYmKG4uc2l6ZXM9aSksYSYmKG4uc3Jjc2V0PWEpLHQmJihuLnNyYz10KSk6ZCgpfSxwcmVsb2FkSW1hZ2VzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztmdW5jdGlvbiB0KCl7bnVsbCE9ZSYmZSYmIWUuZGVzdHJveWVkJiYodm9pZCAwIT09ZS5pbWFnZXNMb2FkZWQmJihlLmltYWdlc0xvYWRlZCs9MSksZS5pbWFnZXNMb2FkZWQ9PT1lLmltYWdlc1RvTG9hZC5sZW5ndGgmJihlLnBhcmFtcy51cGRhdGVPbkltYWdlc1JlYWR5JiZlLnVwZGF0ZSgpLGUuZW1pdChcImltYWdlc1JlYWR5XCIpKSl9ZS5pbWFnZXNUb0xvYWQ9ZS4kZWwuZmluZChcImltZ1wiKTtmb3IodmFyIGE9MDthPGUuaW1hZ2VzVG9Mb2FkLmxlbmd0aDthKz0xKXt2YXIgaT1lLmltYWdlc1RvTG9hZFthXTtlLmxvYWRJbWFnZShpLGkuY3VycmVudFNyY3x8aS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksaS5zcmNzZXR8fGkuZ2V0QXR0cmlidXRlKFwic3Jjc2V0XCIpLGkuc2l6ZXN8fGkuZ2V0QXR0cmlidXRlKFwic2l6ZXNcIiksITAsdCl9fX19LEY9e30sUj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtmb3IodmFyIGUsYSxpPWFyZ3VtZW50cy5sZW5ndGgscz1uZXcgQXJyYXkoaSkscj0wO3I8aTtyKyspc1tyXT1hcmd1bWVudHNbcl07MT09PXMubGVuZ3RoJiZzWzBdLmNvbnN0cnVjdG9yJiZzWzBdLmNvbnN0cnVjdG9yPT09T2JqZWN0P2E9c1swXTooZT1zWzBdLGE9c1sxXSksYXx8KGE9e30pLGE9Uyh7fSxhKSxlJiYhYS5lbCYmKGEuZWw9ZSk7dmFyIG49dGhpcztuLnN1cHBvcnQ9eigpLG4uZGV2aWNlPVAoe3VzZXJBZ2VudDphLnVzZXJBZ2VudH0pLG4uYnJvd3Nlcj1rKCksbi5ldmVudHNMaXN0ZW5lcnM9e30sbi5ldmVudHNBbnlMaXN0ZW5lcnM9W10sdm9pZCAwPT09bi5tb2R1bGVzJiYobi5tb2R1bGVzPXt9KSxPYmplY3Qua2V5cyhuLm1vZHVsZXMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PW4ubW9kdWxlc1tlXTtpZih0LnBhcmFtcyl7dmFyIGk9T2JqZWN0LmtleXModC5wYXJhbXMpWzBdLHM9dC5wYXJhbXNbaV07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHN8fG51bGw9PT1zKXJldHVybjtpZighKGkgaW4gYSl8fCEoXCJlbmFibGVkXCJpbiBzKSlyZXR1cm47ITA9PT1hW2ldJiYoYVtpXT17ZW5hYmxlZDohMH0pLFwib2JqZWN0XCIhPXR5cGVvZiBhW2ldfHxcImVuYWJsZWRcImluIGFbaV18fChhW2ldLmVuYWJsZWQ9ITApLGFbaV18fChhW2ldPXtlbmFibGVkOiExfSl9fSkpO3ZhciBsPVMoe30sWSk7bi51c2VQYXJhbXMobCksbi5wYXJhbXM9Uyh7fSxsLEYsYSksbi5vcmlnaW5hbFBhcmFtcz1TKHt9LG4ucGFyYW1zKSxuLnBhc3NlZFBhcmFtcz1TKHt9LGEpLG4ucGFyYW1zJiZuLnBhcmFtcy5vbiYmT2JqZWN0LmtleXMobi5wYXJhbXMub24pLmZvckVhY2goKGZ1bmN0aW9uKGUpe24ub24oZSxuLnBhcmFtcy5vbltlXSl9KSksbi5wYXJhbXMmJm4ucGFyYW1zLm9uQW55JiZuLm9uQW55KG4ucGFyYW1zLm9uQW55KSxuLiQ9bTt2YXIgbz1tKG4ucGFyYW1zLmVsKTtpZihlPW9bMF0pe2lmKG8ubGVuZ3RoPjEpe3ZhciBkPVtdO3JldHVybiBvLmVhY2goKGZ1bmN0aW9uKGUpe3ZhciBpPVMoe30sYSx7ZWw6ZX0pO2QucHVzaChuZXcgdChpKSl9KSksZH12YXIgcCx1LGM7cmV0dXJuIGUuc3dpcGVyPW4sZSYmZS5zaGFkb3dSb290JiZlLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcj8ocD1tKGUuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLlwiK24ucGFyYW1zLndyYXBwZXJDbGFzcykpKS5jaGlsZHJlbj1mdW5jdGlvbihlKXtyZXR1cm4gby5jaGlsZHJlbihlKX06cD1vLmNoaWxkcmVuKFwiLlwiK24ucGFyYW1zLndyYXBwZXJDbGFzcyksUyhuLHskZWw6byxlbDplLCR3cmFwcGVyRWw6cCx3cmFwcGVyRWw6cFswXSxjbGFzc05hbWVzOltdLHNsaWRlczptKCksc2xpZGVzR3JpZDpbXSxzbmFwR3JpZDpbXSxzbGlkZXNTaXplc0dyaWQ6W10saXNIb3Jpem9udGFsOmZ1bmN0aW9uKCl7cmV0dXJuXCJob3Jpem9udGFsXCI9PT1uLnBhcmFtcy5kaXJlY3Rpb259LGlzVmVydGljYWw6ZnVuY3Rpb24oKXtyZXR1cm5cInZlcnRpY2FsXCI9PT1uLnBhcmFtcy5kaXJlY3Rpb259LHJ0bDpcInJ0bFwiPT09ZS5kaXIudG9Mb3dlckNhc2UoKXx8XCJydGxcIj09PW8uY3NzKFwiZGlyZWN0aW9uXCIpLHJ0bFRyYW5zbGF0ZTpcImhvcml6b250YWxcIj09PW4ucGFyYW1zLmRpcmVjdGlvbiYmKFwicnRsXCI9PT1lLmRpci50b0xvd2VyQ2FzZSgpfHxcInJ0bFwiPT09by5jc3MoXCJkaXJlY3Rpb25cIikpLHdyb25nUlRMOlwiLXdlYmtpdC1ib3hcIj09PXAuY3NzKFwiZGlzcGxheVwiKSxhY3RpdmVJbmRleDowLHJlYWxJbmRleDowLGlzQmVnaW5uaW5nOiEwLGlzRW5kOiExLHRyYW5zbGF0ZTowLHByZXZpb3VzVHJhbnNsYXRlOjAscHJvZ3Jlc3M6MCx2ZWxvY2l0eTowLGFuaW1hdGluZzohMSxhbGxvd1NsaWRlTmV4dDpuLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxhbGxvd1NsaWRlUHJldjpuLnBhcmFtcy5hbGxvd1NsaWRlUHJldix0b3VjaEV2ZW50czoodT1bXCJ0b3VjaHN0YXJ0XCIsXCJ0b3VjaG1vdmVcIixcInRvdWNoZW5kXCIsXCJ0b3VjaGNhbmNlbFwiXSxjPVtcIm1vdXNlZG93blwiLFwibW91c2Vtb3ZlXCIsXCJtb3VzZXVwXCJdLG4uc3VwcG9ydC5wb2ludGVyRXZlbnRzJiYoYz1bXCJwb2ludGVyZG93blwiLFwicG9pbnRlcm1vdmVcIixcInBvaW50ZXJ1cFwiXSksbi50b3VjaEV2ZW50c1RvdWNoPXtzdGFydDp1WzBdLG1vdmU6dVsxXSxlbmQ6dVsyXSxjYW5jZWw6dVszXX0sbi50b3VjaEV2ZW50c0Rlc2t0b3A9e3N0YXJ0OmNbMF0sbW92ZTpjWzFdLGVuZDpjWzJdfSxuLnN1cHBvcnQudG91Y2h8fCFuLnBhcmFtcy5zaW11bGF0ZVRvdWNoP24udG91Y2hFdmVudHNUb3VjaDpuLnRvdWNoRXZlbnRzRGVza3RvcCksdG91Y2hFdmVudHNEYXRhOntpc1RvdWNoZWQ6dm9pZCAwLGlzTW92ZWQ6dm9pZCAwLGFsbG93VG91Y2hDYWxsYmFja3M6dm9pZCAwLHRvdWNoU3RhcnRUaW1lOnZvaWQgMCxpc1Njcm9sbGluZzp2b2lkIDAsY3VycmVudFRyYW5zbGF0ZTp2b2lkIDAsc3RhcnRUcmFuc2xhdGU6dm9pZCAwLGFsbG93VGhyZXNob2xkTW92ZTp2b2lkIDAsZm9ybUVsZW1lbnRzOlwiaW5wdXQsIHNlbGVjdCwgb3B0aW9uLCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlbywgbGFiZWxcIixsYXN0Q2xpY2tUaW1lOngoKSxjbGlja1RpbWVvdXQ6dm9pZCAwLHZlbG9jaXRpZXM6W10sYWxsb3dNb21lbnR1bUJvdW5jZTp2b2lkIDAsaXNUb3VjaEV2ZW50OnZvaWQgMCxzdGFydE1vdmluZzp2b2lkIDB9LGFsbG93Q2xpY2s6ITAsYWxsb3dUb3VjaE1vdmU6bi5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsdG91Y2hlczp7c3RhcnRYOjAsc3RhcnRZOjAsY3VycmVudFg6MCxjdXJyZW50WTowLGRpZmY6MH0saW1hZ2VzVG9Mb2FkOltdLGltYWdlc0xvYWRlZDowfSksbi51c2VNb2R1bGVzKCksbi5lbWl0KFwiX3N3aXBlclwiKSxuLnBhcmFtcy5pbml0JiZuLmluaXQoKSxufX12YXIgYSxpLHMscj10LnByb3RvdHlwZTtyZXR1cm4gci5lbWl0Q29udGFpbmVyQ2xhc3Nlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoZS5wYXJhbXMuX2VtaXRDbGFzc2VzJiZlLmVsKXt2YXIgdD1lLmVsLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQuaW5kZXhPZihcInN3aXBlci1jb250YWluZXJcIil8fDA9PT10LmluZGV4T2YoZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyl9KSk7ZS5lbWl0KFwiX2NvbnRhaW5lckNsYXNzZXNcIix0LmpvaW4oXCIgXCIpKX19LHIuZ2V0U2xpZGVDbGFzc2VzPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIGUuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiAwPT09ZS5pbmRleE9mKFwic3dpcGVyLXNsaWRlXCIpfHwwPT09ZS5pbmRleE9mKHQucGFyYW1zLnNsaWRlQ2xhc3MpfSkpLmpvaW4oXCIgXCIpfSxyLmVtaXRTbGlkZXNDbGFzc2VzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztlLnBhcmFtcy5fZW1pdENsYXNzZXMmJmUuZWwmJmUuc2xpZGVzLmVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPWUuZ2V0U2xpZGVDbGFzc2VzKHQpO2UuZW1pdChcIl9zbGlkZUNsYXNzXCIsdCxhKX0pKX0sci5zbGlkZXNQZXJWaWV3RHluYW1pYz1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnBhcmFtcyxhPWUuc2xpZGVzLGk9ZS5zbGlkZXNHcmlkLHM9ZS5zaXplLHI9ZS5hY3RpdmVJbmRleCxuPTE7aWYodC5jZW50ZXJlZFNsaWRlcyl7Zm9yKHZhciBsLG89YVtyXS5zd2lwZXJTbGlkZVNpemUsZD1yKzE7ZDxhLmxlbmd0aDtkKz0xKWFbZF0mJiFsJiYobis9MSwobys9YVtkXS5zd2lwZXJTbGlkZVNpemUpPnMmJihsPSEwKSk7Zm9yKHZhciBwPXItMTtwPj0wO3AtPTEpYVtwXSYmIWwmJihuKz0xLChvKz1hW3BdLnN3aXBlclNsaWRlU2l6ZSk+cyYmKGw9ITApKX1lbHNlIGZvcih2YXIgdT1yKzE7dTxhLmxlbmd0aDt1Kz0xKWlbdV0taVtyXTxzJiYobis9MSk7cmV0dXJuIG59LHIudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZihlJiYhZS5kZXN0cm95ZWQpe3ZhciB0PWUuc25hcEdyaWQsYT1lLnBhcmFtczthLmJyZWFrcG9pbnRzJiZlLnNldEJyZWFrcG9pbnQoKSxlLnVwZGF0ZVNpemUoKSxlLnVwZGF0ZVNsaWRlcygpLGUudXBkYXRlUHJvZ3Jlc3MoKSxlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSxlLnBhcmFtcy5mcmVlTW9kZT8oaSgpLGUucGFyYW1zLmF1dG9IZWlnaHQmJmUudXBkYXRlQXV0b0hlaWdodCgpKTooKFwiYXV0b1wiPT09ZS5wYXJhbXMuc2xpZGVzUGVyVmlld3x8ZS5wYXJhbXMuc2xpZGVzUGVyVmlldz4xKSYmZS5pc0VuZCYmIWUucGFyYW1zLmNlbnRlcmVkU2xpZGVzP2Uuc2xpZGVUbyhlLnNsaWRlcy5sZW5ndGgtMSwwLCExLCEwKTplLnNsaWRlVG8oZS5hY3RpdmVJbmRleCwwLCExLCEwKSl8fGkoKSxhLndhdGNoT3ZlcmZsb3cmJnQhPT1lLnNuYXBHcmlkJiZlLmNoZWNrT3ZlcmZsb3coKSxlLmVtaXQoXCJ1cGRhdGVcIil9ZnVuY3Rpb24gaSgpe3ZhciB0PWUucnRsVHJhbnNsYXRlPy0xKmUudHJhbnNsYXRlOmUudHJhbnNsYXRlLGE9TWF0aC5taW4oTWF0aC5tYXgodCxlLm1heFRyYW5zbGF0ZSgpKSxlLm1pblRyYW5zbGF0ZSgpKTtlLnNldFRyYW5zbGF0ZShhKSxlLnVwZGF0ZUFjdGl2ZUluZGV4KCksZS51cGRhdGVTbGlkZXNDbGFzc2VzKCl9fSxyLmNoYW5nZURpcmVjdGlvbj1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgYT10aGlzLGk9YS5wYXJhbXMuZGlyZWN0aW9uO3JldHVybiBlfHwoZT1cImhvcml6b250YWxcIj09PWk/XCJ2ZXJ0aWNhbFwiOlwiaG9yaXpvbnRhbFwiKSxlPT09aXx8XCJob3Jpem9udGFsXCIhPT1lJiZcInZlcnRpY2FsXCIhPT1lfHwoYS4kZWwucmVtb3ZlQ2xhc3MoXCJcIithLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzK2kpLmFkZENsYXNzKFwiXCIrYS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcytlKSxhLmVtaXRDb250YWluZXJDbGFzc2VzKCksYS5wYXJhbXMuZGlyZWN0aW9uPWUsYS5zbGlkZXMuZWFjaCgoZnVuY3Rpb24odCl7XCJ2ZXJ0aWNhbFwiPT09ZT90LnN0eWxlLndpZHRoPVwiXCI6dC5zdHlsZS5oZWlnaHQ9XCJcIn0pKSxhLmVtaXQoXCJjaGFuZ2VEaXJlY3Rpb25cIiksdCYmYS51cGRhdGUoKSksYX0sci5pbml0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztlLmluaXRpYWxpemVkfHwoZS5lbWl0KFwiYmVmb3JlSW5pdFwiKSxlLnBhcmFtcy5icmVha3BvaW50cyYmZS5zZXRCcmVha3BvaW50KCksZS5hZGRDbGFzc2VzKCksZS5wYXJhbXMubG9vcCYmZS5sb29wQ3JlYXRlKCksZS51cGRhdGVTaXplKCksZS51cGRhdGVTbGlkZXMoKSxlLnBhcmFtcy53YXRjaE92ZXJmbG93JiZlLmNoZWNrT3ZlcmZsb3coKSxlLnBhcmFtcy5ncmFiQ3Vyc29yJiZlLnNldEdyYWJDdXJzb3IoKSxlLnBhcmFtcy5wcmVsb2FkSW1hZ2VzJiZlLnByZWxvYWRJbWFnZXMoKSxlLnBhcmFtcy5sb29wP2Uuc2xpZGVUbyhlLnBhcmFtcy5pbml0aWFsU2xpZGUrZS5sb29wZWRTbGlkZXMsMCxlLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpOmUuc2xpZGVUbyhlLnBhcmFtcy5pbml0aWFsU2xpZGUsMCxlLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpLGUuYXR0YWNoRXZlbnRzKCksZS5pbml0aWFsaXplZD0hMCxlLmVtaXQoXCJpbml0XCIpLGUuZW1pdChcImFmdGVySW5pdFwiKSl9LHIuZGVzdHJveT1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PWUmJihlPSEwKSx2b2lkIDA9PT10JiYodD0hMCk7dmFyIGEsaT10aGlzLHM9aS5wYXJhbXMscj1pLiRlbCxuPWkuJHdyYXBwZXJFbCxsPWkuc2xpZGVzO3JldHVybiB2b2lkIDA9PT1pLnBhcmFtc3x8aS5kZXN0cm95ZWR8fChpLmVtaXQoXCJiZWZvcmVEZXN0cm95XCIpLGkuaW5pdGlhbGl6ZWQ9ITEsaS5kZXRhY2hFdmVudHMoKSxzLmxvb3AmJmkubG9vcERlc3Ryb3koKSx0JiYoaS5yZW1vdmVDbGFzc2VzKCksci5yZW1vdmVBdHRyKFwic3R5bGVcIiksbi5yZW1vdmVBdHRyKFwic3R5bGVcIiksbCYmbC5sZW5ndGgmJmwucmVtb3ZlQ2xhc3MoW3Muc2xpZGVWaXNpYmxlQ2xhc3Mscy5zbGlkZUFjdGl2ZUNsYXNzLHMuc2xpZGVOZXh0Q2xhc3Mscy5zbGlkZVByZXZDbGFzc10uam9pbihcIiBcIikpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKS5yZW1vdmVBdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikpLGkuZW1pdChcImRlc3Ryb3lcIiksT2JqZWN0LmtleXMoaS5ldmVudHNMaXN0ZW5lcnMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2kub2ZmKGUpfSkpLCExIT09ZSYmKGkuJGVsWzBdLnN3aXBlcj1udWxsLGE9aSxPYmplY3Qua2V5cyhhKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0cnl7YVtlXT1udWxsfWNhdGNoKGUpe310cnl7ZGVsZXRlIGFbZV19Y2F0Y2goZSl7fX0pKSksaS5kZXN0cm95ZWQ9ITApLG51bGx9LHQuZXh0ZW5kRGVmYXVsdHM9ZnVuY3Rpb24oZSl7UyhGLGUpfSx0Lmluc3RhbGxNb2R1bGU9ZnVuY3Rpb24oZSl7dC5wcm90b3R5cGUubW9kdWxlc3x8KHQucHJvdG90eXBlLm1vZHVsZXM9e30pO3ZhciBhPWUubmFtZXx8T2JqZWN0LmtleXModC5wcm90b3R5cGUubW9kdWxlcykubGVuZ3RoK1wiX1wiK3goKTt0LnByb3RvdHlwZS5tb2R1bGVzW2FdPWV9LHQudXNlPWZ1bmN0aW9uKGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpPyhlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB0Lmluc3RhbGxNb2R1bGUoZSl9KSksdCk6KHQuaW5zdGFsbE1vZHVsZShlKSx0KX0sYT10LHM9W3trZXk6XCJleHRlbmRlZERlZmF1bHRzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEZ9fSx7a2V5OlwiZGVmYXVsdHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gWX19XSwoaT1udWxsKSYmZShhLnByb3RvdHlwZSxpKSxzJiZlKGEscyksdH0oKTtPYmplY3Qua2V5cyhWKS5mb3JFYWNoKChmdW5jdGlvbihlKXtPYmplY3Qua2V5cyhWW2VdKS5mb3JFYWNoKChmdW5jdGlvbih0KXtSLnByb3RvdHlwZVt0XT1WW2VdW3RdfSkpfSkpLFIudXNlKFtMLEldKTt2YXIgVz17dXBkYXRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10LnBhcmFtcyxpPWEuc2xpZGVzUGVyVmlldyxzPWEuc2xpZGVzUGVyR3JvdXAscj1hLmNlbnRlcmVkU2xpZGVzLG49dC5wYXJhbXMudmlydHVhbCxsPW4uYWRkU2xpZGVzQmVmb3JlLG89bi5hZGRTbGlkZXNBZnRlcixkPXQudmlydHVhbCxwPWQuZnJvbSx1PWQudG8sYz1kLnNsaWRlcyxoPWQuc2xpZGVzR3JpZCx2PWQucmVuZGVyU2xpZGUsZj1kLm9mZnNldDt0LnVwZGF0ZUFjdGl2ZUluZGV4KCk7dmFyIG0sZyx5LHc9dC5hY3RpdmVJbmRleHx8MDttPXQucnRsVHJhbnNsYXRlP1wicmlnaHRcIjp0LmlzSG9yaXpvbnRhbCgpP1wibGVmdFwiOlwidG9wXCIscj8oZz1NYXRoLmZsb29yKGkvMikrcytvLHk9TWF0aC5mbG9vcihpLzIpK3MrbCk6KGc9aSsocy0xKStvLHk9cytsKTt2YXIgYj1NYXRoLm1heCgod3x8MCkteSwwKSxFPU1hdGgubWluKCh3fHwwKStnLGMubGVuZ3RoLTEpLHg9KHQuc2xpZGVzR3JpZFtiXXx8MCktKHQuc2xpZGVzR3JpZFswXXx8MCk7ZnVuY3Rpb24gVCgpe3QudXBkYXRlU2xpZGVzKCksdC51cGRhdGVQcm9ncmVzcygpLHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpLHQubGF6eSYmdC5wYXJhbXMubGF6eS5lbmFibGVkJiZ0LmxhenkubG9hZCgpfWlmKFModC52aXJ0dWFsLHtmcm9tOmIsdG86RSxvZmZzZXQ6eCxzbGlkZXNHcmlkOnQuc2xpZGVzR3JpZH0pLHA9PT1iJiZ1PT09RSYmIWUpcmV0dXJuIHQuc2xpZGVzR3JpZCE9PWgmJnghPT1mJiZ0LnNsaWRlcy5jc3MobSx4K1wicHhcIiksdm9pZCB0LnVwZGF0ZVByb2dyZXNzKCk7aWYodC5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbClyZXR1cm4gdC5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbC5jYWxsKHQse29mZnNldDp4LGZyb206Yix0bzpFLHNsaWRlczpmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PWI7dDw9RTt0Kz0xKWUucHVzaChjW3RdKTtyZXR1cm4gZX0oKX0pLHZvaWQodC5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbFVwZGF0ZSYmVCgpKTt2YXIgQz1bXSxNPVtdO2lmKGUpdC4kd3JhcHBlckVsLmZpbmQoXCIuXCIrdC5wYXJhbXMuc2xpZGVDbGFzcykucmVtb3ZlKCk7ZWxzZSBmb3IodmFyIHo9cDt6PD11O3orPTEpKHo8Ynx8ej5FKSYmdC4kd3JhcHBlckVsLmZpbmQoXCIuXCIrdC5wYXJhbXMuc2xpZGVDbGFzcysnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyt6KydcIl0nKS5yZW1vdmUoKTtmb3IodmFyIFA9MDtQPGMubGVuZ3RoO1ArPTEpUD49YiYmUDw9RSYmKHZvaWQgMD09PXV8fGU/TS5wdXNoKFApOihQPnUmJk0ucHVzaChQKSxQPHAmJkMucHVzaChQKSkpO00uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC4kd3JhcHBlckVsLmFwcGVuZCh2KGNbZV0sZSkpfSkpLEMuc29ydCgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC1lfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuJHdyYXBwZXJFbC5wcmVwZW5kKHYoY1tlXSxlKSl9KSksdC4kd3JhcHBlckVsLmNoaWxkcmVuKFwiLnN3aXBlci1zbGlkZVwiKS5jc3MobSx4K1wicHhcIiksVCgpfSxyZW5kZXJTbGlkZTpmdW5jdGlvbihlLHQpe3ZhciBhPXRoaXMsaT1hLnBhcmFtcy52aXJ0dWFsO2lmKGkuY2FjaGUmJmEudmlydHVhbC5jYWNoZVt0XSlyZXR1cm4gYS52aXJ0dWFsLmNhY2hlW3RdO3ZhciBzPWkucmVuZGVyU2xpZGU/bShpLnJlbmRlclNsaWRlLmNhbGwoYSxlLHQpKTptKCc8ZGl2IGNsYXNzPVwiJythLnBhcmFtcy5zbGlkZUNsYXNzKydcIiBkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrdCsnXCI+JytlK1wiPC9kaXY+XCIpO3JldHVybiBzLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKXx8cy5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIix0KSxpLmNhY2hlJiYoYS52aXJ0dWFsLmNhY2hlW3RdPXMpLHN9LGFwcGVuZFNsaWRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJlwibGVuZ3RoXCJpbiBlKWZvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSs9MSllW2FdJiZ0LnZpcnR1YWwuc2xpZGVzLnB1c2goZVthXSk7ZWxzZSB0LnZpcnR1YWwuc2xpZGVzLnB1c2goZSk7dC52aXJ0dWFsLnVwZGF0ZSghMCl9LHByZXBlbmRTbGlkZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dC5hY3RpdmVJbmRleCxpPWErMSxzPTE7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKz0xKWVbcl0mJnQudmlydHVhbC5zbGlkZXMudW5zaGlmdChlW3JdKTtpPWErZS5sZW5ndGgscz1lLmxlbmd0aH1lbHNlIHQudmlydHVhbC5zbGlkZXMudW5zaGlmdChlKTtpZih0LnBhcmFtcy52aXJ0dWFsLmNhY2hlKXt2YXIgbj10LnZpcnR1YWwuY2FjaGUsbD17fTtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1uW2VdLGE9dC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIik7YSYmdC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIixwYXJzZUludChhLDEwKSsxKSxsW3BhcnNlSW50KGUsMTApK3NdPXR9KSksdC52aXJ0dWFsLmNhY2hlPWx9dC52aXJ0dWFsLnVwZGF0ZSghMCksdC5zbGlkZVRvKGksMCl9LHJlbW92ZVNsaWRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYobnVsbCE9ZSl7dmFyIGE9dC5hY3RpdmVJbmRleDtpZihBcnJheS5pc0FycmF5KGUpKWZvcih2YXIgaT1lLmxlbmd0aC0xO2k+PTA7aS09MSl0LnZpcnR1YWwuc2xpZGVzLnNwbGljZShlW2ldLDEpLHQucGFyYW1zLnZpcnR1YWwuY2FjaGUmJmRlbGV0ZSB0LnZpcnR1YWwuY2FjaGVbZVtpXV0sZVtpXTxhJiYoYS09MSksYT1NYXRoLm1heChhLDApO2Vsc2UgdC52aXJ0dWFsLnNsaWRlcy5zcGxpY2UoZSwxKSx0LnBhcmFtcy52aXJ0dWFsLmNhY2hlJiZkZWxldGUgdC52aXJ0dWFsLmNhY2hlW2VdLGU8YSYmKGEtPTEpLGE9TWF0aC5tYXgoYSwwKTt0LnZpcnR1YWwudXBkYXRlKCEwKSx0LnNsaWRlVG8oYSwwKX19LHJlbW92ZUFsbFNsaWRlczpmdW5jdGlvbigpe3ZhciBlPXRoaXM7ZS52aXJ0dWFsLnNsaWRlcz1bXSxlLnBhcmFtcy52aXJ0dWFsLmNhY2hlJiYoZS52aXJ0dWFsLmNhY2hlPXt9KSxlLnZpcnR1YWwudXBkYXRlKCEwKSxlLnNsaWRlVG8oMCwwKX19LHE9e25hbWU6XCJ2aXJ0dWFsXCIscGFyYW1zOnt2aXJ0dWFsOntlbmFibGVkOiExLHNsaWRlczpbXSxjYWNoZTohMCxyZW5kZXJTbGlkZTpudWxsLHJlbmRlckV4dGVybmFsOm51bGwscmVuZGVyRXh0ZXJuYWxVcGRhdGU6ITAsYWRkU2xpZGVzQmVmb3JlOjAsYWRkU2xpZGVzQWZ0ZXI6MH19LGNyZWF0ZTpmdW5jdGlvbigpe00odGhpcyx7dmlydHVhbDp0KHt9LFcse3NsaWRlczp0aGlzLnBhcmFtcy52aXJ0dWFsLnNsaWRlcyxjYWNoZTp7fX0pfSl9LG9uOntiZWZvcmVJbml0OmZ1bmN0aW9uKGUpe2lmKGUucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCl7ZS5jbGFzc05hbWVzLnB1c2goZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcytcInZpcnR1YWxcIik7dmFyIHQ9e3dhdGNoU2xpZGVzUHJvZ3Jlc3M6ITB9O1MoZS5wYXJhbXMsdCksUyhlLm9yaWdpbmFsUGFyYW1zLHQpLGUucGFyYW1zLmluaXRpYWxTbGlkZXx8ZS52aXJ0dWFsLnVwZGF0ZSgpfX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKGUpe2UucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCYmZS52aXJ0dWFsLnVwZGF0ZSgpfX19LGo9e2hhbmRsZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9bCgpLGk9cigpLHM9dC5ydGxUcmFuc2xhdGUsbj1lO24ub3JpZ2luYWxFdmVudCYmKG49bi5vcmlnaW5hbEV2ZW50KTt2YXIgbz1uLmtleUNvZGV8fG4uY2hhckNvZGUsZD10LnBhcmFtcy5rZXlib2FyZC5wYWdlVXBEb3duLHA9ZCYmMzM9PT1vLHU9ZCYmMzQ9PT1vLGM9Mzc9PT1vLGg9Mzk9PT1vLHY9Mzg9PT1vLGY9NDA9PT1vO2lmKCF0LmFsbG93U2xpZGVOZXh0JiYodC5pc0hvcml6b250YWwoKSYmaHx8dC5pc1ZlcnRpY2FsKCkmJmZ8fHUpKXJldHVybiExO2lmKCF0LmFsbG93U2xpZGVQcmV2JiYodC5pc0hvcml6b250YWwoKSYmY3x8dC5pc1ZlcnRpY2FsKCkmJnZ8fHApKXJldHVybiExO2lmKCEobi5zaGlmdEtleXx8bi5hbHRLZXl8fG4uY3RybEtleXx8bi5tZXRhS2V5fHxpLmFjdGl2ZUVsZW1lbnQmJmkuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSYmKFwiaW5wdXRcIj09PWkuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpfHxcInRleHRhcmVhXCI9PT1pLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpKXtpZih0LnBhcmFtcy5rZXlib2FyZC5vbmx5SW5WaWV3cG9ydCYmKHB8fHV8fGN8fGh8fHZ8fGYpKXt2YXIgbT0hMTtpZih0LiRlbC5wYXJlbnRzKFwiLlwiK3QucGFyYW1zLnNsaWRlQ2xhc3MpLmxlbmd0aD4wJiYwPT09dC4kZWwucGFyZW50cyhcIi5cIit0LnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKS5sZW5ndGgpcmV0dXJuO3ZhciBnPWEuaW5uZXJXaWR0aCx5PWEuaW5uZXJIZWlnaHQsdz10LiRlbC5vZmZzZXQoKTtzJiYody5sZWZ0LT10LiRlbFswXS5zY3JvbGxMZWZ0KTtmb3IodmFyIGI9W1t3LmxlZnQsdy50b3BdLFt3LmxlZnQrdC53aWR0aCx3LnRvcF0sW3cubGVmdCx3LnRvcCt0LmhlaWdodF0sW3cubGVmdCt0LndpZHRoLHcudG9wK3QuaGVpZ2h0XV0sRT0wO0U8Yi5sZW5ndGg7RSs9MSl7dmFyIHg9YltFXTtpZih4WzBdPj0wJiZ4WzBdPD1nJiZ4WzFdPj0wJiZ4WzFdPD15KXtpZigwPT09eFswXSYmMD09PXhbMV0pY29udGludWU7bT0hMH19aWYoIW0pcmV0dXJufXQuaXNIb3Jpem9udGFsKCk/KChwfHx1fHxjfHxoKSYmKG4ucHJldmVudERlZmF1bHQ/bi5wcmV2ZW50RGVmYXVsdCgpOm4ucmV0dXJuVmFsdWU9ITEpLCgodXx8aCkmJiFzfHwocHx8YykmJnMpJiZ0LnNsaWRlTmV4dCgpLCgocHx8YykmJiFzfHwodXx8aCkmJnMpJiZ0LnNsaWRlUHJldigpKTooKHB8fHV8fHZ8fGYpJiYobi5wcmV2ZW50RGVmYXVsdD9uLnByZXZlbnREZWZhdWx0KCk6bi5yZXR1cm5WYWx1ZT0hMSksKHV8fGYpJiZ0LnNsaWRlTmV4dCgpLChwfHx2KSYmdC5zbGlkZVByZXYoKSksdC5lbWl0KFwia2V5UHJlc3NcIixvKX19LGVuYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1yKCk7ZS5rZXlib2FyZC5lbmFibGVkfHwobSh0KS5vbihcImtleWRvd25cIixlLmtleWJvYXJkLmhhbmRsZSksZS5rZXlib2FyZC5lbmFibGVkPSEwKX0sZGlzYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1yKCk7ZS5rZXlib2FyZC5lbmFibGVkJiYobSh0KS5vZmYoXCJrZXlkb3duXCIsZS5rZXlib2FyZC5oYW5kbGUpLGUua2V5Ym9hcmQuZW5hYmxlZD0hMSl9fSxfPXtuYW1lOlwia2V5Ym9hcmRcIixwYXJhbXM6e2tleWJvYXJkOntlbmFibGVkOiExLG9ubHlJblZpZXdwb3J0OiEwLHBhZ2VVcERvd246ITB9fSxjcmVhdGU6ZnVuY3Rpb24oKXtNKHRoaXMse2tleWJvYXJkOnQoe2VuYWJsZWQ6ITF9LGopfSl9LG9uOntpbml0OmZ1bmN0aW9uKGUpe2UucGFyYW1zLmtleWJvYXJkLmVuYWJsZWQmJmUua2V5Ym9hcmQuZW5hYmxlKCl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS5rZXlib2FyZC5lbmFibGVkJiZlLmtleWJvYXJkLmRpc2FibGUoKX19fTt2YXIgVT17bGFzdFNjcm9sbFRpbWU6eCgpLGxhc3RFdmVudEJlZm9yZVNuYXA6dm9pZCAwLHJlY2VudFdoZWVsRXZlbnRzOltdLGV2ZW50OmZ1bmN0aW9uKCl7cmV0dXJuIGwoKS5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJmaXJlZm94XCIpPi0xP1wiRE9NTW91c2VTY3JvbGxcIjpmdW5jdGlvbigpe3ZhciBlPXIoKSx0PVwib253aGVlbFwiLGE9dCBpbiBlO2lmKCFhKXt2YXIgaT1lLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5zZXRBdHRyaWJ1dGUodCxcInJldHVybjtcIiksYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpLm9ud2hlZWx9cmV0dXJuIWEmJmUuaW1wbGVtZW50YXRpb24mJmUuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSYmITAhPT1lLmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJcIixcIlwiKSYmKGE9ZS5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiRXZlbnRzLndoZWVsXCIsXCIzLjBcIikpLGF9KCk/XCJ3aGVlbFwiOlwibW91c2V3aGVlbFwifSxub3JtYWxpemU6ZnVuY3Rpb24oZSl7dmFyIHQ9MCxhPTAsaT0wLHM9MDtyZXR1cm5cImRldGFpbFwiaW4gZSYmKGE9ZS5kZXRhaWwpLFwid2hlZWxEZWx0YVwiaW4gZSYmKGE9LWUud2hlZWxEZWx0YS8xMjApLFwid2hlZWxEZWx0YVlcImluIGUmJihhPS1lLndoZWVsRGVsdGFZLzEyMCksXCJ3aGVlbERlbHRhWFwiaW4gZSYmKHQ9LWUud2hlZWxEZWx0YVgvMTIwKSxcImF4aXNcImluIGUmJmUuYXhpcz09PWUuSE9SSVpPTlRBTF9BWElTJiYodD1hLGE9MCksaT0xMCp0LHM9MTAqYSxcImRlbHRhWVwiaW4gZSYmKHM9ZS5kZWx0YVkpLFwiZGVsdGFYXCJpbiBlJiYoaT1lLmRlbHRhWCksZS5zaGlmdEtleSYmIWkmJihpPXMscz0wKSwoaXx8cykmJmUuZGVsdGFNb2RlJiYoMT09PWUuZGVsdGFNb2RlPyhpKj00MCxzKj00MCk6KGkqPTgwMCxzKj04MDApKSxpJiYhdCYmKHQ9aTwxPy0xOjEpLHMmJiFhJiYoYT1zPDE/LTE6MSkse3NwaW5YOnQsc3Bpblk6YSxwaXhlbFg6aSxwaXhlbFk6c319LGhhbmRsZU1vdXNlRW50ZXI6ZnVuY3Rpb24oKXt0aGlzLm1vdXNlRW50ZXJlZD0hMH0saGFuZGxlTW91c2VMZWF2ZTpmdW5jdGlvbigpe3RoaXMubW91c2VFbnRlcmVkPSExfSxoYW5kbGU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZSxhPXRoaXMsaT1hLnBhcmFtcy5tb3VzZXdoZWVsO2EucGFyYW1zLmNzc01vZGUmJnQucHJldmVudERlZmF1bHQoKTt2YXIgcz1hLiRlbDtpZihcImNvbnRhaW5lclwiIT09YS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQmJihzPW0oYS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpKSwhYS5tb3VzZUVudGVyZWQmJiFzWzBdLmNvbnRhaW5zKHQudGFyZ2V0KSYmIWkucmVsZWFzZU9uRWRnZXMpcmV0dXJuITA7dC5vcmlnaW5hbEV2ZW50JiYodD10Lm9yaWdpbmFsRXZlbnQpO3ZhciByPTAsbj1hLnJ0bFRyYW5zbGF0ZT8tMToxLGw9VS5ub3JtYWxpemUodCk7aWYoaS5mb3JjZVRvQXhpcylpZihhLmlzSG9yaXpvbnRhbCgpKXtpZighKE1hdGguYWJzKGwucGl4ZWxYKT5NYXRoLmFicyhsLnBpeGVsWSkpKXJldHVybiEwO3I9LWwucGl4ZWxYKm59ZWxzZXtpZighKE1hdGguYWJzKGwucGl4ZWxZKT5NYXRoLmFicyhsLnBpeGVsWCkpKXJldHVybiEwO3I9LWwucGl4ZWxZfWVsc2Ugcj1NYXRoLmFicyhsLnBpeGVsWCk+TWF0aC5hYnMobC5waXhlbFkpPy1sLnBpeGVsWCpuOi1sLnBpeGVsWTtpZigwPT09cilyZXR1cm4hMDtpLmludmVydCYmKHI9LXIpO3ZhciBvPWEuZ2V0VHJhbnNsYXRlKCkrcippLnNlbnNpdGl2aXR5O2lmKG8+PWEubWluVHJhbnNsYXRlKCkmJihvPWEubWluVHJhbnNsYXRlKCkpLG88PWEubWF4VHJhbnNsYXRlKCkmJihvPWEubWF4VHJhbnNsYXRlKCkpLCghIWEucGFyYW1zLmxvb3B8fCEobz09PWEubWluVHJhbnNsYXRlKCl8fG89PT1hLm1heFRyYW5zbGF0ZSgpKSkmJmEucGFyYW1zLm5lc3RlZCYmdC5zdG9wUHJvcGFnYXRpb24oKSxhLnBhcmFtcy5mcmVlTW9kZSl7dmFyIGQ9e3RpbWU6eCgpLGRlbHRhOk1hdGguYWJzKHIpLGRpcmVjdGlvbjpNYXRoLnNpZ24ocil9LHA9YS5tb3VzZXdoZWVsLmxhc3RFdmVudEJlZm9yZVNuYXAsdT1wJiZkLnRpbWU8cC50aW1lKzUwMCYmZC5kZWx0YTw9cC5kZWx0YSYmZC5kaXJlY3Rpb249PT1wLmRpcmVjdGlvbjtpZighdSl7YS5tb3VzZXdoZWVsLmxhc3RFdmVudEJlZm9yZVNuYXA9dm9pZCAwLGEucGFyYW1zLmxvb3AmJmEubG9vcEZpeCgpO3ZhciBjPWEuZ2V0VHJhbnNsYXRlKCkrcippLnNlbnNpdGl2aXR5LGg9YS5pc0JlZ2lubmluZyx2PWEuaXNFbmQ7aWYoYz49YS5taW5UcmFuc2xhdGUoKSYmKGM9YS5taW5UcmFuc2xhdGUoKSksYzw9YS5tYXhUcmFuc2xhdGUoKSYmKGM9YS5tYXhUcmFuc2xhdGUoKSksYS5zZXRUcmFuc2l0aW9uKDApLGEuc2V0VHJhbnNsYXRlKGMpLGEudXBkYXRlUHJvZ3Jlc3MoKSxhLnVwZGF0ZUFjdGl2ZUluZGV4KCksYS51cGRhdGVTbGlkZXNDbGFzc2VzKCksKCFoJiZhLmlzQmVnaW5uaW5nfHwhdiYmYS5pc0VuZCkmJmEudXBkYXRlU2xpZGVzQ2xhc3NlcygpLGEucGFyYW1zLmZyZWVNb2RlU3RpY2t5KXtjbGVhclRpbWVvdXQoYS5tb3VzZXdoZWVsLnRpbWVvdXQpLGEubW91c2V3aGVlbC50aW1lb3V0PXZvaWQgMDt2YXIgZj1hLm1vdXNld2hlZWwucmVjZW50V2hlZWxFdmVudHM7Zi5sZW5ndGg+PTE1JiZmLnNoaWZ0KCk7dmFyIGc9Zi5sZW5ndGg/ZltmLmxlbmd0aC0xXTp2b2lkIDAseT1mWzBdO2lmKGYucHVzaChkKSxnJiYoZC5kZWx0YT5nLmRlbHRhfHxkLmRpcmVjdGlvbiE9PWcuZGlyZWN0aW9uKSlmLnNwbGljZSgwKTtlbHNlIGlmKGYubGVuZ3RoPj0xNSYmZC50aW1lLXkudGltZTw1MDAmJnkuZGVsdGEtZC5kZWx0YT49MSYmZC5kZWx0YTw9Nil7dmFyIHc9cj4wPy44Oi4yO2EubW91c2V3aGVlbC5sYXN0RXZlbnRCZWZvcmVTbmFwPWQsZi5zcGxpY2UoMCksYS5tb3VzZXdoZWVsLnRpbWVvdXQ9RSgoZnVuY3Rpb24oKXthLnNsaWRlVG9DbG9zZXN0KGEucGFyYW1zLnNwZWVkLCEwLHZvaWQgMCx3KX0pLDApfWEubW91c2V3aGVlbC50aW1lb3V0fHwoYS5tb3VzZXdoZWVsLnRpbWVvdXQ9RSgoZnVuY3Rpb24oKXthLm1vdXNld2hlZWwubGFzdEV2ZW50QmVmb3JlU25hcD1kLGYuc3BsaWNlKDApLGEuc2xpZGVUb0Nsb3Nlc3QoYS5wYXJhbXMuc3BlZWQsITAsdm9pZCAwLC41KX0pLDUwMCkpfWlmKHV8fGEuZW1pdChcInNjcm9sbFwiLHQpLGEucGFyYW1zLmF1dG9wbGF5JiZhLnBhcmFtcy5hdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uJiZhLmF1dG9wbGF5LnN0b3AoKSxjPT09YS5taW5UcmFuc2xhdGUoKXx8Yz09PWEubWF4VHJhbnNsYXRlKCkpcmV0dXJuITB9fWVsc2V7dmFyIGI9e3RpbWU6eCgpLGRlbHRhOk1hdGguYWJzKHIpLGRpcmVjdGlvbjpNYXRoLnNpZ24ocikscmF3OmV9LFQ9YS5tb3VzZXdoZWVsLnJlY2VudFdoZWVsRXZlbnRzO1QubGVuZ3RoPj0yJiZULnNoaWZ0KCk7dmFyIEM9VC5sZW5ndGg/VFtULmxlbmd0aC0xXTp2b2lkIDA7aWYoVC5wdXNoKGIpLEM/KGIuZGlyZWN0aW9uIT09Qy5kaXJlY3Rpb258fGIuZGVsdGE+Qy5kZWx0YXx8Yi50aW1lPkMudGltZSsxNTApJiZhLm1vdXNld2hlZWwuYW5pbWF0ZVNsaWRlcihiKTphLm1vdXNld2hlZWwuYW5pbWF0ZVNsaWRlcihiKSxhLm1vdXNld2hlZWwucmVsZWFzZVNjcm9sbChiKSlyZXR1cm4hMH1yZXR1cm4gdC5wcmV2ZW50RGVmYXVsdD90LnByZXZlbnREZWZhdWx0KCk6dC5yZXR1cm5WYWx1ZT0hMSwhMX0sYW5pbWF0ZVNsaWRlcjpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9bCgpO3JldHVybiEodGhpcy5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGREZWx0YSYmZS5kZWx0YTx0aGlzLnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZERlbHRhKSYmKCEodGhpcy5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGRUaW1lJiZ4KCktdC5tb3VzZXdoZWVsLmxhc3RTY3JvbGxUaW1lPHRoaXMucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSkmJihlLmRlbHRhPj02JiZ4KCktdC5tb3VzZXdoZWVsLmxhc3RTY3JvbGxUaW1lPDYwfHwoZS5kaXJlY3Rpb248MD90LmlzRW5kJiYhdC5wYXJhbXMubG9vcHx8dC5hbmltYXRpbmd8fCh0LnNsaWRlTmV4dCgpLHQuZW1pdChcInNjcm9sbFwiLGUucmF3KSk6dC5pc0JlZ2lubmluZyYmIXQucGFyYW1zLmxvb3B8fHQuYW5pbWF0aW5nfHwodC5zbGlkZVByZXYoKSx0LmVtaXQoXCJzY3JvbGxcIixlLnJhdykpLHQubW91c2V3aGVlbC5sYXN0U2Nyb2xsVGltZT0obmV3IGEuRGF0ZSkuZ2V0VGltZSgpLCExKSkpfSxyZWxlYXNlU2Nyb2xsOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10LnBhcmFtcy5tb3VzZXdoZWVsO2lmKGUuZGlyZWN0aW9uPDApe2lmKHQuaXNFbmQmJiF0LnBhcmFtcy5sb29wJiZhLnJlbGVhc2VPbkVkZ2VzKXJldHVybiEwfWVsc2UgaWYodC5pc0JlZ2lubmluZyYmIXQucGFyYW1zLmxvb3AmJmEucmVsZWFzZU9uRWRnZXMpcmV0dXJuITA7cmV0dXJuITF9LGVuYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1VLmV2ZW50KCk7aWYoZS5wYXJhbXMuY3NzTW9kZSlyZXR1cm4gZS53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUubW91c2V3aGVlbC5oYW5kbGUpLCEwO2lmKCF0KXJldHVybiExO2lmKGUubW91c2V3aGVlbC5lbmFibGVkKXJldHVybiExO3ZhciBhPWUuJGVsO3JldHVyblwiY29udGFpbmVyXCIhPT1lLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCYmKGE9bShlLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCkpLGEub24oXCJtb3VzZWVudGVyXCIsZS5tb3VzZXdoZWVsLmhhbmRsZU1vdXNlRW50ZXIpLGEub24oXCJtb3VzZWxlYXZlXCIsZS5tb3VzZXdoZWVsLmhhbmRsZU1vdXNlTGVhdmUpLGEub24odCxlLm1vdXNld2hlZWwuaGFuZGxlKSxlLm1vdXNld2hlZWwuZW5hYmxlZD0hMCwhMH0sZGlzYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1VLmV2ZW50KCk7aWYoZS5wYXJhbXMuY3NzTW9kZSlyZXR1cm4gZS53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcih0LGUubW91c2V3aGVlbC5oYW5kbGUpLCEwO2lmKCF0KXJldHVybiExO2lmKCFlLm1vdXNld2hlZWwuZW5hYmxlZClyZXR1cm4hMTt2YXIgYT1lLiRlbDtyZXR1cm5cImNvbnRhaW5lclwiIT09ZS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQmJihhPW0oZS5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpKSxhLm9mZih0LGUubW91c2V3aGVlbC5oYW5kbGUpLGUubW91c2V3aGVlbC5lbmFibGVkPSExLCEwfX0sSz17dXBkYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWUucGFyYW1zLm5hdmlnYXRpb247aWYoIWUucGFyYW1zLmxvb3Ape3ZhciBhPWUubmF2aWdhdGlvbixpPWEuJG5leHRFbCxzPWEuJHByZXZFbDtzJiZzLmxlbmd0aD4wJiYoZS5pc0JlZ2lubmluZz9zLmFkZENsYXNzKHQuZGlzYWJsZWRDbGFzcyk6cy5yZW1vdmVDbGFzcyh0LmRpc2FibGVkQ2xhc3MpLHNbZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyYmZS5pc0xvY2tlZD9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXSh0LmxvY2tDbGFzcykpLGkmJmkubGVuZ3RoPjAmJihlLmlzRW5kP2kuYWRkQ2xhc3ModC5kaXNhYmxlZENsYXNzKTppLnJlbW92ZUNsYXNzKHQuZGlzYWJsZWRDbGFzcyksaVtlLnBhcmFtcy53YXRjaE92ZXJmbG93JiZlLmlzTG9ja2VkP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKHQubG9ja0NsYXNzKSl9fSxvblByZXZDbGljazpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2UucHJldmVudERlZmF1bHQoKSx0LmlzQmVnaW5uaW5nJiYhdC5wYXJhbXMubG9vcHx8dC5zbGlkZVByZXYoKX0sb25OZXh0Q2xpY2s6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlLnByZXZlbnREZWZhdWx0KCksdC5pc0VuZCYmIXQucGFyYW1zLmxvb3B8fHQuc2xpZGVOZXh0KCl9LGluaXQ6ZnVuY3Rpb24oKXt2YXIgZSx0LGE9dGhpcyxpPWEucGFyYW1zLm5hdmlnYXRpb247KGkubmV4dEVsfHxpLnByZXZFbCkmJihpLm5leHRFbCYmKGU9bShpLm5leHRFbCksYS5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMmJlwic3RyaW5nXCI9PXR5cGVvZiBpLm5leHRFbCYmZS5sZW5ndGg+MSYmMT09PWEuJGVsLmZpbmQoaS5uZXh0RWwpLmxlbmd0aCYmKGU9YS4kZWwuZmluZChpLm5leHRFbCkpKSxpLnByZXZFbCYmKHQ9bShpLnByZXZFbCksYS5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMmJlwic3RyaW5nXCI9PXR5cGVvZiBpLnByZXZFbCYmdC5sZW5ndGg+MSYmMT09PWEuJGVsLmZpbmQoaS5wcmV2RWwpLmxlbmd0aCYmKHQ9YS4kZWwuZmluZChpLnByZXZFbCkpKSxlJiZlLmxlbmd0aD4wJiZlLm9uKFwiY2xpY2tcIixhLm5hdmlnYXRpb24ub25OZXh0Q2xpY2spLHQmJnQubGVuZ3RoPjAmJnQub24oXCJjbGlja1wiLGEubmF2aWdhdGlvbi5vblByZXZDbGljayksUyhhLm5hdmlnYXRpb24seyRuZXh0RWw6ZSxuZXh0RWw6ZSYmZVswXSwkcHJldkVsOnQscHJldkVsOnQmJnRbMF19KSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS5uYXZpZ2F0aW9uLGE9dC4kbmV4dEVsLGk9dC4kcHJldkVsO2EmJmEubGVuZ3RoJiYoYS5vZmYoXCJjbGlja1wiLGUubmF2aWdhdGlvbi5vbk5leHRDbGljayksYS5yZW1vdmVDbGFzcyhlLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpKSxpJiZpLmxlbmd0aCYmKGkub2ZmKFwiY2xpY2tcIixlLm5hdmlnYXRpb24ub25QcmV2Q2xpY2spLGkucmVtb3ZlQ2xhc3MoZS5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKSl9fSxaPXt1cGRhdGU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS5ydGwsYT1lLnBhcmFtcy5wYWdpbmF0aW9uO2lmKGEuZWwmJmUucGFnaW5hdGlvbi5lbCYmZS5wYWdpbmF0aW9uLiRlbCYmMCE9PWUucGFnaW5hdGlvbi4kZWwubGVuZ3RoKXt2YXIgaSxzPWUudmlydHVhbCYmZS5wYXJhbXMudmlydHVhbC5lbmFibGVkP2UudmlydHVhbC5zbGlkZXMubGVuZ3RoOmUuc2xpZGVzLmxlbmd0aCxyPWUucGFnaW5hdGlvbi4kZWwsbj1lLnBhcmFtcy5sb29wP01hdGguY2VpbCgocy0yKmUubG9vcGVkU2xpZGVzKS9lLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk6ZS5zbmFwR3JpZC5sZW5ndGg7aWYoZS5wYXJhbXMubG9vcD8oKGk9TWF0aC5jZWlsKChlLmFjdGl2ZUluZGV4LWUubG9vcGVkU2xpZGVzKS9lLnBhcmFtcy5zbGlkZXNQZXJHcm91cCkpPnMtMS0yKmUubG9vcGVkU2xpZGVzJiYoaS09cy0yKmUubG9vcGVkU2xpZGVzKSxpPm4tMSYmKGktPW4pLGk8MCYmXCJidWxsZXRzXCIhPT1lLnBhcmFtcy5wYWdpbmF0aW9uVHlwZSYmKGk9bitpKSk6aT12b2lkIDAhPT1lLnNuYXBJbmRleD9lLnNuYXBJbmRleDplLmFjdGl2ZUluZGV4fHwwLFwiYnVsbGV0c1wiPT09YS50eXBlJiZlLnBhZ2luYXRpb24uYnVsbGV0cyYmZS5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoPjApe3ZhciBsLG8sZCxwPWUucGFnaW5hdGlvbi5idWxsZXRzO2lmKGEuZHluYW1pY0J1bGxldHMmJihlLnBhZ2luYXRpb24uYnVsbGV0U2l6ZT1wLmVxKDApW2UuaXNIb3Jpem9udGFsKCk/XCJvdXRlcldpZHRoXCI6XCJvdXRlckhlaWdodFwiXSghMCksci5jc3MoZS5pc0hvcml6b250YWwoKT9cIndpZHRoXCI6XCJoZWlnaHRcIixlLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSooYS5keW5hbWljTWFpbkJ1bGxldHMrNCkrXCJweFwiKSxhLmR5bmFtaWNNYWluQnVsbGV0cz4xJiZ2b2lkIDAhPT1lLnByZXZpb3VzSW5kZXgmJihlLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4Kz1pLWUucHJldmlvdXNJbmRleCxlLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4PmEuZHluYW1pY01haW5CdWxsZXRzLTE/ZS5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleD1hLmR5bmFtaWNNYWluQnVsbGV0cy0xOmUucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXg8MCYmKGUucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXg9MCkpLGw9aS1lLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4LGQ9KChvPWwrKE1hdGgubWluKHAubGVuZ3RoLGEuZHluYW1pY01haW5CdWxsZXRzKS0xKSkrbCkvMikscC5yZW1vdmVDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzK1wiIFwiK2EuYnVsbGV0QWN0aXZlQ2xhc3MrXCItbmV4dCBcIithLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLW5leHQtbmV4dCBcIithLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLXByZXYgXCIrYS5idWxsZXRBY3RpdmVDbGFzcytcIi1wcmV2LXByZXYgXCIrYS5idWxsZXRBY3RpdmVDbGFzcytcIi1tYWluXCIpLHIubGVuZ3RoPjEpcC5lYWNoKChmdW5jdGlvbihlKXt2YXIgdD1tKGUpLHM9dC5pbmRleCgpO3M9PT1pJiZ0LmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MpLGEuZHluYW1pY0J1bGxldHMmJihzPj1sJiZzPD1vJiZ0LmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MrXCItbWFpblwiKSxzPT09bCYmdC5wcmV2KCkuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcytcIi1wcmV2XCIpLnByZXYoKS5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLXByZXYtcHJldlwiKSxzPT09byYmdC5uZXh0KCkuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcytcIi1uZXh0XCIpLm5leHQoKS5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLW5leHQtbmV4dFwiKSl9KSk7ZWxzZXt2YXIgdT1wLmVxKGkpLGM9dS5pbmRleCgpO2lmKHUuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcyksYS5keW5hbWljQnVsbGV0cyl7Zm9yKHZhciBoPXAuZXEobCksdj1wLmVxKG8pLGY9bDtmPD1vO2YrPTEpcC5lcShmKS5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLW1haW5cIik7aWYoZS5wYXJhbXMubG9vcClpZihjPj1wLmxlbmd0aC1hLmR5bmFtaWNNYWluQnVsbGV0cyl7Zm9yKHZhciBnPWEuZHluYW1pY01haW5CdWxsZXRzO2c+PTA7Zy09MSlwLmVxKHAubGVuZ3RoLWcpLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MrXCItbWFpblwiKTtwLmVxKHAubGVuZ3RoLWEuZHluYW1pY01haW5CdWxsZXRzLTEpLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MrXCItcHJldlwiKX1lbHNlIGgucHJldigpLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MrXCItcHJldlwiKS5wcmV2KCkuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcytcIi1wcmV2LXByZXZcIiksdi5uZXh0KCkuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcytcIi1uZXh0XCIpLm5leHQoKS5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLW5leHQtbmV4dFwiKTtlbHNlIGgucHJldigpLmFkZENsYXNzKGEuYnVsbGV0QWN0aXZlQ2xhc3MrXCItcHJldlwiKS5wcmV2KCkuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcytcIi1wcmV2LXByZXZcIiksdi5uZXh0KCkuYWRkQ2xhc3MoYS5idWxsZXRBY3RpdmVDbGFzcytcIi1uZXh0XCIpLm5leHQoKS5hZGRDbGFzcyhhLmJ1bGxldEFjdGl2ZUNsYXNzK1wiLW5leHQtbmV4dFwiKX19aWYoYS5keW5hbWljQnVsbGV0cyl7dmFyIHk9TWF0aC5taW4ocC5sZW5ndGgsYS5keW5hbWljTWFpbkJ1bGxldHMrNCksdz0oZS5wYWdpbmF0aW9uLmJ1bGxldFNpemUqeS1lLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSkvMi1kKmUucGFnaW5hdGlvbi5idWxsZXRTaXplLGI9dD9cInJpZ2h0XCI6XCJsZWZ0XCI7cC5jc3MoZS5pc0hvcml6b250YWwoKT9iOlwidG9wXCIsdytcInB4XCIpfX1pZihcImZyYWN0aW9uXCI9PT1hLnR5cGUmJihyLmZpbmQoXCIuXCIrYS5jdXJyZW50Q2xhc3MpLnRleHQoYS5mb3JtYXRGcmFjdGlvbkN1cnJlbnQoaSsxKSksci5maW5kKFwiLlwiK2EudG90YWxDbGFzcykudGV4dChhLmZvcm1hdEZyYWN0aW9uVG90YWwobikpKSxcInByb2dyZXNzYmFyXCI9PT1hLnR5cGUpe3ZhciBFO0U9YS5wcm9ncmVzc2Jhck9wcG9zaXRlP2UuaXNIb3Jpem9udGFsKCk/XCJ2ZXJ0aWNhbFwiOlwiaG9yaXpvbnRhbFwiOmUuaXNIb3Jpem9udGFsKCk/XCJob3Jpem9udGFsXCI6XCJ2ZXJ0aWNhbFwiO3ZhciB4PShpKzEpL24sVD0xLEM9MTtcImhvcml6b250YWxcIj09PUU/VD14OkM9eCxyLmZpbmQoXCIuXCIrYS5wcm9ncmVzc2JhckZpbGxDbGFzcykudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlWChcIitUK1wiKSBzY2FsZVkoXCIrQytcIilcIikudHJhbnNpdGlvbihlLnBhcmFtcy5zcGVlZCl9XCJjdXN0b21cIj09PWEudHlwZSYmYS5yZW5kZXJDdXN0b20/KHIuaHRtbChhLnJlbmRlckN1c3RvbShlLGkrMSxuKSksZS5lbWl0KFwicGFnaW5hdGlvblJlbmRlclwiLHJbMF0pKTplLmVtaXQoXCJwYWdpbmF0aW9uVXBkYXRlXCIsclswXSkscltlLnBhcmFtcy53YXRjaE92ZXJmbG93JiZlLmlzTG9ja2VkP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKGEubG9ja0NsYXNzKX19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnBhcmFtcy5wYWdpbmF0aW9uO2lmKHQuZWwmJmUucGFnaW5hdGlvbi5lbCYmZS5wYWdpbmF0aW9uLiRlbCYmMCE9PWUucGFnaW5hdGlvbi4kZWwubGVuZ3RoKXt2YXIgYT1lLnZpcnR1YWwmJmUucGFyYW1zLnZpcnR1YWwuZW5hYmxlZD9lLnZpcnR1YWwuc2xpZGVzLmxlbmd0aDplLnNsaWRlcy5sZW5ndGgsaT1lLnBhZ2luYXRpb24uJGVsLHM9XCJcIjtpZihcImJ1bGxldHNcIj09PXQudHlwZSl7Zm9yKHZhciByPWUucGFyYW1zLmxvb3A/TWF0aC5jZWlsKChhLTIqZS5sb29wZWRTbGlkZXMpL2UucGFyYW1zLnNsaWRlc1Blckdyb3VwKTplLnNuYXBHcmlkLmxlbmd0aCxuPTA7bjxyO24rPTEpdC5yZW5kZXJCdWxsZXQ/cys9dC5yZW5kZXJCdWxsZXQuY2FsbChlLG4sdC5idWxsZXRDbGFzcyk6cys9XCI8XCIrdC5idWxsZXRFbGVtZW50KycgY2xhc3M9XCInK3QuYnVsbGV0Q2xhc3MrJ1wiPjwvJyt0LmJ1bGxldEVsZW1lbnQrXCI+XCI7aS5odG1sKHMpLGUucGFnaW5hdGlvbi5idWxsZXRzPWkuZmluZChcIi5cIit0LmJ1bGxldENsYXNzLnJlcGxhY2UoLyAvZyxcIi5cIikpfVwiZnJhY3Rpb25cIj09PXQudHlwZSYmKHM9dC5yZW5kZXJGcmFjdGlvbj90LnJlbmRlckZyYWN0aW9uLmNhbGwoZSx0LmN1cnJlbnRDbGFzcyx0LnRvdGFsQ2xhc3MpOic8c3BhbiBjbGFzcz1cIicrdC5jdXJyZW50Q2xhc3MrJ1wiPjwvc3Bhbj4gLyA8c3BhbiBjbGFzcz1cIicrdC50b3RhbENsYXNzKydcIj48L3NwYW4+JyxpLmh0bWwocykpLFwicHJvZ3Jlc3NiYXJcIj09PXQudHlwZSYmKHM9dC5yZW5kZXJQcm9ncmVzc2Jhcj90LnJlbmRlclByb2dyZXNzYmFyLmNhbGwoZSx0LnByb2dyZXNzYmFyRmlsbENsYXNzKTonPHNwYW4gY2xhc3M9XCInK3QucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MrJ1wiPjwvc3Bhbj4nLGkuaHRtbChzKSksXCJjdXN0b21cIiE9PXQudHlwZSYmZS5lbWl0KFwicGFnaW5hdGlvblJlbmRlclwiLGUucGFnaW5hdGlvbi4kZWxbMF0pfX0saW5pdDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnBhcmFtcy5wYWdpbmF0aW9uO2lmKHQuZWwpe3ZhciBhPW0odC5lbCk7MCE9PWEubGVuZ3RoJiYoZS5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMmJlwic3RyaW5nXCI9PXR5cGVvZiB0LmVsJiZhLmxlbmd0aD4xJiYoYT1lLiRlbC5maW5kKHQuZWwpKSxcImJ1bGxldHNcIj09PXQudHlwZSYmdC5jbGlja2FibGUmJmEuYWRkQ2xhc3ModC5jbGlja2FibGVDbGFzcyksYS5hZGRDbGFzcyh0Lm1vZGlmaWVyQ2xhc3MrdC50eXBlKSxcImJ1bGxldHNcIj09PXQudHlwZSYmdC5keW5hbWljQnVsbGV0cyYmKGEuYWRkQ2xhc3MoXCJcIit0Lm1vZGlmaWVyQ2xhc3MrdC50eXBlK1wiLWR5bmFtaWNcIiksZS5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleD0wLHQuZHluYW1pY01haW5CdWxsZXRzPDEmJih0LmR5bmFtaWNNYWluQnVsbGV0cz0xKSksXCJwcm9ncmVzc2JhclwiPT09dC50eXBlJiZ0LnByb2dyZXNzYmFyT3Bwb3NpdGUmJmEuYWRkQ2xhc3ModC5wcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3MpLHQuY2xpY2thYmxlJiZhLm9uKFwiY2xpY2tcIixcIi5cIit0LmJ1bGxldENsYXNzLnJlcGxhY2UoLyAvZyxcIi5cIiksKGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgYT1tKHRoaXMpLmluZGV4KCkqZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7ZS5wYXJhbXMubG9vcCYmKGErPWUubG9vcGVkU2xpZGVzKSxlLnNsaWRlVG8oYSl9KSksUyhlLnBhZ2luYXRpb24seyRlbDphLGVsOmFbMF19KSl9fSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWUucGFyYW1zLnBhZ2luYXRpb247aWYodC5lbCYmZS5wYWdpbmF0aW9uLmVsJiZlLnBhZ2luYXRpb24uJGVsJiYwIT09ZS5wYWdpbmF0aW9uLiRlbC5sZW5ndGgpe3ZhciBhPWUucGFnaW5hdGlvbi4kZWw7YS5yZW1vdmVDbGFzcyh0LmhpZGRlbkNsYXNzKSxhLnJlbW92ZUNsYXNzKHQubW9kaWZpZXJDbGFzcyt0LnR5cGUpLGUucGFnaW5hdGlvbi5idWxsZXRzJiZlLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyh0LmJ1bGxldEFjdGl2ZUNsYXNzKSx0LmNsaWNrYWJsZSYmYS5vZmYoXCJjbGlja1wiLFwiLlwiK3QuYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLFwiLlwiKSl9fX0sSj17c2V0VHJhbnNsYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZihlLnBhcmFtcy5zY3JvbGxiYXIuZWwmJmUuc2Nyb2xsYmFyLmVsKXt2YXIgdD1lLnNjcm9sbGJhcixhPWUucnRsVHJhbnNsYXRlLGk9ZS5wcm9ncmVzcyxzPXQuZHJhZ1NpemUscj10LnRyYWNrU2l6ZSxuPXQuJGRyYWdFbCxsPXQuJGVsLG89ZS5wYXJhbXMuc2Nyb2xsYmFyLGQ9cyxwPShyLXMpKmk7YT8ocD0tcCk+MD8oZD1zLXAscD0wKTotcCtzPnImJihkPXIrcCk6cDwwPyhkPXMrcCxwPTApOnArcz5yJiYoZD1yLXApLGUuaXNIb3Jpem9udGFsKCk/KG4udHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIrcCtcInB4LCAwLCAwKVwiKSxuWzBdLnN0eWxlLndpZHRoPWQrXCJweFwiKToobi50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwcHgsIFwiK3ArXCJweCwgMClcIiksblswXS5zdHlsZS5oZWlnaHQ9ZCtcInB4XCIpLG8uaGlkZSYmKGNsZWFyVGltZW91dChlLnNjcm9sbGJhci50aW1lb3V0KSxsWzBdLnN0eWxlLm9wYWNpdHk9MSxlLnNjcm9sbGJhci50aW1lb3V0PXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7bFswXS5zdHlsZS5vcGFjaXR5PTAsbC50cmFuc2l0aW9uKDQwMCl9KSwxZTMpKX19LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0LnBhcmFtcy5zY3JvbGxiYXIuZWwmJnQuc2Nyb2xsYmFyLmVsJiZ0LnNjcm9sbGJhci4kZHJhZ0VsLnRyYW5zaXRpb24oZSl9LHVwZGF0ZVNpemU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKGUucGFyYW1zLnNjcm9sbGJhci5lbCYmZS5zY3JvbGxiYXIuZWwpe3ZhciB0PWUuc2Nyb2xsYmFyLGE9dC4kZHJhZ0VsLGk9dC4kZWw7YVswXS5zdHlsZS53aWR0aD1cIlwiLGFbMF0uc3R5bGUuaGVpZ2h0PVwiXCI7dmFyIHMscj1lLmlzSG9yaXpvbnRhbCgpP2lbMF0ub2Zmc2V0V2lkdGg6aVswXS5vZmZzZXRIZWlnaHQsbj1lLnNpemUvZS52aXJ0dWFsU2l6ZSxsPW4qKHIvZS5zaXplKTtzPVwiYXV0b1wiPT09ZS5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplP3IqbjpwYXJzZUludChlLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUsMTApLGUuaXNIb3Jpem9udGFsKCk/YVswXS5zdHlsZS53aWR0aD1zK1wicHhcIjphWzBdLnN0eWxlLmhlaWdodD1zK1wicHhcIixpWzBdLnN0eWxlLmRpc3BsYXk9bj49MT9cIm5vbmVcIjpcIlwiLGUucGFyYW1zLnNjcm9sbGJhci5oaWRlJiYoaVswXS5zdHlsZS5vcGFjaXR5PTApLFModCx7dHJhY2tTaXplOnIsZGl2aWRlcjpuLG1vdmVEaXZpZGVyOmwsZHJhZ1NpemU6c30pLHQuJGVsW2UucGFyYW1zLndhdGNoT3ZlcmZsb3cmJmUuaXNMb2NrZWQ/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0oZS5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcyl9fSxnZXRQb2ludGVyUG9zaXRpb246ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKCk/XCJ0b3VjaHN0YXJ0XCI9PT1lLnR5cGV8fFwidG91Y2htb3ZlXCI9PT1lLnR5cGU/ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFg6ZS5jbGllbnRYOlwidG91Y2hzdGFydFwiPT09ZS50eXBlfHxcInRvdWNobW92ZVwiPT09ZS50eXBlP2UudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZOmUuY2xpZW50WX0sc2V0RHJhZ1Bvc2l0aW9uOmZ1bmN0aW9uKGUpe3ZhciB0LGE9dGhpcyxpPWEuc2Nyb2xsYmFyLHM9YS5ydGxUcmFuc2xhdGUscj1pLiRlbCxuPWkuZHJhZ1NpemUsbD1pLnRyYWNrU2l6ZSxvPWkuZHJhZ1N0YXJ0UG9zO3Q9KGkuZ2V0UG9pbnRlclBvc2l0aW9uKGUpLXIub2Zmc2V0KClbYS5pc0hvcml6b250YWwoKT9cImxlZnRcIjpcInRvcFwiXS0obnVsbCE9PW8/bzpuLzIpKS8obC1uKSx0PU1hdGgubWF4KE1hdGgubWluKHQsMSksMCkscyYmKHQ9MS10KTt2YXIgZD1hLm1pblRyYW5zbGF0ZSgpKyhhLm1heFRyYW5zbGF0ZSgpLWEubWluVHJhbnNsYXRlKCkpKnQ7YS51cGRhdGVQcm9ncmVzcyhkKSxhLnNldFRyYW5zbGF0ZShkKSxhLnVwZGF0ZUFjdGl2ZUluZGV4KCksYS51cGRhdGVTbGlkZXNDbGFzc2VzKCl9LG9uRHJhZ1N0YXJ0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10LnBhcmFtcy5zY3JvbGxiYXIsaT10LnNjcm9sbGJhcixzPXQuJHdyYXBwZXJFbCxyPWkuJGVsLG49aS4kZHJhZ0VsO3Quc2Nyb2xsYmFyLmlzVG91Y2hlZD0hMCx0LnNjcm9sbGJhci5kcmFnU3RhcnRQb3M9ZS50YXJnZXQ9PT1uWzBdfHxlLnRhcmdldD09PW4/aS5nZXRQb2ludGVyUG9zaXRpb24oZSktZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdC5pc0hvcml6b250YWwoKT9cImxlZnRcIjpcInRvcFwiXTpudWxsLGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHMudHJhbnNpdGlvbigxMDApLG4udHJhbnNpdGlvbigxMDApLGkuc2V0RHJhZ1Bvc2l0aW9uKGUpLGNsZWFyVGltZW91dCh0LnNjcm9sbGJhci5kcmFnVGltZW91dCksci50cmFuc2l0aW9uKDApLGEuaGlkZSYmci5jc3MoXCJvcGFjaXR5XCIsMSksdC5wYXJhbXMuY3NzTW9kZSYmdC4kd3JhcHBlckVsLmNzcyhcInNjcm9sbC1zbmFwLXR5cGVcIixcIm5vbmVcIiksdC5lbWl0KFwic2Nyb2xsYmFyRHJhZ1N0YXJ0XCIsZSl9LG9uRHJhZ01vdmU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQuc2Nyb2xsYmFyLGk9dC4kd3JhcHBlckVsLHM9YS4kZWwscj1hLiRkcmFnRWw7dC5zY3JvbGxiYXIuaXNUb3VjaGVkJiYoZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6ZS5yZXR1cm5WYWx1ZT0hMSxhLnNldERyYWdQb3NpdGlvbihlKSxpLnRyYW5zaXRpb24oMCkscy50cmFuc2l0aW9uKDApLHIudHJhbnNpdGlvbigwKSx0LmVtaXQoXCJzY3JvbGxiYXJEcmFnTW92ZVwiLGUpKX0sb25EcmFnRW5kOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10LnBhcmFtcy5zY3JvbGxiYXIsaT10LnNjcm9sbGJhcixzPXQuJHdyYXBwZXJFbCxyPWkuJGVsO3Quc2Nyb2xsYmFyLmlzVG91Y2hlZCYmKHQuc2Nyb2xsYmFyLmlzVG91Y2hlZD0hMSx0LnBhcmFtcy5jc3NNb2RlJiYodC4kd3JhcHBlckVsLmNzcyhcInNjcm9sbC1zbmFwLXR5cGVcIixcIlwiKSxzLnRyYW5zaXRpb24oXCJcIikpLGEuaGlkZSYmKGNsZWFyVGltZW91dCh0LnNjcm9sbGJhci5kcmFnVGltZW91dCksdC5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQ9RSgoZnVuY3Rpb24oKXtyLmNzcyhcIm9wYWNpdHlcIiwwKSxyLnRyYW5zaXRpb24oNDAwKX0pLDFlMykpLHQuZW1pdChcInNjcm9sbGJhckRyYWdFbmRcIixlKSxhLnNuYXBPblJlbGVhc2UmJnQuc2xpZGVUb0Nsb3Nlc3QoKSl9LGVuYWJsZURyYWdnYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoZS5wYXJhbXMuc2Nyb2xsYmFyLmVsKXt2YXIgdD1yKCksYT1lLnNjcm9sbGJhcixpPWUudG91Y2hFdmVudHNUb3VjaCxzPWUudG91Y2hFdmVudHNEZXNrdG9wLG49ZS5wYXJhbXMsbD1lLnN1cHBvcnQsbz1hLiRlbFswXSxkPSEoIWwucGFzc2l2ZUxpc3RlbmVyfHwhbi5wYXNzaXZlTGlzdGVuZXJzKSYme3Bhc3NpdmU6ITEsY2FwdHVyZTohMX0scD0hKCFsLnBhc3NpdmVMaXN0ZW5lcnx8IW4ucGFzc2l2ZUxpc3RlbmVycykmJntwYXNzaXZlOiEwLGNhcHR1cmU6ITF9O2wudG91Y2g/KG8uYWRkRXZlbnRMaXN0ZW5lcihpLnN0YXJ0LGUuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LGQpLG8uYWRkRXZlbnRMaXN0ZW5lcihpLm1vdmUsZS5zY3JvbGxiYXIub25EcmFnTW92ZSxkKSxvLmFkZEV2ZW50TGlzdGVuZXIoaS5lbmQsZS5zY3JvbGxiYXIub25EcmFnRW5kLHApKTooby5hZGRFdmVudExpc3RlbmVyKHMuc3RhcnQsZS5zY3JvbGxiYXIub25EcmFnU3RhcnQsZCksdC5hZGRFdmVudExpc3RlbmVyKHMubW92ZSxlLnNjcm9sbGJhci5vbkRyYWdNb3ZlLGQpLHQuYWRkRXZlbnRMaXN0ZW5lcihzLmVuZCxlLnNjcm9sbGJhci5vbkRyYWdFbmQscCkpfX0sZGlzYWJsZURyYWdnYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoZS5wYXJhbXMuc2Nyb2xsYmFyLmVsKXt2YXIgdD1yKCksYT1lLnNjcm9sbGJhcixpPWUudG91Y2hFdmVudHNUb3VjaCxzPWUudG91Y2hFdmVudHNEZXNrdG9wLG49ZS5wYXJhbXMsbD1lLnN1cHBvcnQsbz1hLiRlbFswXSxkPSEoIWwucGFzc2l2ZUxpc3RlbmVyfHwhbi5wYXNzaXZlTGlzdGVuZXJzKSYme3Bhc3NpdmU6ITEsY2FwdHVyZTohMX0scD0hKCFsLnBhc3NpdmVMaXN0ZW5lcnx8IW4ucGFzc2l2ZUxpc3RlbmVycykmJntwYXNzaXZlOiEwLGNhcHR1cmU6ITF9O2wudG91Y2g/KG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLnN0YXJ0LGUuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LGQpLG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLm1vdmUsZS5zY3JvbGxiYXIub25EcmFnTW92ZSxkKSxvLnJlbW92ZUV2ZW50TGlzdGVuZXIoaS5lbmQsZS5zY3JvbGxiYXIub25EcmFnRW5kLHApKTooby5yZW1vdmVFdmVudExpc3RlbmVyKHMuc3RhcnQsZS5zY3JvbGxiYXIub25EcmFnU3RhcnQsZCksdC5yZW1vdmVFdmVudExpc3RlbmVyKHMubW92ZSxlLnNjcm9sbGJhci5vbkRyYWdNb3ZlLGQpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihzLmVuZCxlLnNjcm9sbGJhci5vbkRyYWdFbmQscCkpfX0saW5pdDpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoZS5wYXJhbXMuc2Nyb2xsYmFyLmVsKXt2YXIgdD1lLnNjcm9sbGJhcixhPWUuJGVsLGk9ZS5wYXJhbXMuc2Nyb2xsYmFyLHM9bShpLmVsKTtlLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyYmXCJzdHJpbmdcIj09dHlwZW9mIGkuZWwmJnMubGVuZ3RoPjEmJjE9PT1hLmZpbmQoaS5lbCkubGVuZ3RoJiYocz1hLmZpbmQoaS5lbCkpO3ZhciByPXMuZmluZChcIi5cIitlLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzKTswPT09ci5sZW5ndGgmJihyPW0oJzxkaXYgY2xhc3M9XCInK2UucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3MrJ1wiPjwvZGl2PicpLHMuYXBwZW5kKHIpKSxTKHQseyRlbDpzLGVsOnNbMF0sJGRyYWdFbDpyLGRyYWdFbDpyWzBdfSksaS5kcmFnZ2FibGUmJnQuZW5hYmxlRHJhZ2dhYmxlKCl9fSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5zY3JvbGxiYXIuZGlzYWJsZURyYWdnYWJsZSgpfX0sUT17c2V0VHJhbnNmb3JtOmZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpcy5ydGwsaT1tKGUpLHM9YT8tMToxLHI9aS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXhcIil8fFwiMFwiLG49aS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgteFwiKSxsPWkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LXlcIiksbz1pLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZVwiKSxkPWkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHlcIik7aWYobnx8bD8obj1ufHxcIjBcIixsPWx8fFwiMFwiKTp0aGlzLmlzSG9yaXpvbnRhbCgpPyhuPXIsbD1cIjBcIik6KGw9cixuPVwiMFwiKSxuPW4uaW5kZXhPZihcIiVcIik+PTA/cGFyc2VJbnQobiwxMCkqdCpzK1wiJVwiOm4qdCpzK1wicHhcIixsPWwuaW5kZXhPZihcIiVcIik+PTA/cGFyc2VJbnQobCwxMCkqdCtcIiVcIjpsKnQrXCJweFwiLG51bGwhPWQpe3ZhciBwPWQtKGQtMSkqKDEtTWF0aC5hYnModCkpO2lbMF0uc3R5bGUub3BhY2l0eT1wfWlmKG51bGw9PW8paS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIituK1wiLCBcIitsK1wiLCAwcHgpXCIpO2Vsc2V7dmFyIHU9by0oby0xKSooMS1NYXRoLmFicyh0KSk7aS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIituK1wiLCBcIitsK1wiLCAwcHgpIHNjYWxlKFwiK3UrXCIpXCIpfX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWUuJGVsLGE9ZS5zbGlkZXMsaT1lLnByb2dyZXNzLHM9ZS5zbmFwR3JpZDt0LmNoaWxkcmVuKFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiKS5lYWNoKChmdW5jdGlvbih0KXtlLnBhcmFsbGF4LnNldFRyYW5zZm9ybSh0LGkpfSkpLGEuZWFjaCgoZnVuY3Rpb24odCxhKXt2YXIgcj10LnByb2dyZXNzO2UucGFyYW1zLnNsaWRlc1Blckdyb3VwPjEmJlwiYXV0b1wiIT09ZS5wYXJhbXMuc2xpZGVzUGVyVmlldyYmKHIrPU1hdGguY2VpbChhLzIpLWkqKHMubGVuZ3RoLTEpKSxyPU1hdGgubWluKE1hdGgubWF4KHIsLTEpLDEpLG0odCkuZmluZChcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZV1cIikuZWFjaCgoZnVuY3Rpb24odCl7ZS5wYXJhbGxheC5zZXRUcmFuc2Zvcm0odCxyKX0pKX0pKX0sc2V0VHJhbnNpdGlvbjpmdW5jdGlvbihlKXt2b2lkIDA9PT1lJiYoZT10aGlzLnBhcmFtcy5zcGVlZCk7dGhpcy4kZWwuZmluZChcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZV1cIikuZWFjaCgoZnVuY3Rpb24odCl7dmFyIGE9bSh0KSxpPXBhcnNlSW50KGEuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LWR1cmF0aW9uXCIpLDEwKXx8ZTswPT09ZSYmKGk9MCksYS50cmFuc2l0aW9uKGkpfSkpfX0sZWU9e2dldERpc3RhbmNlQmV0d2VlblRvdWNoZXM6ZnVuY3Rpb24oZSl7aWYoZS50YXJnZXRUb3VjaGVzLmxlbmd0aDwyKXJldHVybiAxO3ZhciB0PWUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCxhPWUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSxpPWUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWCxzPWUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGktdCwyKStNYXRoLnBvdyhzLWEsMikpfSxvbkdlc3R1cmVTdGFydDpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dC5zdXBwb3J0LGk9dC5wYXJhbXMuem9vbSxzPXQuem9vbSxyPXMuZ2VzdHVyZTtpZihzLmZha2VHZXN0dXJlVG91Y2hlZD0hMSxzLmZha2VHZXN0dXJlTW92ZWQ9ITEsIWEuZ2VzdHVyZXMpe2lmKFwidG91Y2hzdGFydFwiIT09ZS50eXBlfHxcInRvdWNoc3RhcnRcIj09PWUudHlwZSYmZS50YXJnZXRUb3VjaGVzLmxlbmd0aDwyKXJldHVybjtzLmZha2VHZXN0dXJlVG91Y2hlZD0hMCxyLnNjYWxlU3RhcnQ9ZWUuZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcyhlKX1yLiRzbGlkZUVsJiZyLiRzbGlkZUVsLmxlbmd0aHx8KHIuJHNsaWRlRWw9bShlLnRhcmdldCkuY2xvc2VzdChcIi5cIit0LnBhcmFtcy5zbGlkZUNsYXNzKSwwPT09ci4kc2xpZGVFbC5sZW5ndGgmJihyLiRzbGlkZUVsPXQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpKSxyLiRpbWFnZUVsPXIuJHNsaWRlRWwuZmluZChcImltZywgc3ZnLCBjYW52YXMsIHBpY3R1cmUsIC5zd2lwZXItem9vbS10YXJnZXRcIiksci4kaW1hZ2VXcmFwRWw9ci4kaW1hZ2VFbC5wYXJlbnQoXCIuXCIraS5jb250YWluZXJDbGFzcyksci5tYXhSYXRpbz1yLiRpbWFnZVdyYXBFbC5hdHRyKFwiZGF0YS1zd2lwZXItem9vbVwiKXx8aS5tYXhSYXRpbywwIT09ci4kaW1hZ2VXcmFwRWwubGVuZ3RoKT8oci4kaW1hZ2VFbCYmci4kaW1hZ2VFbC50cmFuc2l0aW9uKDApLHQuem9vbS5pc1NjYWxpbmc9ITApOnIuJGltYWdlRWw9dm9pZCAwfSxvbkdlc3R1cmVDaGFuZ2U6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQuc3VwcG9ydCxpPXQucGFyYW1zLnpvb20scz10Lnpvb20scj1zLmdlc3R1cmU7aWYoIWEuZ2VzdHVyZXMpe2lmKFwidG91Y2htb3ZlXCIhPT1lLnR5cGV8fFwidG91Y2htb3ZlXCI9PT1lLnR5cGUmJmUudGFyZ2V0VG91Y2hlcy5sZW5ndGg8MilyZXR1cm47cy5mYWtlR2VzdHVyZU1vdmVkPSEwLHIuc2NhbGVNb3ZlPWVlLmdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSl9ci4kaW1hZ2VFbCYmMCE9PXIuJGltYWdlRWwubGVuZ3RoPyhhLmdlc3R1cmVzP3Muc2NhbGU9ZS5zY2FsZSpzLmN1cnJlbnRTY2FsZTpzLnNjYWxlPXIuc2NhbGVNb3ZlL3Iuc2NhbGVTdGFydCpzLmN1cnJlbnRTY2FsZSxzLnNjYWxlPnIubWF4UmF0aW8mJihzLnNjYWxlPXIubWF4UmF0aW8tMStNYXRoLnBvdyhzLnNjYWxlLXIubWF4UmF0aW8rMSwuNSkpLHMuc2NhbGU8aS5taW5SYXRpbyYmKHMuc2NhbGU9aS5taW5SYXRpbysxLU1hdGgucG93KGkubWluUmF0aW8tcy5zY2FsZSsxLC41KSksci4kaW1hZ2VFbC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoXCIrcy5zY2FsZStcIilcIikpOlwiZ2VzdHVyZWNoYW5nZVwiPT09ZS50eXBlJiZzLm9uR2VzdHVyZVN0YXJ0KGUpfSxvbkdlc3R1cmVFbmQ6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQuZGV2aWNlLGk9dC5zdXBwb3J0LHM9dC5wYXJhbXMuem9vbSxyPXQuem9vbSxuPXIuZ2VzdHVyZTtpZighaS5nZXN0dXJlcyl7aWYoIXIuZmFrZUdlc3R1cmVUb3VjaGVkfHwhci5mYWtlR2VzdHVyZU1vdmVkKXJldHVybjtpZihcInRvdWNoZW5kXCIhPT1lLnR5cGV8fFwidG91Y2hlbmRcIj09PWUudHlwZSYmZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg8MiYmIWEuYW5kcm9pZClyZXR1cm47ci5mYWtlR2VzdHVyZVRvdWNoZWQ9ITEsci5mYWtlR2VzdHVyZU1vdmVkPSExfW4uJGltYWdlRWwmJjAhPT1uLiRpbWFnZUVsLmxlbmd0aCYmKHIuc2NhbGU9TWF0aC5tYXgoTWF0aC5taW4oci5zY2FsZSxuLm1heFJhdGlvKSxzLm1pblJhdGlvKSxuLiRpbWFnZUVsLnRyYW5zaXRpb24odC5wYXJhbXMuc3BlZWQpLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZShcIityLnNjYWxlK1wiKVwiKSxyLmN1cnJlbnRTY2FsZT1yLnNjYWxlLHIuaXNTY2FsaW5nPSExLDE9PT1yLnNjYWxlJiYobi4kc2xpZGVFbD12b2lkIDApKX0sb25Ub3VjaFN0YXJ0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZGV2aWNlLGE9dGhpcy56b29tLGk9YS5nZXN0dXJlLHM9YS5pbWFnZTtpLiRpbWFnZUVsJiYwIT09aS4kaW1hZ2VFbC5sZW5ndGgmJihzLmlzVG91Y2hlZHx8KHQuYW5kcm9pZCYmZS5jYW5jZWxhYmxlJiZlLnByZXZlbnREZWZhdWx0KCkscy5pc1RvdWNoZWQ9ITAscy50b3VjaGVzU3RhcnQueD1cInRvdWNoc3RhcnRcIj09PWUudHlwZT9lLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg6ZS5wYWdlWCxzLnRvdWNoZXNTdGFydC55PVwidG91Y2hzdGFydFwiPT09ZS50eXBlP2UudGFyZ2V0VG91Y2hlc1swXS5wYWdlWTplLnBhZ2VZKSl9LG9uVG91Y2hNb3ZlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10Lnpvb20saT1hLmdlc3R1cmUscz1hLmltYWdlLHI9YS52ZWxvY2l0eTtpZihpLiRpbWFnZUVsJiYwIT09aS4kaW1hZ2VFbC5sZW5ndGgmJih0LmFsbG93Q2xpY2s9ITEscy5pc1RvdWNoZWQmJmkuJHNsaWRlRWwpKXtzLmlzTW92ZWR8fChzLndpZHRoPWkuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGgscy5oZWlnaHQ9aS4kaW1hZ2VFbFswXS5vZmZzZXRIZWlnaHQscy5zdGFydFg9VChpLiRpbWFnZVdyYXBFbFswXSxcInhcIil8fDAscy5zdGFydFk9VChpLiRpbWFnZVdyYXBFbFswXSxcInlcIil8fDAsaS5zbGlkZVdpZHRoPWkuJHNsaWRlRWxbMF0ub2Zmc2V0V2lkdGgsaS5zbGlkZUhlaWdodD1pLiRzbGlkZUVsWzBdLm9mZnNldEhlaWdodCxpLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDApLHQucnRsJiYocy5zdGFydFg9LXMuc3RhcnRYLHMuc3RhcnRZPS1zLnN0YXJ0WSkpO3ZhciBuPXMud2lkdGgqYS5zY2FsZSxsPXMuaGVpZ2h0KmEuc2NhbGU7aWYoIShuPGkuc2xpZGVXaWR0aCYmbDxpLnNsaWRlSGVpZ2h0KSl7aWYocy5taW5YPU1hdGgubWluKGkuc2xpZGVXaWR0aC8yLW4vMiwwKSxzLm1heFg9LXMubWluWCxzLm1pblk9TWF0aC5taW4oaS5zbGlkZUhlaWdodC8yLWwvMiwwKSxzLm1heFk9LXMubWluWSxzLnRvdWNoZXNDdXJyZW50Lng9XCJ0b3VjaG1vdmVcIj09PWUudHlwZT9lLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg6ZS5wYWdlWCxzLnRvdWNoZXNDdXJyZW50Lnk9XCJ0b3VjaG1vdmVcIj09PWUudHlwZT9lLnRhcmdldFRvdWNoZXNbMF0ucGFnZVk6ZS5wYWdlWSwhcy5pc01vdmVkJiYhYS5pc1NjYWxpbmcpe2lmKHQuaXNIb3Jpem9udGFsKCkmJihNYXRoLmZsb29yKHMubWluWCk9PT1NYXRoLmZsb29yKHMuc3RhcnRYKSYmcy50b3VjaGVzQ3VycmVudC54PHMudG91Y2hlc1N0YXJ0Lnh8fE1hdGguZmxvb3Iocy5tYXhYKT09PU1hdGguZmxvb3Iocy5zdGFydFgpJiZzLnRvdWNoZXNDdXJyZW50Lng+cy50b3VjaGVzU3RhcnQueCkpcmV0dXJuIHZvaWQocy5pc1RvdWNoZWQ9ITEpO2lmKCF0LmlzSG9yaXpvbnRhbCgpJiYoTWF0aC5mbG9vcihzLm1pblkpPT09TWF0aC5mbG9vcihzLnN0YXJ0WSkmJnMudG91Y2hlc0N1cnJlbnQueTxzLnRvdWNoZXNTdGFydC55fHxNYXRoLmZsb29yKHMubWF4WSk9PT1NYXRoLmZsb29yKHMuc3RhcnRZKSYmcy50b3VjaGVzQ3VycmVudC55PnMudG91Y2hlc1N0YXJ0LnkpKXJldHVybiB2b2lkKHMuaXNUb3VjaGVkPSExKX1lLmNhbmNlbGFibGUmJmUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHMuaXNNb3ZlZD0hMCxzLmN1cnJlbnRYPXMudG91Y2hlc0N1cnJlbnQueC1zLnRvdWNoZXNTdGFydC54K3Muc3RhcnRYLHMuY3VycmVudFk9cy50b3VjaGVzQ3VycmVudC55LXMudG91Y2hlc1N0YXJ0Lnkrcy5zdGFydFkscy5jdXJyZW50WDxzLm1pblgmJihzLmN1cnJlbnRYPXMubWluWCsxLU1hdGgucG93KHMubWluWC1zLmN1cnJlbnRYKzEsLjgpKSxzLmN1cnJlbnRYPnMubWF4WCYmKHMuY3VycmVudFg9cy5tYXhYLTErTWF0aC5wb3cocy5jdXJyZW50WC1zLm1heFgrMSwuOCkpLHMuY3VycmVudFk8cy5taW5ZJiYocy5jdXJyZW50WT1zLm1pblkrMS1NYXRoLnBvdyhzLm1pblktcy5jdXJyZW50WSsxLC44KSkscy5jdXJyZW50WT5zLm1heFkmJihzLmN1cnJlbnRZPXMubWF4WS0xK01hdGgucG93KHMuY3VycmVudFktcy5tYXhZKzEsLjgpKSxyLnByZXZQb3NpdGlvblh8fChyLnByZXZQb3NpdGlvblg9cy50b3VjaGVzQ3VycmVudC54KSxyLnByZXZQb3NpdGlvbll8fChyLnByZXZQb3NpdGlvblk9cy50b3VjaGVzQ3VycmVudC55KSxyLnByZXZUaW1lfHwoci5wcmV2VGltZT1EYXRlLm5vdygpKSxyLng9KHMudG91Y2hlc0N1cnJlbnQueC1yLnByZXZQb3NpdGlvblgpLyhEYXRlLm5vdygpLXIucHJldlRpbWUpLzIsci55PShzLnRvdWNoZXNDdXJyZW50Lnktci5wcmV2UG9zaXRpb25ZKS8oRGF0ZS5ub3coKS1yLnByZXZUaW1lKS8yLE1hdGguYWJzKHMudG91Y2hlc0N1cnJlbnQueC1yLnByZXZQb3NpdGlvblgpPDImJihyLng9MCksTWF0aC5hYnMocy50b3VjaGVzQ3VycmVudC55LXIucHJldlBvc2l0aW9uWSk8MiYmKHIueT0wKSxyLnByZXZQb3NpdGlvblg9cy50b3VjaGVzQ3VycmVudC54LHIucHJldlBvc2l0aW9uWT1zLnRvdWNoZXNDdXJyZW50Lnksci5wcmV2VGltZT1EYXRlLm5vdygpLGkuJGltYWdlV3JhcEVsLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiK3MuY3VycmVudFgrXCJweCwgXCIrcy5jdXJyZW50WStcInB4LDApXCIpfX19LG9uVG91Y2hFbmQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnpvb20sdD1lLmdlc3R1cmUsYT1lLmltYWdlLGk9ZS52ZWxvY2l0eTtpZih0LiRpbWFnZUVsJiYwIT09dC4kaW1hZ2VFbC5sZW5ndGgpe2lmKCFhLmlzVG91Y2hlZHx8IWEuaXNNb3ZlZClyZXR1cm4gYS5pc1RvdWNoZWQ9ITEsdm9pZChhLmlzTW92ZWQ9ITEpO2EuaXNUb3VjaGVkPSExLGEuaXNNb3ZlZD0hMTt2YXIgcz0zMDAscj0zMDAsbj1pLngqcyxsPWEuY3VycmVudFgrbixvPWkueSpyLGQ9YS5jdXJyZW50WStvOzAhPT1pLngmJihzPU1hdGguYWJzKChsLWEuY3VycmVudFgpL2kueCkpLDAhPT1pLnkmJihyPU1hdGguYWJzKChkLWEuY3VycmVudFkpL2kueSkpO3ZhciBwPU1hdGgubWF4KHMscik7YS5jdXJyZW50WD1sLGEuY3VycmVudFk9ZDt2YXIgdT1hLndpZHRoKmUuc2NhbGUsYz1hLmhlaWdodCplLnNjYWxlO2EubWluWD1NYXRoLm1pbih0LnNsaWRlV2lkdGgvMi11LzIsMCksYS5tYXhYPS1hLm1pblgsYS5taW5ZPU1hdGgubWluKHQuc2xpZGVIZWlnaHQvMi1jLzIsMCksYS5tYXhZPS1hLm1pblksYS5jdXJyZW50WD1NYXRoLm1heChNYXRoLm1pbihhLmN1cnJlbnRYLGEubWF4WCksYS5taW5YKSxhLmN1cnJlbnRZPU1hdGgubWF4KE1hdGgubWluKGEuY3VycmVudFksYS5tYXhZKSxhLm1pblkpLHQuJGltYWdlV3JhcEVsLnRyYW5zaXRpb24ocCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIrYS5jdXJyZW50WCtcInB4LCBcIithLmN1cnJlbnRZK1wicHgsMClcIil9fSxvblRyYW5zaXRpb25FbmQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS56b29tLGE9dC5nZXN0dXJlO2EuJHNsaWRlRWwmJmUucHJldmlvdXNJbmRleCE9PWUuYWN0aXZlSW5kZXgmJihhLiRpbWFnZUVsJiZhLiRpbWFnZUVsLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKVwiKSxhLiRpbWFnZVdyYXBFbCYmYS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApXCIpLHQuc2NhbGU9MSx0LmN1cnJlbnRTY2FsZT0xLGEuJHNsaWRlRWw9dm9pZCAwLGEuJGltYWdlRWw9dm9pZCAwLGEuJGltYWdlV3JhcEVsPXZvaWQgMCl9LHRvZ2dsZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLnpvb207dC5zY2FsZSYmMSE9PXQuc2NhbGU/dC5vdXQoKTp0LmluKGUpfSxpbjpmdW5jdGlvbihlKXt2YXIgdCxhLGkscyxyLG4sbCxvLGQscCx1LGMsaCx2LGYsbSxnPXRoaXMseT1nLnpvb20sdz1nLnBhcmFtcy56b29tLGI9eS5nZXN0dXJlLEU9eS5pbWFnZTsoYi4kc2xpZGVFbHx8KGcucGFyYW1zLnZpcnR1YWwmJmcucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCYmZy52aXJ0dWFsP2IuJHNsaWRlRWw9Zy4kd3JhcHBlckVsLmNoaWxkcmVuKFwiLlwiK2cucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpOmIuJHNsaWRlRWw9Zy5zbGlkZXMuZXEoZy5hY3RpdmVJbmRleCksYi4kaW1hZ2VFbD1iLiRzbGlkZUVsLmZpbmQoXCJpbWcsIHN2ZywgY2FudmFzLCBwaWN0dXJlLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCIpLGIuJGltYWdlV3JhcEVsPWIuJGltYWdlRWwucGFyZW50KFwiLlwiK3cuY29udGFpbmVyQ2xhc3MpKSxiLiRpbWFnZUVsJiYwIT09Yi4kaW1hZ2VFbC5sZW5ndGgpJiYoYi4kc2xpZGVFbC5hZGRDbGFzcyhcIlwiK3cuem9vbWVkU2xpZGVDbGFzcyksdm9pZCAwPT09RS50b3VjaGVzU3RhcnQueCYmZT8odD1cInRvdWNoZW5kXCI9PT1lLnR5cGU/ZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDplLnBhZ2VYLGE9XCJ0b3VjaGVuZFwiPT09ZS50eXBlP2UuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk6ZS5wYWdlWSk6KHQ9RS50b3VjaGVzU3RhcnQueCxhPUUudG91Y2hlc1N0YXJ0LnkpLHkuc2NhbGU9Yi4kaW1hZ2VXcmFwRWwuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIil8fHcubWF4UmF0aW8seS5jdXJyZW50U2NhbGU9Yi4kaW1hZ2VXcmFwRWwuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIil8fHcubWF4UmF0aW8sZT8oZj1iLiRzbGlkZUVsWzBdLm9mZnNldFdpZHRoLG09Yi4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQsaT1iLiRzbGlkZUVsLm9mZnNldCgpLmxlZnQrZi8yLXQscz1iLiRzbGlkZUVsLm9mZnNldCgpLnRvcCttLzItYSxsPWIuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGgsbz1iLiRpbWFnZUVsWzBdLm9mZnNldEhlaWdodCxkPWwqeS5zY2FsZSxwPW8qeS5zY2FsZSxoPS0odT1NYXRoLm1pbihmLzItZC8yLDApKSx2PS0oYz1NYXRoLm1pbihtLzItcC8yLDApKSwocj1pKnkuc2NhbGUpPHUmJihyPXUpLHI+aCYmKHI9aCksKG49cyp5LnNjYWxlKTxjJiYobj1jKSxuPnYmJihuPXYpKToocj0wLG49MCksYi4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKFwiK3IrXCJweCwgXCIrbitcInB4LDApXCIpLGIuJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZShcIit5LnNjYWxlK1wiKVwiKSl9LG91dDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnpvb20sYT1lLnBhcmFtcy56b29tLGk9dC5nZXN0dXJlO2kuJHNsaWRlRWx8fChlLnBhcmFtcy52aXJ0dWFsJiZlLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQmJmUudmlydHVhbD9pLiRzbGlkZUVsPWUuJHdyYXBwZXJFbC5jaGlsZHJlbihcIi5cIitlLnBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKTppLiRzbGlkZUVsPWUuc2xpZGVzLmVxKGUuYWN0aXZlSW5kZXgpLGkuJGltYWdlRWw9aS4kc2xpZGVFbC5maW5kKFwiaW1nLCBzdmcsIGNhbnZhcywgcGljdHVyZSwgLnN3aXBlci16b29tLXRhcmdldFwiKSxpLiRpbWFnZVdyYXBFbD1pLiRpbWFnZUVsLnBhcmVudChcIi5cIithLmNvbnRhaW5lckNsYXNzKSksaS4kaW1hZ2VFbCYmMCE9PWkuJGltYWdlRWwubGVuZ3RoJiYodC5zY2FsZT0xLHQuY3VycmVudFNjYWxlPTEsaS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKVwiKSxpLiRpbWFnZUVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSlcIiksaS4kc2xpZGVFbC5yZW1vdmVDbGFzcyhcIlwiK2Euem9vbWVkU2xpZGVDbGFzcyksaS4kc2xpZGVFbD12b2lkIDApfSx0b2dnbGVHZXN0dXJlczpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dC56b29tLGk9YS5zbGlkZVNlbGVjdG9yLHM9YS5wYXNzaXZlTGlzdGVuZXI7dC4kd3JhcHBlckVsW2VdKFwiZ2VzdHVyZXN0YXJ0XCIsaSxhLm9uR2VzdHVyZVN0YXJ0LHMpLHQuJHdyYXBwZXJFbFtlXShcImdlc3R1cmVjaGFuZ2VcIixpLGEub25HZXN0dXJlQ2hhbmdlLHMpLHQuJHdyYXBwZXJFbFtlXShcImdlc3R1cmVlbmRcIixpLGEub25HZXN0dXJlRW5kLHMpfSxlbmFibGVHZXN0dXJlczpmdW5jdGlvbigpe3RoaXMuem9vbS5nZXN0dXJlc0VuYWJsZWR8fCh0aGlzLnpvb20uZ2VzdHVyZXNFbmFibGVkPSEwLHRoaXMuem9vbS50b2dnbGVHZXN0dXJlcyhcIm9uXCIpKX0sZGlzYWJsZUdlc3R1cmVzOmZ1bmN0aW9uKCl7dGhpcy56b29tLmdlc3R1cmVzRW5hYmxlZCYmKHRoaXMuem9vbS5nZXN0dXJlc0VuYWJsZWQ9ITEsdGhpcy56b29tLnRvZ2dsZUdlc3R1cmVzKFwib2ZmXCIpKX0sZW5hYmxlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWUuc3VwcG9ydCxhPWUuem9vbTtpZighYS5lbmFibGVkKXthLmVuYWJsZWQ9ITA7dmFyIGk9IShcInRvdWNoc3RhcnRcIiE9PWUudG91Y2hFdmVudHMuc3RhcnR8fCF0LnBhc3NpdmVMaXN0ZW5lcnx8IWUucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpJiZ7cGFzc2l2ZTohMCxjYXB0dXJlOiExfSxzPSF0LnBhc3NpdmVMaXN0ZW5lcnx8e3Bhc3NpdmU6ITEsY2FwdHVyZTohMH0scj1cIi5cIitlLnBhcmFtcy5zbGlkZUNsYXNzO2Uuem9vbS5wYXNzaXZlTGlzdGVuZXI9aSxlLnpvb20uc2xpZGVTZWxlY3Rvcj1yLHQuZ2VzdHVyZXM/KGUuJHdyYXBwZXJFbC5vbihlLnRvdWNoRXZlbnRzLnN0YXJ0LGUuem9vbS5lbmFibGVHZXN0dXJlcyxpKSxlLiR3cmFwcGVyRWwub24oZS50b3VjaEV2ZW50cy5lbmQsZS56b29tLmRpc2FibGVHZXN0dXJlcyxpKSk6XCJ0b3VjaHN0YXJ0XCI9PT1lLnRvdWNoRXZlbnRzLnN0YXJ0JiYoZS4kd3JhcHBlckVsLm9uKGUudG91Y2hFdmVudHMuc3RhcnQscixhLm9uR2VzdHVyZVN0YXJ0LGkpLGUuJHdyYXBwZXJFbC5vbihlLnRvdWNoRXZlbnRzLm1vdmUscixhLm9uR2VzdHVyZUNoYW5nZSxzKSxlLiR3cmFwcGVyRWwub24oZS50b3VjaEV2ZW50cy5lbmQscixhLm9uR2VzdHVyZUVuZCxpKSxlLnRvdWNoRXZlbnRzLmNhbmNlbCYmZS4kd3JhcHBlckVsLm9uKGUudG91Y2hFdmVudHMuY2FuY2VsLHIsYS5vbkdlc3R1cmVFbmQsaSkpLGUuJHdyYXBwZXJFbC5vbihlLnRvdWNoRXZlbnRzLm1vdmUsXCIuXCIrZS5wYXJhbXMuem9vbS5jb250YWluZXJDbGFzcyxhLm9uVG91Y2hNb3ZlLHMpfX0sZGlzYWJsZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnpvb207aWYodC5lbmFibGVkKXt2YXIgYT1lLnN1cHBvcnQ7ZS56b29tLmVuYWJsZWQ9ITE7dmFyIGk9IShcInRvdWNoc3RhcnRcIiE9PWUudG91Y2hFdmVudHMuc3RhcnR8fCFhLnBhc3NpdmVMaXN0ZW5lcnx8IWUucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpJiZ7cGFzc2l2ZTohMCxjYXB0dXJlOiExfSxzPSFhLnBhc3NpdmVMaXN0ZW5lcnx8e3Bhc3NpdmU6ITEsY2FwdHVyZTohMH0scj1cIi5cIitlLnBhcmFtcy5zbGlkZUNsYXNzO2EuZ2VzdHVyZXM/KGUuJHdyYXBwZXJFbC5vZmYoZS50b3VjaEV2ZW50cy5zdGFydCxlLnpvb20uZW5hYmxlR2VzdHVyZXMsaSksZS4kd3JhcHBlckVsLm9mZihlLnRvdWNoRXZlbnRzLmVuZCxlLnpvb20uZGlzYWJsZUdlc3R1cmVzLGkpKTpcInRvdWNoc3RhcnRcIj09PWUudG91Y2hFdmVudHMuc3RhcnQmJihlLiR3cmFwcGVyRWwub2ZmKGUudG91Y2hFdmVudHMuc3RhcnQscix0Lm9uR2VzdHVyZVN0YXJ0LGkpLGUuJHdyYXBwZXJFbC5vZmYoZS50b3VjaEV2ZW50cy5tb3ZlLHIsdC5vbkdlc3R1cmVDaGFuZ2UscyksZS4kd3JhcHBlckVsLm9mZihlLnRvdWNoRXZlbnRzLmVuZCxyLHQub25HZXN0dXJlRW5kLGkpLGUudG91Y2hFdmVudHMuY2FuY2VsJiZlLiR3cmFwcGVyRWwub2ZmKGUudG91Y2hFdmVudHMuY2FuY2VsLHIsdC5vbkdlc3R1cmVFbmQsaSkpLGUuJHdyYXBwZXJFbC5vZmYoZS50b3VjaEV2ZW50cy5tb3ZlLFwiLlwiK2UucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3MsdC5vblRvdWNoTW92ZSxzKX19fSx0ZT17bG9hZEluU2xpZGU6ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMCk7dmFyIGE9dGhpcyxpPWEucGFyYW1zLmxhenk7aWYodm9pZCAwIT09ZSYmMCE9PWEuc2xpZGVzLmxlbmd0aCl7dmFyIHM9YS52aXJ0dWFsJiZhLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ/YS4kd3JhcHBlckVsLmNoaWxkcmVuKFwiLlwiK2EucGFyYW1zLnNsaWRlQ2xhc3MrJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrZSsnXCJdJyk6YS5zbGlkZXMuZXEoZSkscj1zLmZpbmQoXCIuXCIraS5lbGVtZW50Q2xhc3MrXCI6bm90KC5cIitpLmxvYWRlZENsYXNzK1wiKTpub3QoLlwiK2kubG9hZGluZ0NsYXNzK1wiKVwiKTshcy5oYXNDbGFzcyhpLmVsZW1lbnRDbGFzcyl8fHMuaGFzQ2xhc3MoaS5sb2FkZWRDbGFzcyl8fHMuaGFzQ2xhc3MoaS5sb2FkaW5nQ2xhc3MpfHxyLnB1c2goc1swXSksMCE9PXIubGVuZ3RoJiZyLmVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPW0oZSk7ci5hZGRDbGFzcyhpLmxvYWRpbmdDbGFzcyk7dmFyIG49ci5hdHRyKFwiZGF0YS1iYWNrZ3JvdW5kXCIpLGw9ci5hdHRyKFwiZGF0YS1zcmNcIiksbz1yLmF0dHIoXCJkYXRhLXNyY3NldFwiKSxkPXIuYXR0cihcImRhdGEtc2l6ZXNcIikscD1yLnBhcmVudChcInBpY3R1cmVcIik7YS5sb2FkSW1hZ2UoclswXSxsfHxuLG8sZCwhMSwoZnVuY3Rpb24oKXtpZihudWxsIT1hJiZhJiYoIWF8fGEucGFyYW1zKSYmIWEuZGVzdHJveWVkKXtpZihuPyhyLmNzcyhcImJhY2tncm91bmQtaW1hZ2VcIiwndXJsKFwiJytuKydcIiknKSxyLnJlbW92ZUF0dHIoXCJkYXRhLWJhY2tncm91bmRcIikpOihvJiYoci5hdHRyKFwic3Jjc2V0XCIsbyksci5yZW1vdmVBdHRyKFwiZGF0YS1zcmNzZXRcIikpLGQmJihyLmF0dHIoXCJzaXplc1wiLGQpLHIucmVtb3ZlQXR0cihcImRhdGEtc2l6ZXNcIikpLHAubGVuZ3RoJiZwLmNoaWxkcmVuKFwic291cmNlXCIpLmVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PW0oZSk7dC5hdHRyKFwiZGF0YS1zcmNzZXRcIikmJih0LmF0dHIoXCJzcmNzZXRcIix0LmF0dHIoXCJkYXRhLXNyY3NldFwiKSksdC5yZW1vdmVBdHRyKFwiZGF0YS1zcmNzZXRcIikpfSkpLGwmJihyLmF0dHIoXCJzcmNcIixsKSxyLnJlbW92ZUF0dHIoXCJkYXRhLXNyY1wiKSkpLHIuYWRkQ2xhc3MoaS5sb2FkZWRDbGFzcykucmVtb3ZlQ2xhc3MoaS5sb2FkaW5nQ2xhc3MpLHMuZmluZChcIi5cIitpLnByZWxvYWRlckNsYXNzKS5yZW1vdmUoKSxhLnBhcmFtcy5sb29wJiZ0KXt2YXIgZT1zLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKTtpZihzLmhhc0NsYXNzKGEucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKXt2YXIgdT1hLiR3cmFwcGVyRWwuY2hpbGRyZW4oJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrZSsnXCJdOm5vdCguJythLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzK1wiKVwiKTthLmxhenkubG9hZEluU2xpZGUodS5pbmRleCgpLCExKX1lbHNle3ZhciBjPWEuJHdyYXBwZXJFbC5jaGlsZHJlbihcIi5cIithLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKydbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInK2UrJ1wiXScpO2EubGF6eS5sb2FkSW5TbGlkZShjLmluZGV4KCksITEpfX1hLmVtaXQoXCJsYXp5SW1hZ2VSZWFkeVwiLHNbMF0sclswXSksYS5wYXJhbXMuYXV0b0hlaWdodCYmYS51cGRhdGVBdXRvSGVpZ2h0KCl9fSkpLGEuZW1pdChcImxhenlJbWFnZUxvYWRcIixzWzBdLHJbMF0pfSkpfX0sbG9hZDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLiR3cmFwcGVyRWwsYT1lLnBhcmFtcyxpPWUuc2xpZGVzLHM9ZS5hY3RpdmVJbmRleCxyPWUudmlydHVhbCYmYS52aXJ0dWFsLmVuYWJsZWQsbj1hLmxhenksbD1hLnNsaWRlc1BlclZpZXc7ZnVuY3Rpb24gbyhlKXtpZihyKXtpZih0LmNoaWxkcmVuKFwiLlwiK2Euc2xpZGVDbGFzcysnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytlKydcIl0nKS5sZW5ndGgpcmV0dXJuITB9ZWxzZSBpZihpW2VdKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGQoZSl7cmV0dXJuIHI/bShlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIik6bShlKS5pbmRleCgpfWlmKFwiYXV0b1wiPT09bCYmKGw9MCksZS5sYXp5LmluaXRpYWxJbWFnZUxvYWRlZHx8KGUubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQ9ITApLGUucGFyYW1zLndhdGNoU2xpZGVzVmlzaWJpbGl0eSl0LmNoaWxkcmVuKFwiLlwiK2Euc2xpZGVWaXNpYmxlQ2xhc3MpLmVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPXI/bSh0KS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIik6bSh0KS5pbmRleCgpO2UubGF6eS5sb2FkSW5TbGlkZShhKX0pKTtlbHNlIGlmKGw+MSlmb3IodmFyIHA9cztwPHMrbDtwKz0xKW8ocCkmJmUubGF6eS5sb2FkSW5TbGlkZShwKTtlbHNlIGUubGF6eS5sb2FkSW5TbGlkZShzKTtpZihuLmxvYWRQcmV2TmV4dClpZihsPjF8fG4ubG9hZFByZXZOZXh0QW1vdW50JiZuLmxvYWRQcmV2TmV4dEFtb3VudD4xKXtmb3IodmFyIHU9bi5sb2FkUHJldk5leHRBbW91bnQsYz1sLGg9TWF0aC5taW4ocytjK01hdGgubWF4KHUsYyksaS5sZW5ndGgpLHY9TWF0aC5tYXgocy1NYXRoLm1heChjLHUpLDApLGY9cytsO2Y8aDtmKz0xKW8oZikmJmUubGF6eS5sb2FkSW5TbGlkZShmKTtmb3IodmFyIGc9djtnPHM7Zys9MSlvKGcpJiZlLmxhenkubG9hZEluU2xpZGUoZyl9ZWxzZXt2YXIgeT10LmNoaWxkcmVuKFwiLlwiK2Euc2xpZGVOZXh0Q2xhc3MpO3kubGVuZ3RoPjAmJmUubGF6eS5sb2FkSW5TbGlkZShkKHkpKTt2YXIgdz10LmNoaWxkcmVuKFwiLlwiK2Euc2xpZGVQcmV2Q2xhc3MpO3cubGVuZ3RoPjAmJmUubGF6eS5sb2FkSW5TbGlkZShkKHcpKX19LGNoZWNrSW5WaWV3T25Mb2FkOmZ1bmN0aW9uKCl7dmFyIGU9bCgpLHQ9dGhpcztpZih0JiYhdC5kZXN0cm95ZWQpe3ZhciBhPXQucGFyYW1zLmxhenkuc2Nyb2xsaW5nRWxlbWVudD9tKHQucGFyYW1zLmxhenkuc2Nyb2xsaW5nRWxlbWVudCk6bShlKSxpPWFbMF09PT1lLHM9aT9lLmlubmVyV2lkdGg6YVswXS5vZmZzZXRXaWR0aCxyPWk/ZS5pbm5lckhlaWdodDphWzBdLm9mZnNldEhlaWdodCxuPXQuJGVsLm9mZnNldCgpLG89ITE7dC5ydGxUcmFuc2xhdGUmJihuLmxlZnQtPXQuJGVsWzBdLnNjcm9sbExlZnQpO2Zvcih2YXIgZD1bW24ubGVmdCxuLnRvcF0sW24ubGVmdCt0LndpZHRoLG4udG9wXSxbbi5sZWZ0LG4udG9wK3QuaGVpZ2h0XSxbbi5sZWZ0K3Qud2lkdGgsbi50b3ArdC5oZWlnaHRdXSxwPTA7cDxkLmxlbmd0aDtwKz0xKXt2YXIgdT1kW3BdO2lmKHVbMF0+PTAmJnVbMF08PXMmJnVbMV0+PTAmJnVbMV08PXIpe2lmKDA9PT11WzBdJiYwPT09dVsxXSljb250aW51ZTtvPSEwfX1vPyh0LmxhenkubG9hZCgpLGEub2ZmKFwic2Nyb2xsXCIsdC5sYXp5LmNoZWNrSW5WaWV3T25Mb2FkKSk6dC5sYXp5LnNjcm9sbEhhbmRsZXJBdHRhY2hlZHx8KHQubGF6eS5zY3JvbGxIYW5kbGVyQXR0YWNoZWQ9ITAsYS5vbihcInNjcm9sbFwiLHQubGF6eS5jaGVja0luVmlld09uTG9hZCkpfX19LGFlPXtMaW5lYXJTcGxpbmU6ZnVuY3Rpb24oZSx0KXt2YXIgYSxpLHMscixuLGw9ZnVuY3Rpb24oZSx0KXtmb3IoaT0tMSxhPWUubGVuZ3RoO2EtaT4xOyllW3M9YStpPj4xXTw9dD9pPXM6YT1zO3JldHVybiBhfTtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy5sYXN0SW5kZXg9ZS5sZW5ndGgtMSx0aGlzLmludGVycG9sYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBlPyhuPWwodGhpcy54LGUpLHI9bi0xLChlLXRoaXMueFtyXSkqKHRoaXMueVtuXS10aGlzLnlbcl0pLyh0aGlzLnhbbl0tdGhpcy54W3JdKSt0aGlzLnlbcl0pOjB9LHRoaXN9LGdldEludGVycG9sYXRlRnVuY3Rpb246ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0LmNvbnRyb2xsZXIuc3BsaW5lfHwodC5jb250cm9sbGVyLnNwbGluZT10LnBhcmFtcy5sb29wP25ldyBhZS5MaW5lYXJTcGxpbmUodC5zbGlkZXNHcmlkLGUuc2xpZGVzR3JpZCk6bmV3IGFlLkxpbmVhclNwbGluZSh0LnNuYXBHcmlkLGUuc25hcEdyaWQpKX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKGUsdCl7dmFyIGEsaSxzPXRoaXMscj1zLmNvbnRyb2xsZXIuY29udHJvbCxuPXMuY29uc3RydWN0b3I7ZnVuY3Rpb24gbChlKXt2YXIgdD1zLnJ0bFRyYW5zbGF0ZT8tcy50cmFuc2xhdGU6cy50cmFuc2xhdGU7XCJzbGlkZVwiPT09cy5wYXJhbXMuY29udHJvbGxlci5ieSYmKHMuY29udHJvbGxlci5nZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uKGUpLGk9LXMuY29udHJvbGxlci5zcGxpbmUuaW50ZXJwb2xhdGUoLXQpKSxpJiZcImNvbnRhaW5lclwiIT09cy5wYXJhbXMuY29udHJvbGxlci5ieXx8KGE9KGUubWF4VHJhbnNsYXRlKCktZS5taW5UcmFuc2xhdGUoKSkvKHMubWF4VHJhbnNsYXRlKCktcy5taW5UcmFuc2xhdGUoKSksaT0odC1zLm1pblRyYW5zbGF0ZSgpKSphK2UubWluVHJhbnNsYXRlKCkpLHMucGFyYW1zLmNvbnRyb2xsZXIuaW52ZXJzZSYmKGk9ZS5tYXhUcmFuc2xhdGUoKS1pKSxlLnVwZGF0ZVByb2dyZXNzKGkpLGUuc2V0VHJhbnNsYXRlKGkscyksZS51cGRhdGVBY3RpdmVJbmRleCgpLGUudXBkYXRlU2xpZGVzQ2xhc3NlcygpfWlmKEFycmF5LmlzQXJyYXkocikpZm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKz0xKXJbb10hPT10JiZyW29daW5zdGFuY2VvZiBuJiZsKHJbb10pO2Vsc2UgciBpbnN0YW5jZW9mIG4mJnQhPT1yJiZsKHIpfSxzZXRUcmFuc2l0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIGEsaT10aGlzLHM9aS5jb25zdHJ1Y3RvcixyPWkuY29udHJvbGxlci5jb250cm9sO2Z1bmN0aW9uIG4odCl7dC5zZXRUcmFuc2l0aW9uKGUsaSksMCE9PWUmJih0LnRyYW5zaXRpb25TdGFydCgpLHQucGFyYW1zLmF1dG9IZWlnaHQmJkUoKGZ1bmN0aW9uKCl7dC51cGRhdGVBdXRvSGVpZ2h0KCl9KSksdC4kd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKGZ1bmN0aW9uKCl7ciYmKHQucGFyYW1zLmxvb3AmJlwic2xpZGVcIj09PWkucGFyYW1zLmNvbnRyb2xsZXIuYnkmJnQubG9vcEZpeCgpLHQudHJhbnNpdGlvbkVuZCgpKX0pKSl9aWYoQXJyYXkuaXNBcnJheShyKSlmb3IoYT0wO2E8ci5sZW5ndGg7YSs9MSlyW2FdIT09dCYmclthXWluc3RhbmNlb2YgcyYmbihyW2FdKTtlbHNlIHIgaW5zdGFuY2VvZiBzJiZ0IT09ciYmbihyKX19LGllPXtnZXRSYW5kb21OdW1iZXI6ZnVuY3Rpb24oZSl7dm9pZCAwPT09ZSYmKGU9MTYpO3JldHVyblwieFwiLnJlcGVhdChlKS5yZXBsYWNlKC94L2csKGZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucm91bmQoMTYqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpfSkpfSxtYWtlRWxGb2N1c2FibGU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXR0cihcInRhYkluZGV4XCIsXCIwXCIpLGV9LG1ha2VFbE5vdEZvY3VzYWJsZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5hdHRyKFwidGFiSW5kZXhcIixcIi0xXCIpLGV9LGFkZEVsUm9sZTpmdW5jdGlvbihlLHQpe3JldHVybiBlLmF0dHIoXCJyb2xlXCIsdCksZX0sYWRkRWxSb2xlRGVzY3JpcHRpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5hdHRyKFwiYXJpYS1yb2xlLWRlc2NyaXB0aW9uXCIsdCksZX0sYWRkRWxDb250cm9sczpmdW5jdGlvbihlLHQpe3JldHVybiBlLmF0dHIoXCJhcmlhLWNvbnRyb2xzXCIsdCksZX0sYWRkRWxMYWJlbDpmdW5jdGlvbihlLHQpe3JldHVybiBlLmF0dHIoXCJhcmlhLWxhYmVsXCIsdCksZX0sYWRkRWxJZDpmdW5jdGlvbihlLHQpe3JldHVybiBlLmF0dHIoXCJpZFwiLHQpLGV9LGFkZEVsTGl2ZTpmdW5jdGlvbihlLHQpe3JldHVybiBlLmF0dHIoXCJhcmlhLWxpdmVcIix0KSxlfSxkaXNhYmxlRWw6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwhMCksZX0sZW5hYmxlRWw6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwhMSksZX0sb25FbnRlcktleTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dC5wYXJhbXMuYTExeTtpZigxMz09PWUua2V5Q29kZSl7dmFyIGk9bShlLnRhcmdldCk7dC5uYXZpZ2F0aW9uJiZ0Lm5hdmlnYXRpb24uJG5leHRFbCYmaS5pcyh0Lm5hdmlnYXRpb24uJG5leHRFbCkmJih0LmlzRW5kJiYhdC5wYXJhbXMubG9vcHx8dC5zbGlkZU5leHQoKSx0LmlzRW5kP3QuYTExeS5ub3RpZnkoYS5sYXN0U2xpZGVNZXNzYWdlKTp0LmExMXkubm90aWZ5KGEubmV4dFNsaWRlTWVzc2FnZSkpLHQubmF2aWdhdGlvbiYmdC5uYXZpZ2F0aW9uLiRwcmV2RWwmJmkuaXModC5uYXZpZ2F0aW9uLiRwcmV2RWwpJiYodC5pc0JlZ2lubmluZyYmIXQucGFyYW1zLmxvb3B8fHQuc2xpZGVQcmV2KCksdC5pc0JlZ2lubmluZz90LmExMXkubm90aWZ5KGEuZmlyc3RTbGlkZU1lc3NhZ2UpOnQuYTExeS5ub3RpZnkoYS5wcmV2U2xpZGVNZXNzYWdlKSksdC5wYWdpbmF0aW9uJiZpLmlzKFwiLlwiK3QucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLFwiLlwiKSkmJmlbMF0uY2xpY2soKX19LG5vdGlmeTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmExMXkubGl2ZVJlZ2lvbjswIT09dC5sZW5ndGgmJih0Lmh0bWwoXCJcIiksdC5odG1sKGUpKX0sdXBkYXRlTmF2aWdhdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoIWUucGFyYW1zLmxvb3AmJmUubmF2aWdhdGlvbil7dmFyIHQ9ZS5uYXZpZ2F0aW9uLGE9dC4kbmV4dEVsLGk9dC4kcHJldkVsO2kmJmkubGVuZ3RoPjAmJihlLmlzQmVnaW5uaW5nPyhlLmExMXkuZGlzYWJsZUVsKGkpLGUuYTExeS5tYWtlRWxOb3RGb2N1c2FibGUoaSkpOihlLmExMXkuZW5hYmxlRWwoaSksZS5hMTF5Lm1ha2VFbEZvY3VzYWJsZShpKSkpLGEmJmEubGVuZ3RoPjAmJihlLmlzRW5kPyhlLmExMXkuZGlzYWJsZUVsKGEpLGUuYTExeS5tYWtlRWxOb3RGb2N1c2FibGUoYSkpOihlLmExMXkuZW5hYmxlRWwoYSksZS5hMTF5Lm1ha2VFbEZvY3VzYWJsZShhKSkpfX0sdXBkYXRlUGFnaW5hdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnBhcmFtcy5hMTF5O2UucGFnaW5hdGlvbiYmZS5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUmJmUucGFnaW5hdGlvbi5idWxsZXRzJiZlLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgmJmUucGFnaW5hdGlvbi5idWxsZXRzLmVhY2goKGZ1bmN0aW9uKGEpe3ZhciBpPW0oYSk7ZS5hMTF5Lm1ha2VFbEZvY3VzYWJsZShpKSxlLnBhcmFtcy5wYWdpbmF0aW9uLnJlbmRlckJ1bGxldHx8KGUuYTExeS5hZGRFbFJvbGUoaSxcImJ1dHRvblwiKSxlLmExMXkuYWRkRWxMYWJlbChpLHQucGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7aW5kZXhcXH1cXH0vLGkuaW5kZXgoKSsxKSkpfSkpfSxpbml0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWUucGFyYW1zLmExMXk7ZS4kZWwuYXBwZW5kKGUuYTExeS5saXZlUmVnaW9uKTt2YXIgYT1lLiRlbDt0LmNvbnRhaW5lclJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UmJmUuYTExeS5hZGRFbFJvbGVEZXNjcmlwdGlvbihhLHQuY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSksdC5jb250YWluZXJNZXNzYWdlJiZlLmExMXkuYWRkRWxMYWJlbChhLHQuY29udGFpbmVyTWVzc2FnZSk7dmFyIGkscyxyLG49ZS4kd3JhcHBlckVsLGw9bi5hdHRyKFwiaWRcIil8fFwic3dpcGVyLXdyYXBwZXItXCIrZS5hMTF5LmdldFJhbmRvbU51bWJlcigxNik7ZS5hMTF5LmFkZEVsSWQobixsKSxpPWUucGFyYW1zLmF1dG9wbGF5JiZlLnBhcmFtcy5hdXRvcGxheS5lbmFibGVkP1wib2ZmXCI6XCJwb2xpdGVcIixlLmExMXkuYWRkRWxMaXZlKG4saSksdC5pdGVtUm9sZURlc2NyaXB0aW9uTWVzc2FnZSYmZS5hMTF5LmFkZEVsUm9sZURlc2NyaXB0aW9uKG0oZS5zbGlkZXMpLHQuaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UpLGUuYTExeS5hZGRFbFJvbGUobShlLnNsaWRlcyksXCJncm91cFwiKSxlLnNsaWRlcy5lYWNoKChmdW5jdGlvbih0KXt2YXIgYT1tKHQpO2UuYTExeS5hZGRFbExhYmVsKGEsYS5pbmRleCgpKzErXCIgLyBcIitlLnNsaWRlcy5sZW5ndGgpfSkpLGUubmF2aWdhdGlvbiYmZS5uYXZpZ2F0aW9uLiRuZXh0RWwmJihzPWUubmF2aWdhdGlvbi4kbmV4dEVsKSxlLm5hdmlnYXRpb24mJmUubmF2aWdhdGlvbi4kcHJldkVsJiYocj1lLm5hdmlnYXRpb24uJHByZXZFbCkscyYmcy5sZW5ndGgmJihlLmExMXkubWFrZUVsRm9jdXNhYmxlKHMpLFwiQlVUVE9OXCIhPT1zWzBdLnRhZ05hbWUmJihlLmExMXkuYWRkRWxSb2xlKHMsXCJidXR0b25cIikscy5vbihcImtleWRvd25cIixlLmExMXkub25FbnRlcktleSkpLGUuYTExeS5hZGRFbExhYmVsKHMsdC5uZXh0U2xpZGVNZXNzYWdlKSxlLmExMXkuYWRkRWxDb250cm9scyhzLGwpKSxyJiZyLmxlbmd0aCYmKGUuYTExeS5tYWtlRWxGb2N1c2FibGUociksXCJCVVRUT05cIiE9PXJbMF0udGFnTmFtZSYmKGUuYTExeS5hZGRFbFJvbGUocixcImJ1dHRvblwiKSxyLm9uKFwia2V5ZG93blwiLGUuYTExeS5vbkVudGVyS2V5KSksZS5hMTF5LmFkZEVsTGFiZWwocix0LnByZXZTbGlkZU1lc3NhZ2UpLGUuYTExeS5hZGRFbENvbnRyb2xzKHIsbCkpLGUucGFnaW5hdGlvbiYmZS5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUmJmUucGFnaW5hdGlvbi5idWxsZXRzJiZlLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgmJmUucGFnaW5hdGlvbi4kZWwub24oXCJrZXlkb3duXCIsXCIuXCIrZS5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcy5yZXBsYWNlKC8gL2csXCIuXCIpLGUuYTExeS5vbkVudGVyS2V5KX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBlLHQsYT10aGlzO2EuYTExeS5saXZlUmVnaW9uJiZhLmExMXkubGl2ZVJlZ2lvbi5sZW5ndGg+MCYmYS5hMTF5LmxpdmVSZWdpb24ucmVtb3ZlKCksYS5uYXZpZ2F0aW9uJiZhLm5hdmlnYXRpb24uJG5leHRFbCYmKGU9YS5uYXZpZ2F0aW9uLiRuZXh0RWwpLGEubmF2aWdhdGlvbiYmYS5uYXZpZ2F0aW9uLiRwcmV2RWwmJih0PWEubmF2aWdhdGlvbi4kcHJldkVsKSxlJiZlLm9mZihcImtleWRvd25cIixhLmExMXkub25FbnRlcktleSksdCYmdC5vZmYoXCJrZXlkb3duXCIsYS5hMTF5Lm9uRW50ZXJLZXkpLGEucGFnaW5hdGlvbiYmYS5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUmJmEucGFnaW5hdGlvbi5idWxsZXRzJiZhLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgmJmEucGFnaW5hdGlvbi4kZWwub2ZmKFwia2V5ZG93blwiLFwiLlwiK2EucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MucmVwbGFjZSgvIC9nLFwiLlwiKSxhLmExMXkub25FbnRlcktleSl9fSxzZT17aW5pdDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1sKCk7aWYoZS5wYXJhbXMuaGlzdG9yeSl7aWYoIXQuaGlzdG9yeXx8IXQuaGlzdG9yeS5wdXNoU3RhdGUpcmV0dXJuIGUucGFyYW1zLmhpc3RvcnkuZW5hYmxlZD0hMSx2b2lkKGUucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQ9ITApO3ZhciBhPWUuaGlzdG9yeTthLmluaXRpYWxpemVkPSEwLGEucGF0aHM9c2UuZ2V0UGF0aFZhbHVlcyhlLnBhcmFtcy51cmwpLChhLnBhdGhzLmtleXx8YS5wYXRocy52YWx1ZSkmJihhLnNjcm9sbFRvU2xpZGUoMCxhLnBhdGhzLnZhbHVlLGUucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCksZS5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGV8fHQuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsZS5oaXN0b3J5LnNldEhpc3RvcnlQb3BTdGF0ZSkpfX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBlPWwoKTt0aGlzLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZXx8ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIix0aGlzLmhpc3Rvcnkuc2V0SGlzdG9yeVBvcFN0YXRlKX0sc2V0SGlzdG9yeVBvcFN0YXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztlLmhpc3RvcnkucGF0aHM9c2UuZ2V0UGF0aFZhbHVlcyhlLnBhcmFtcy51cmwpLGUuaGlzdG9yeS5zY3JvbGxUb1NsaWRlKGUucGFyYW1zLnNwZWVkLGUuaGlzdG9yeS5wYXRocy52YWx1ZSwhMSl9LGdldFBhdGhWYWx1ZXM6ZnVuY3Rpb24oZSl7dmFyIHQ9bCgpLGE9KGU/bmV3IFVSTChlKTp0LmxvY2F0aW9uKS5wYXRobmFtZS5zbGljZSgxKS5zcGxpdChcIi9cIikuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm5cIlwiIT09ZX0pKSxpPWEubGVuZ3RoO3JldHVybntrZXk6YVtpLTJdLHZhbHVlOmFbaS0xXX19LHNldEhpc3Rvcnk6ZnVuY3Rpb24oZSx0KXt2YXIgYT10aGlzLGk9bCgpO2lmKGEuaGlzdG9yeS5pbml0aWFsaXplZCYmYS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKXt2YXIgcztzPWEucGFyYW1zLnVybD9uZXcgVVJMKGEucGFyYW1zLnVybCk6aS5sb2NhdGlvbjt2YXIgcj1hLnNsaWRlcy5lcSh0KSxuPXNlLnNsdWdpZnkoci5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKTtzLnBhdGhuYW1lLmluY2x1ZGVzKGUpfHwobj1lK1wiL1wiK24pO3ZhciBvPWkuaGlzdG9yeS5zdGF0ZTtvJiZvLnZhbHVlPT09bnx8KGEucGFyYW1zLmhpc3RvcnkucmVwbGFjZVN0YXRlP2kuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe3ZhbHVlOm59LG51bGwsbik6aS5oaXN0b3J5LnB1c2hTdGF0ZSh7dmFsdWU6bn0sbnVsbCxuKSl9fSxzbHVnaWZ5OmZ1bmN0aW9uKGUpe3JldHVybiBlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLFwiLVwiKS5yZXBsYWNlKC9bXlxcdy1dKy9nLFwiXCIpLnJlcGxhY2UoLy0tKy9nLFwiLVwiKS5yZXBsYWNlKC9eLSsvLFwiXCIpLnJlcGxhY2UoLy0rJC8sXCJcIil9LHNjcm9sbFRvU2xpZGU6ZnVuY3Rpb24oZSx0LGEpe3ZhciBpPXRoaXM7aWYodClmb3IodmFyIHM9MCxyPWkuc2xpZGVzLmxlbmd0aDtzPHI7cys9MSl7dmFyIG49aS5zbGlkZXMuZXEocyk7aWYoc2Uuc2x1Z2lmeShuLmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpPT09dCYmIW4uaGFzQ2xhc3MoaS5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpe3ZhciBsPW4uaW5kZXgoKTtpLnNsaWRlVG8obCxlLGEpfX1lbHNlIGkuc2xpZGVUbygwLGUsYSl9fSxyZT17b25IYXNoQ2FuZ2U6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9cigpO2UuZW1pdChcImhhc2hDaGFuZ2VcIik7dmFyIGE9dC5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoXCIjXCIsXCJcIik7aWYoYSE9PWUuc2xpZGVzLmVxKGUuYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLWhhc2hcIikpe3ZhciBpPWUuJHdyYXBwZXJFbC5jaGlsZHJlbihcIi5cIitlLnBhcmFtcy5zbGlkZUNsYXNzKydbZGF0YS1oYXNoPVwiJythKydcIl0nKS5pbmRleCgpO2lmKHZvaWQgMD09PWkpcmV0dXJuO2Uuc2xpZGVUbyhpKX19LHNldEhhc2g6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9bCgpLGE9cigpO2lmKGUuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQmJmUucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpaWYoZS5wYXJhbXMuaGFzaE5hdmlnYXRpb24ucmVwbGFjZVN0YXRlJiZ0Lmhpc3RvcnkmJnQuaGlzdG9yeS5yZXBsYWNlU3RhdGUpdC5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLG51bGwsXCIjXCIrZS5zbGlkZXMuZXEoZS5hY3RpdmVJbmRleCkuYXR0cihcImRhdGEtaGFzaFwiKXx8XCJcIiksZS5lbWl0KFwiaGFzaFNldFwiKTtlbHNle3ZhciBpPWUuc2xpZGVzLmVxKGUuYWN0aXZlSW5kZXgpLHM9aS5hdHRyKFwiZGF0YS1oYXNoXCIpfHxpLmF0dHIoXCJkYXRhLWhpc3RvcnlcIik7YS5sb2NhdGlvbi5oYXNoPXN8fFwiXCIsZS5lbWl0KFwiaGFzaFNldFwiKX19LGluaXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9cigpLGE9bCgpO2lmKCEoIWUucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWR8fGUucGFyYW1zLmhpc3RvcnkmJmUucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCkpe2UuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQ9ITA7dmFyIGk9dC5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoXCIjXCIsXCJcIik7aWYoaSlmb3IodmFyIHM9MCxuPWUuc2xpZGVzLmxlbmd0aDtzPG47cys9MSl7dmFyIG89ZS5zbGlkZXMuZXEocyk7aWYoKG8uYXR0cihcImRhdGEtaGFzaFwiKXx8by5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKT09PWkmJiFvLmhhc0NsYXNzKGUucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKXt2YXIgZD1vLmluZGV4KCk7ZS5zbGlkZVRvKGQsMCxlLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQsITApfX1lLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi53YXRjaFN0YXRlJiZtKGEpLm9uKFwiaGFzaGNoYW5nZVwiLGUuaGFzaE5hdmlnYXRpb24ub25IYXNoQ2FuZ2UpfX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBlPWwoKTt0aGlzLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi53YXRjaFN0YXRlJiZtKGUpLm9mZihcImhhc2hjaGFuZ2VcIix0aGlzLmhhc2hOYXZpZ2F0aW9uLm9uSGFzaENhbmdlKX19LG5lPXtydW46ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZS5zbGlkZXMuZXEoZS5hY3RpdmVJbmRleCksYT1lLnBhcmFtcy5hdXRvcGxheS5kZWxheTt0LmF0dHIoXCJkYXRhLXN3aXBlci1hdXRvcGxheVwiKSYmKGE9dC5hdHRyKFwiZGF0YS1zd2lwZXItYXV0b3BsYXlcIil8fGUucGFyYW1zLmF1dG9wbGF5LmRlbGF5KSxjbGVhclRpbWVvdXQoZS5hdXRvcGxheS50aW1lb3V0KSxlLmF1dG9wbGF5LnRpbWVvdXQ9RSgoZnVuY3Rpb24oKXt2YXIgdDtlLnBhcmFtcy5hdXRvcGxheS5yZXZlcnNlRGlyZWN0aW9uP2UucGFyYW1zLmxvb3A/KGUubG9vcEZpeCgpLHQ9ZS5zbGlkZVByZXYoZS5wYXJhbXMuc3BlZWQsITAsITApLGUuZW1pdChcImF1dG9wbGF5XCIpKTplLmlzQmVnaW5uaW5nP2UucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZT9lLmF1dG9wbGF5LnN0b3AoKToodD1lLnNsaWRlVG8oZS5zbGlkZXMubGVuZ3RoLTEsZS5wYXJhbXMuc3BlZWQsITAsITApLGUuZW1pdChcImF1dG9wbGF5XCIpKToodD1lLnNsaWRlUHJldihlLnBhcmFtcy5zcGVlZCwhMCwhMCksZS5lbWl0KFwiYXV0b3BsYXlcIikpOmUucGFyYW1zLmxvb3A/KGUubG9vcEZpeCgpLHQ9ZS5zbGlkZU5leHQoZS5wYXJhbXMuc3BlZWQsITAsITApLGUuZW1pdChcImF1dG9wbGF5XCIpKTplLmlzRW5kP2UucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZT9lLmF1dG9wbGF5LnN0b3AoKToodD1lLnNsaWRlVG8oMCxlLnBhcmFtcy5zcGVlZCwhMCwhMCksZS5lbWl0KFwiYXV0b3BsYXlcIikpOih0PWUuc2xpZGVOZXh0KGUucGFyYW1zLnNwZWVkLCEwLCEwKSxlLmVtaXQoXCJhdXRvcGxheVwiKSksKGUucGFyYW1zLmNzc01vZGUmJmUuYXV0b3BsYXkucnVubmluZ3x8ITE9PT10KSYmZS5hdXRvcGxheS5ydW4oKX0pLGEpfSxzdGFydDpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHZvaWQgMD09PWUuYXV0b3BsYXkudGltZW91dCYmKCFlLmF1dG9wbGF5LnJ1bm5pbmcmJihlLmF1dG9wbGF5LnJ1bm5pbmc9ITAsZS5lbWl0KFwiYXV0b3BsYXlTdGFydFwiKSxlLmF1dG9wbGF5LnJ1bigpLCEwKSl9LHN0b3A6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiEhZS5hdXRvcGxheS5ydW5uaW5nJiYodm9pZCAwIT09ZS5hdXRvcGxheS50aW1lb3V0JiYoZS5hdXRvcGxheS50aW1lb3V0JiYoY2xlYXJUaW1lb3V0KGUuYXV0b3BsYXkudGltZW91dCksZS5hdXRvcGxheS50aW1lb3V0PXZvaWQgMCksZS5hdXRvcGxheS5ydW5uaW5nPSExLGUuZW1pdChcImF1dG9wbGF5U3RvcFwiKSwhMCkpfSxwYXVzZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3QuYXV0b3BsYXkucnVubmluZyYmKHQuYXV0b3BsYXkucGF1c2VkfHwodC5hdXRvcGxheS50aW1lb3V0JiZjbGVhclRpbWVvdXQodC5hdXRvcGxheS50aW1lb3V0KSx0LmF1dG9wbGF5LnBhdXNlZD0hMCwwIT09ZSYmdC5wYXJhbXMuYXV0b3BsYXkud2FpdEZvclRyYW5zaXRpb24/KHQuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLHQuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKSx0LiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIix0LmF1dG9wbGF5Lm9uVHJhbnNpdGlvbkVuZCkpOih0LmF1dG9wbGF5LnBhdXNlZD0hMSx0LmF1dG9wbGF5LnJ1bigpKSkpfSxvblZpc2liaWxpdHlDaGFuZ2U6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9cigpO1wiaGlkZGVuXCI9PT10LnZpc2liaWxpdHlTdGF0ZSYmZS5hdXRvcGxheS5ydW5uaW5nJiZlLmF1dG9wbGF5LnBhdXNlKCksXCJ2aXNpYmxlXCI9PT10LnZpc2liaWxpdHlTdGF0ZSYmZS5hdXRvcGxheS5wYXVzZWQmJihlLmF1dG9wbGF5LnJ1bigpLGUuYXV0b3BsYXkucGF1c2VkPSExKX0sb25UcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dCYmIXQuZGVzdHJveWVkJiZ0LiR3cmFwcGVyRWwmJmUudGFyZ2V0PT09dC4kd3JhcHBlckVsWzBdJiYodC4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsdC5hdXRvcGxheS5vblRyYW5zaXRpb25FbmQpLHQuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLHQuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKSx0LmF1dG9wbGF5LnBhdXNlZD0hMSx0LmF1dG9wbGF5LnJ1bm5pbmc/dC5hdXRvcGxheS5ydW4oKTp0LmF1dG9wbGF5LnN0b3AoKSl9fSxsZT17c2V0VHJhbnNsYXRlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMsdD1lLnNsaWRlcyxhPTA7YTx0Lmxlbmd0aDthKz0xKXt2YXIgaT1lLnNsaWRlcy5lcShhKSxzPS1pWzBdLnN3aXBlclNsaWRlT2Zmc2V0O2UucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGV8fChzLT1lLnRyYW5zbGF0ZSk7dmFyIHI9MDtlLmlzSG9yaXpvbnRhbCgpfHwocj1zLHM9MCk7dmFyIG49ZS5wYXJhbXMuZmFkZUVmZmVjdC5jcm9zc0ZhZGU/TWF0aC5tYXgoMS1NYXRoLmFicyhpWzBdLnByb2dyZXNzKSwwKToxK01hdGgubWluKE1hdGgubWF4KGlbMF0ucHJvZ3Jlc3MsLTEpLDApO2kuY3NzKHtvcGFjaXR5Om59KS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZChcIitzK1wicHgsIFwiK3IrXCJweCwgMHB4KVwiKX19LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQuc2xpZGVzLGk9dC4kd3JhcHBlckVsO2lmKGEudHJhbnNpdGlvbihlKSx0LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlJiYwIT09ZSl7dmFyIHM9ITE7YS50cmFuc2l0aW9uRW5kKChmdW5jdGlvbigpe2lmKCFzJiZ0JiYhdC5kZXN0cm95ZWQpe3M9ITAsdC5hbmltYXRpbmc9ITE7Zm9yKHZhciBlPVtcIndlYmtpdFRyYW5zaXRpb25FbmRcIixcInRyYW5zaXRpb25lbmRcIl0sYT0wO2E8ZS5sZW5ndGg7YSs9MSlpLnRyaWdnZXIoZVthXSl9fSkpfX19LG9lPXtzZXRUcmFuc2xhdGU6ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXMsYT10LiRlbCxpPXQuJHdyYXBwZXJFbCxzPXQuc2xpZGVzLHI9dC53aWR0aCxuPXQuaGVpZ2h0LGw9dC5ydGxUcmFuc2xhdGUsbz10LnNpemUsZD10LmJyb3dzZXIscD10LnBhcmFtcy5jdWJlRWZmZWN0LHU9dC5pc0hvcml6b250YWwoKSxjPXQudmlydHVhbCYmdC5wYXJhbXMudmlydHVhbC5lbmFibGVkLGg9MDtwLnNoYWRvdyYmKHU/KDA9PT0oZT1pLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpKS5sZW5ndGgmJihlPW0oJzxkaXYgY2xhc3M9XCJzd2lwZXItY3ViZS1zaGFkb3dcIj48L2Rpdj4nKSxpLmFwcGVuZChlKSksZS5jc3Moe2hlaWdodDpyK1wicHhcIn0pKTowPT09KGU9YS5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKSkubGVuZ3RoJiYoZT1tKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+JyksYS5hcHBlbmQoZSkpKTtmb3IodmFyIHY9MDt2PHMubGVuZ3RoO3YrPTEpe3ZhciBmPXMuZXEodiksZz12O2MmJihnPXBhcnNlSW50KGYuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLDEwKSk7dmFyIHk9OTAqZyx3PU1hdGguZmxvb3IoeS8zNjApO2wmJih5PS15LHc9TWF0aC5mbG9vcigteS8zNjApKTt2YXIgYj1NYXRoLm1heChNYXRoLm1pbihmWzBdLnByb2dyZXNzLDEpLC0xKSxFPTAseD0wLFQ9MDtnJTQ9PTA/KEU9NCotdypvLFQ9MCk6KGctMSklND09MD8oRT0wLFQ9NCotdypvKTooZy0yKSU0PT0wPyhFPW8rNCp3Km8sVD1vKTooZy0zKSU0PT0wJiYoRT0tbyxUPTMqbys0Km8qdyksbCYmKEU9LUUpLHV8fCh4PUUsRT0wKTt2YXIgQz1cInJvdGF0ZVgoXCIrKHU/MDoteSkrXCJkZWcpIHJvdGF0ZVkoXCIrKHU/eTowKStcImRlZykgdHJhbnNsYXRlM2QoXCIrRStcInB4LCBcIit4K1wicHgsIFwiK1QrXCJweClcIjtpZihiPD0xJiZiPi0xJiYoaD05MCpnKzkwKmIsbCYmKGg9OTAqLWctOTAqYikpLGYudHJhbnNmb3JtKEMpLHAuc2xpZGVTaGFkb3dzKXt2YXIgUz11P2YuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIik6Zi5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wXCIpLE09dT9mLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKTpmLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7MD09PVMubGVuZ3RoJiYoUz1tKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nKyh1P1wibGVmdFwiOlwidG9wXCIpKydcIj48L2Rpdj4nKSxmLmFwcGVuZChTKSksMD09PU0ubGVuZ3RoJiYoTT1tKCc8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0nKyh1P1wicmlnaHRcIjpcImJvdHRvbVwiKSsnXCI+PC9kaXY+JyksZi5hcHBlbmQoTSkpLFMubGVuZ3RoJiYoU1swXS5zdHlsZS5vcGFjaXR5PU1hdGgubWF4KC1iLDApKSxNLmxlbmd0aCYmKE1bMF0uc3R5bGUub3BhY2l0eT1NYXRoLm1heChiLDApKX19aWYoaS5jc3Moe1wiLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luXCI6XCI1MCUgNTAlIC1cIitvLzIrXCJweFwiLFwiLW1vei10cmFuc2Zvcm0tb3JpZ2luXCI6XCI1MCUgNTAlIC1cIitvLzIrXCJweFwiLFwiLW1zLXRyYW5zZm9ybS1vcmlnaW5cIjpcIjUwJSA1MCUgLVwiK28vMitcInB4XCIsXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6XCI1MCUgNTAlIC1cIitvLzIrXCJweFwifSkscC5zaGFkb3cpaWYodSllLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDBweCwgXCIrKHIvMitwLnNoYWRvd09mZnNldCkrXCJweCwgXCIrLXIvMitcInB4KSByb3RhdGVYKDkwZGVnKSByb3RhdGVaKDBkZWcpIHNjYWxlKFwiK3Auc2hhZG93U2NhbGUrXCIpXCIpO2Vsc2V7dmFyIHo9TWF0aC5hYnMoaCktOTAqTWF0aC5mbG9vcihNYXRoLmFicyhoKS85MCksUD0xLjUtKE1hdGguc2luKDIqeipNYXRoLlBJLzM2MCkvMitNYXRoLmNvcygyKnoqTWF0aC5QSS8zNjApLzIpLGs9cC5zaGFkb3dTY2FsZSxMPXAuc2hhZG93U2NhbGUvUCwkPXAuc2hhZG93T2Zmc2V0O2UudHJhbnNmb3JtKFwic2NhbGUzZChcIitrK1wiLCAxLCBcIitMK1wiKSB0cmFuc2xhdGUzZCgwcHgsIFwiKyhuLzIrJCkrXCJweCwgXCIrLW4vMi9MK1wicHgpIHJvdGF0ZVgoLTkwZGVnKVwiKX12YXIgST1kLmlzU2FmYXJpfHxkLmlzV2ViVmlldz8tby8yOjA7aS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwcHgsMCxcIitJK1wicHgpIHJvdGF0ZVgoXCIrKHQuaXNIb3Jpem9udGFsKCk/MDpoKStcImRlZykgcm90YXRlWShcIisodC5pc0hvcml6b250YWwoKT8taDowKStcImRlZylcIil9LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXQuJGVsO3Quc2xpZGVzLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpLHQucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93JiYhdC5pc0hvcml6b250YWwoKSYmYS5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKS50cmFuc2l0aW9uKGUpfX0sZGU9e3NldFRyYW5zbGF0ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLHQ9ZS5zbGlkZXMsYT1lLnJ0bFRyYW5zbGF0ZSxpPTA7aTx0Lmxlbmd0aDtpKz0xKXt2YXIgcz10LmVxKGkpLHI9c1swXS5wcm9ncmVzcztlLnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24mJihyPU1hdGgubWF4KE1hdGgubWluKHNbMF0ucHJvZ3Jlc3MsMSksLTEpKTt2YXIgbj0tMTgwKnIsbD0wLG89LXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQsZD0wO2lmKGUuaXNIb3Jpem9udGFsKCk/YSYmKG49LW4pOihkPW8sbz0wLGw9LW4sbj0wKSxzWzBdLnN0eWxlLnpJbmRleD0tTWF0aC5hYnMoTWF0aC5yb3VuZChyKSkrdC5sZW5ndGgsZS5wYXJhbXMuZmxpcEVmZmVjdC5zbGlkZVNoYWRvd3Mpe3ZhciBwPWUuaXNIb3Jpem9udGFsKCk/cy5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKTpzLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksdT1lLmlzSG9yaXpvbnRhbCgpP3MuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0XCIpOnMuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbVwiKTswPT09cC5sZW5ndGgmJihwPW0oJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScrKGUuaXNIb3Jpem9udGFsKCk/XCJsZWZ0XCI6XCJ0b3BcIikrJ1wiPjwvZGl2PicpLHMuYXBwZW5kKHApKSwwPT09dS5sZW5ndGgmJih1PW0oJzxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LScrKGUuaXNIb3Jpem9udGFsKCk/XCJyaWdodFwiOlwiYm90dG9tXCIpKydcIj48L2Rpdj4nKSxzLmFwcGVuZCh1KSkscC5sZW5ndGgmJihwWzBdLnN0eWxlLm9wYWNpdHk9TWF0aC5tYXgoLXIsMCkpLHUubGVuZ3RoJiYodVswXS5zdHlsZS5vcGFjaXR5PU1hdGgubWF4KHIsMCkpfXMudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoXCIrbytcInB4LCBcIitkK1wicHgsIDBweCkgcm90YXRlWChcIitsK1wiZGVnKSByb3RhdGVZKFwiK24rXCJkZWcpXCIpfX0sc2V0VHJhbnNpdGlvbjpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dC5zbGlkZXMsaT10LmFjdGl2ZUluZGV4LHM9dC4kd3JhcHBlckVsO2lmKGEudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpLnRyYW5zaXRpb24oZSksdC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSYmMCE9PWUpe3ZhciByPSExO2EuZXEoaSkudHJhbnNpdGlvbkVuZCgoZnVuY3Rpb24oKXtpZighciYmdCYmIXQuZGVzdHJveWVkKXtyPSEwLHQuYW5pbWF0aW5nPSExO2Zvcih2YXIgZT1bXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsXCJ0cmFuc2l0aW9uZW5kXCJdLGE9MDthPGUubGVuZ3RoO2ErPTEpcy50cmlnZ2VyKGVbYV0pfX0pKX19fSxwZT17c2V0VHJhbnNsYXRlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMsdD1lLndpZHRoLGE9ZS5oZWlnaHQsaT1lLnNsaWRlcyxzPWUuc2xpZGVzU2l6ZXNHcmlkLHI9ZS5wYXJhbXMuY292ZXJmbG93RWZmZWN0LG49ZS5pc0hvcml6b250YWwoKSxsPWUudHJhbnNsYXRlLG89bj90LzItbDphLzItbCxkPW4/ci5yb3RhdGU6LXIucm90YXRlLHA9ci5kZXB0aCx1PTAsYz1pLmxlbmd0aDt1PGM7dSs9MSl7dmFyIGg9aS5lcSh1KSx2PXNbdV0sZj0oby1oWzBdLnN3aXBlclNsaWRlT2Zmc2V0LXYvMikvdipyLm1vZGlmaWVyLGc9bj9kKmY6MCx5PW4/MDpkKmYsdz0tcCpNYXRoLmFicyhmKSxiPXIuc3RyZXRjaDtcInN0cmluZ1wiPT10eXBlb2YgYiYmLTEhPT1iLmluZGV4T2YoXCIlXCIpJiYoYj1wYXJzZUZsb2F0KHIuc3RyZXRjaCkvMTAwKnYpO3ZhciBFPW4/MDpiKmYseD1uP2IqZjowLFQ9MS0oMS1yLnNjYWxlKSpNYXRoLmFicyhmKTtNYXRoLmFicyh4KTwuMDAxJiYoeD0wKSxNYXRoLmFicyhFKTwuMDAxJiYoRT0wKSxNYXRoLmFicyh3KTwuMDAxJiYodz0wKSxNYXRoLmFicyhnKTwuMDAxJiYoZz0wKSxNYXRoLmFicyh5KTwuMDAxJiYoeT0wKSxNYXRoLmFicyhUKTwuMDAxJiYoVD0wKTt2YXIgQz1cInRyYW5zbGF0ZTNkKFwiK3grXCJweCxcIitFK1wicHgsXCIrdytcInB4KSAgcm90YXRlWChcIit5K1wiZGVnKSByb3RhdGVZKFwiK2crXCJkZWcpIHNjYWxlKFwiK1QrXCIpXCI7aWYoaC50cmFuc2Zvcm0oQyksaFswXS5zdHlsZS56SW5kZXg9MS1NYXRoLmFicyhNYXRoLnJvdW5kKGYpKSxyLnNsaWRlU2hhZG93cyl7dmFyIFM9bj9oLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpOmguZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxNPW4/aC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIik6aC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpOzA9PT1TLmxlbmd0aCYmKFM9bSgnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJysobj9cImxlZnRcIjpcInRvcFwiKSsnXCI+PC9kaXY+JyksaC5hcHBlbmQoUykpLDA9PT1NLmxlbmd0aCYmKE09bSgnPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJysobj9cInJpZ2h0XCI6XCJib3R0b21cIikrJ1wiPjwvZGl2PicpLGguYXBwZW5kKE0pKSxTLmxlbmd0aCYmKFNbMF0uc3R5bGUub3BhY2l0eT1mPjA/ZjowKSxNLmxlbmd0aCYmKE1bMF0uc3R5bGUub3BhY2l0eT0tZj4wPy1mOjApfX19LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSl7dGhpcy5zbGlkZXMudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpLnRyYW5zaXRpb24oZSl9fSx1ZT17aW5pdDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnBhcmFtcy50aHVtYnM7aWYoZS50aHVtYnMuaW5pdGlhbGl6ZWQpcmV0dXJuITE7ZS50aHVtYnMuaW5pdGlhbGl6ZWQ9ITA7dmFyIGE9ZS5jb25zdHJ1Y3RvcjtyZXR1cm4gdC5zd2lwZXIgaW5zdGFuY2VvZiBhPyhlLnRodW1icy5zd2lwZXI9dC5zd2lwZXIsUyhlLnRodW1icy5zd2lwZXIub3JpZ2luYWxQYXJhbXMse3dhdGNoU2xpZGVzUHJvZ3Jlc3M6ITAsc2xpZGVUb0NsaWNrZWRTbGlkZTohMX0pLFMoZS50aHVtYnMuc3dpcGVyLnBhcmFtcyx7d2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzbGlkZVRvQ2xpY2tlZFNsaWRlOiExfSkpOkModC5zd2lwZXIpJiYoZS50aHVtYnMuc3dpcGVyPW5ldyBhKFMoe30sdC5zd2lwZXIse3dhdGNoU2xpZGVzVmlzaWJpbGl0eTohMCx3YXRjaFNsaWRlc1Byb2dyZXNzOiEwLHNsaWRlVG9DbGlja2VkU2xpZGU6ITF9KSksZS50aHVtYnMuc3dpcGVyQ3JlYXRlZD0hMCksZS50aHVtYnMuc3dpcGVyLiRlbC5hZGRDbGFzcyhlLnBhcmFtcy50aHVtYnMudGh1bWJzQ29udGFpbmVyQ2xhc3MpLGUudGh1bWJzLnN3aXBlci5vbihcInRhcFwiLGUudGh1bWJzLm9uVGh1bWJDbGljayksITB9LG9uVGh1bWJDbGljazpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLnRodW1icy5zd2lwZXI7aWYodCl7dmFyIGE9dC5jbGlja2VkSW5kZXgsaT10LmNsaWNrZWRTbGlkZTtpZighKGkmJm0oaSkuaGFzQ2xhc3MoZS5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcyl8fG51bGw9PWEpKXt2YXIgcztpZihzPXQucGFyYW1zLmxvb3A/cGFyc2VJbnQobSh0LmNsaWNrZWRTbGlkZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLDEwKTphLGUucGFyYW1zLmxvb3Ape3ZhciByPWUuYWN0aXZlSW5kZXg7ZS5zbGlkZXMuZXEocikuaGFzQ2xhc3MoZS5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykmJihlLmxvb3BGaXgoKSxlLl9jbGllbnRMZWZ0PWUuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0LHI9ZS5hY3RpdmVJbmRleCk7dmFyIG49ZS5zbGlkZXMuZXEocikucHJldkFsbCgnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytzKydcIl0nKS5lcSgwKS5pbmRleCgpLGw9ZS5zbGlkZXMuZXEocikubmV4dEFsbCgnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJytzKydcIl0nKS5lcSgwKS5pbmRleCgpO3M9dm9pZCAwPT09bj9sOnZvaWQgMD09PWw/bjpsLXI8ci1uP2w6bn1lLnNsaWRlVG8ocyl9fX0sdXBkYXRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10LnRodW1icy5zd2lwZXI7aWYoYSl7dmFyIGk9XCJhdXRvXCI9PT1hLnBhcmFtcy5zbGlkZXNQZXJWaWV3P2Euc2xpZGVzUGVyVmlld0R5bmFtaWMoKTphLnBhcmFtcy5zbGlkZXNQZXJWaWV3LHM9dC5wYXJhbXMudGh1bWJzLmF1dG9TY3JvbGxPZmZzZXQscj1zJiYhYS5wYXJhbXMubG9vcDtpZih0LnJlYWxJbmRleCE9PWEucmVhbEluZGV4fHxyKXt2YXIgbixsLG89YS5hY3RpdmVJbmRleDtpZihhLnBhcmFtcy5sb29wKXthLnNsaWRlcy5lcShvKS5oYXNDbGFzcyhhLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSYmKGEubG9vcEZpeCgpLGEuX2NsaWVudExlZnQ9YS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQsbz1hLmFjdGl2ZUluZGV4KTt2YXIgZD1hLnNsaWRlcy5lcShvKS5wcmV2QWxsKCdbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCInK3QucmVhbEluZGV4KydcIl0nKS5lcSgwKS5pbmRleCgpLHA9YS5zbGlkZXMuZXEobykubmV4dEFsbCgnW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJyt0LnJlYWxJbmRleCsnXCJdJykuZXEoMCkuaW5kZXgoKTtuPXZvaWQgMD09PWQ/cDp2b2lkIDA9PT1wP2Q6cC1vPT1vLWQ/bzpwLW88by1kP3A6ZCxsPXQuYWN0aXZlSW5kZXg+dC5wcmV2aW91c0luZGV4P1wibmV4dFwiOlwicHJldlwifWVsc2UgbD0obj10LnJlYWxJbmRleCk+dC5wcmV2aW91c0luZGV4P1wibmV4dFwiOlwicHJldlwiO3ImJihuKz1cIm5leHRcIj09PWw/czotMSpzKSxhLnZpc2libGVTbGlkZXNJbmRleGVzJiZhLnZpc2libGVTbGlkZXNJbmRleGVzLmluZGV4T2Yobik8MCYmKGEucGFyYW1zLmNlbnRlcmVkU2xpZGVzP249bj5vP24tTWF0aC5mbG9vcihpLzIpKzE6bitNYXRoLmZsb29yKGkvMiktMTpuPm8mJihuPW4taSsxKSxhLnNsaWRlVG8obixlPzA6dm9pZCAwKSl9dmFyIHU9MSxjPXQucGFyYW1zLnRodW1icy5zbGlkZVRodW1iQWN0aXZlQ2xhc3M7aWYodC5wYXJhbXMuc2xpZGVzUGVyVmlldz4xJiYhdC5wYXJhbXMuY2VudGVyZWRTbGlkZXMmJih1PXQucGFyYW1zLnNsaWRlc1BlclZpZXcpLHQucGFyYW1zLnRodW1icy5tdWx0aXBsZUFjdGl2ZVRodW1ic3x8KHU9MSksdT1NYXRoLmZsb29yKHUpLGEuc2xpZGVzLnJlbW92ZUNsYXNzKGMpLGEucGFyYW1zLmxvb3B8fGEucGFyYW1zLnZpcnR1YWwmJmEucGFyYW1zLnZpcnR1YWwuZW5hYmxlZClmb3IodmFyIGg9MDtoPHU7aCs9MSlhLiR3cmFwcGVyRWwuY2hpbGRyZW4oJ1tkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIicrKHQucmVhbEluZGV4K2gpKydcIl0nKS5hZGRDbGFzcyhjKTtlbHNlIGZvcih2YXIgdj0wO3Y8dTt2Kz0xKWEuc2xpZGVzLmVxKHQucmVhbEluZGV4K3YpLmFkZENsYXNzKGMpfX19LGNlPVtxLF8se25hbWU6XCJtb3VzZXdoZWVsXCIscGFyYW1zOnttb3VzZXdoZWVsOntlbmFibGVkOiExLHJlbGVhc2VPbkVkZ2VzOiExLGludmVydDohMSxmb3JjZVRvQXhpczohMSxzZW5zaXRpdml0eToxLGV2ZW50c1RhcmdldDpcImNvbnRhaW5lclwiLHRocmVzaG9sZERlbHRhOm51bGwsdGhyZXNob2xkVGltZTpudWxsfX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHttb3VzZXdoZWVsOntlbmFibGVkOiExLGxhc3RTY3JvbGxUaW1lOngoKSxsYXN0RXZlbnRCZWZvcmVTbmFwOnZvaWQgMCxyZWNlbnRXaGVlbEV2ZW50czpbXSxlbmFibGU6VS5lbmFibGUsZGlzYWJsZTpVLmRpc2FibGUsaGFuZGxlOlUuaGFuZGxlLGhhbmRsZU1vdXNlRW50ZXI6VS5oYW5kbGVNb3VzZUVudGVyLGhhbmRsZU1vdXNlTGVhdmU6VS5oYW5kbGVNb3VzZUxlYXZlLGFuaW1hdGVTbGlkZXI6VS5hbmltYXRlU2xpZGVyLHJlbGVhc2VTY3JvbGw6VS5yZWxlYXNlU2Nyb2xsfX0pfSxvbjp7aW5pdDpmdW5jdGlvbihlKXshZS5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkJiZlLnBhcmFtcy5jc3NNb2RlJiZlLm1vdXNld2hlZWwuZGlzYWJsZSgpLGUucGFyYW1zLm1vdXNld2hlZWwuZW5hYmxlZCYmZS5tb3VzZXdoZWVsLmVuYWJsZSgpfSxkZXN0cm95OmZ1bmN0aW9uKGUpe2UucGFyYW1zLmNzc01vZGUmJmUubW91c2V3aGVlbC5lbmFibGUoKSxlLm1vdXNld2hlZWwuZW5hYmxlZCYmZS5tb3VzZXdoZWVsLmRpc2FibGUoKX19fSx7bmFtZTpcIm5hdmlnYXRpb25cIixwYXJhbXM6e25hdmlnYXRpb246e25leHRFbDpudWxsLHByZXZFbDpudWxsLGhpZGVPbkNsaWNrOiExLGRpc2FibGVkQ2xhc3M6XCJzd2lwZXItYnV0dG9uLWRpc2FibGVkXCIsaGlkZGVuQ2xhc3M6XCJzd2lwZXItYnV0dG9uLWhpZGRlblwiLGxvY2tDbGFzczpcInN3aXBlci1idXR0b24tbG9ja1wifX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHtuYXZpZ2F0aW9uOnQoe30sSyl9KX0sb246e2luaXQ6ZnVuY3Rpb24oZSl7ZS5uYXZpZ2F0aW9uLmluaXQoKSxlLm5hdmlnYXRpb24udXBkYXRlKCl9LHRvRWRnZTpmdW5jdGlvbihlKXtlLm5hdmlnYXRpb24udXBkYXRlKCl9LGZyb21FZGdlOmZ1bmN0aW9uKGUpe2UubmF2aWdhdGlvbi51cGRhdGUoKX0sZGVzdHJveTpmdW5jdGlvbihlKXtlLm5hdmlnYXRpb24uZGVzdHJveSgpfSxjbGljazpmdW5jdGlvbihlLHQpe3ZhciBhLGk9ZS5uYXZpZ2F0aW9uLHM9aS4kbmV4dEVsLHI9aS4kcHJldkVsOyFlLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrfHxtKHQudGFyZ2V0KS5pcyhyKXx8bSh0LnRhcmdldCkuaXMocyl8fChzP2E9cy5oYXNDbGFzcyhlLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTpyJiYoYT1yLmhhc0NsYXNzKGUucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpKSwhMD09PWE/ZS5lbWl0KFwibmF2aWdhdGlvblNob3dcIik6ZS5lbWl0KFwibmF2aWdhdGlvbkhpZGVcIikscyYmcy50b2dnbGVDbGFzcyhlLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKSxyJiZyLnRvZ2dsZUNsYXNzKGUucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpKX19fSx7bmFtZTpcInBhZ2luYXRpb25cIixwYXJhbXM6e3BhZ2luYXRpb246e2VsOm51bGwsYnVsbGV0RWxlbWVudDpcInNwYW5cIixjbGlja2FibGU6ITEsaGlkZU9uQ2xpY2s6ITEscmVuZGVyQnVsbGV0Om51bGwscmVuZGVyUHJvZ3Jlc3NiYXI6bnVsbCxyZW5kZXJGcmFjdGlvbjpudWxsLHJlbmRlckN1c3RvbTpudWxsLHByb2dyZXNzYmFyT3Bwb3NpdGU6ITEsdHlwZTpcImJ1bGxldHNcIixkeW5hbWljQnVsbGV0czohMSxkeW5hbWljTWFpbkJ1bGxldHM6MSxmb3JtYXRGcmFjdGlvbkN1cnJlbnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGZvcm1hdEZyYWN0aW9uVG90YWw6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGJ1bGxldENsYXNzOlwic3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0XCIsYnVsbGV0QWN0aXZlQ2xhc3M6XCJzd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlXCIsbW9kaWZpZXJDbGFzczpcInN3aXBlci1wYWdpbmF0aW9uLVwiLGN1cnJlbnRDbGFzczpcInN3aXBlci1wYWdpbmF0aW9uLWN1cnJlbnRcIix0b3RhbENsYXNzOlwic3dpcGVyLXBhZ2luYXRpb24tdG90YWxcIixoaWRkZW5DbGFzczpcInN3aXBlci1wYWdpbmF0aW9uLWhpZGRlblwiLHByb2dyZXNzYmFyRmlsbENsYXNzOlwic3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItZmlsbFwiLHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczpcInN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLW9wcG9zaXRlXCIsY2xpY2thYmxlQ2xhc3M6XCJzd2lwZXItcGFnaW5hdGlvbi1jbGlja2FibGVcIixsb2NrQ2xhc3M6XCJzd2lwZXItcGFnaW5hdGlvbi1sb2NrXCJ9fSxjcmVhdGU6ZnVuY3Rpb24oKXtNKHRoaXMse3BhZ2luYXRpb246dCh7ZHluYW1pY0J1bGxldEluZGV4OjB9LFopfSl9LG9uOntpbml0OmZ1bmN0aW9uKGUpe2UucGFnaW5hdGlvbi5pbml0KCksZS5wYWdpbmF0aW9uLnJlbmRlcigpLGUucGFnaW5hdGlvbi51cGRhdGUoKX0sYWN0aXZlSW5kZXhDaGFuZ2U6ZnVuY3Rpb24oZSl7KGUucGFyYW1zLmxvb3B8fHZvaWQgMD09PWUuc25hcEluZGV4KSYmZS5wYWdpbmF0aW9uLnVwZGF0ZSgpfSxzbmFwSW5kZXhDaGFuZ2U6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMubG9vcHx8ZS5wYWdpbmF0aW9uLnVwZGF0ZSgpfSxzbGlkZXNMZW5ndGhDaGFuZ2U6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMubG9vcCYmKGUucGFnaW5hdGlvbi5yZW5kZXIoKSxlLnBhZ2luYXRpb24udXBkYXRlKCkpfSxzbmFwR3JpZExlbmd0aENoYW5nZTpmdW5jdGlvbihlKXtlLnBhcmFtcy5sb29wfHwoZS5wYWdpbmF0aW9uLnJlbmRlcigpLGUucGFnaW5hdGlvbi51cGRhdGUoKSl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS5wYWdpbmF0aW9uLmRlc3Ryb3koKX0sY2xpY2s6ZnVuY3Rpb24oZSx0KXtlLnBhcmFtcy5wYWdpbmF0aW9uLmVsJiZlLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGVPbkNsaWNrJiZlLnBhZ2luYXRpb24uJGVsLmxlbmd0aD4wJiYhbSh0LnRhcmdldCkuaGFzQ2xhc3MoZS5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcykmJighMD09PWUucGFnaW5hdGlvbi4kZWwuaGFzQ2xhc3MoZS5wYXJhbXMucGFnaW5hdGlvbi5oaWRkZW5DbGFzcyk/ZS5lbWl0KFwicGFnaW5hdGlvblNob3dcIik6ZS5lbWl0KFwicGFnaW5hdGlvbkhpZGVcIiksZS5wYWdpbmF0aW9uLiRlbC50b2dnbGVDbGFzcyhlLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKSl9fX0se25hbWU6XCJzY3JvbGxiYXJcIixwYXJhbXM6e3Njcm9sbGJhcjp7ZWw6bnVsbCxkcmFnU2l6ZTpcImF1dG9cIixoaWRlOiExLGRyYWdnYWJsZTohMSxzbmFwT25SZWxlYXNlOiEwLGxvY2tDbGFzczpcInN3aXBlci1zY3JvbGxiYXItbG9ja1wiLGRyYWdDbGFzczpcInN3aXBlci1zY3JvbGxiYXItZHJhZ1wifX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHtzY3JvbGxiYXI6dCh7aXNUb3VjaGVkOiExLHRpbWVvdXQ6bnVsbCxkcmFnVGltZW91dDpudWxsfSxKKX0pfSxvbjp7aW5pdDpmdW5jdGlvbihlKXtlLnNjcm9sbGJhci5pbml0KCksZS5zY3JvbGxiYXIudXBkYXRlU2l6ZSgpLGUuc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpfSx1cGRhdGU6ZnVuY3Rpb24oZSl7ZS5zY3JvbGxiYXIudXBkYXRlU2l6ZSgpfSxyZXNpemU6ZnVuY3Rpb24oZSl7ZS5zY3JvbGxiYXIudXBkYXRlU2l6ZSgpfSxvYnNlcnZlclVwZGF0ZTpmdW5jdGlvbihlKXtlLnNjcm9sbGJhci51cGRhdGVTaXplKCl9LHNldFRyYW5zbGF0ZTpmdW5jdGlvbihlKXtlLnNjcm9sbGJhci5zZXRUcmFuc2xhdGUoKX0sc2V0VHJhbnNpdGlvbjpmdW5jdGlvbihlLHQpe2Uuc2Nyb2xsYmFyLnNldFRyYW5zaXRpb24odCl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS5zY3JvbGxiYXIuZGVzdHJveSgpfX19LHtuYW1lOlwicGFyYWxsYXhcIixwYXJhbXM6e3BhcmFsbGF4OntlbmFibGVkOiExfX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHtwYXJhbGxheDp0KHt9LFEpfSl9LG9uOntiZWZvcmVJbml0OmZ1bmN0aW9uKGUpe2UucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQmJihlLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzPSEwLGUub3JpZ2luYWxQYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcz0hMCl9LGluaXQ6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCYmZS5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKGUpe2UucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQmJmUucGFyYWxsYXguc2V0VHJhbnNsYXRlKCl9LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSx0KXtlLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkJiZlLnBhcmFsbGF4LnNldFRyYW5zaXRpb24odCl9fX0se25hbWU6XCJ6b29tXCIscGFyYW1zOnt6b29tOntlbmFibGVkOiExLG1heFJhdGlvOjMsbWluUmF0aW86MSx0b2dnbGU6ITAsY29udGFpbmVyQ2xhc3M6XCJzd2lwZXItem9vbS1jb250YWluZXJcIix6b29tZWRTbGlkZUNsYXNzOlwic3dpcGVyLXNsaWRlLXpvb21lZFwifX0sY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztNKGUse3pvb206dCh7ZW5hYmxlZDohMSxzY2FsZToxLGN1cnJlbnRTY2FsZToxLGlzU2NhbGluZzohMSxnZXN0dXJlOnskc2xpZGVFbDp2b2lkIDAsc2xpZGVXaWR0aDp2b2lkIDAsc2xpZGVIZWlnaHQ6dm9pZCAwLCRpbWFnZUVsOnZvaWQgMCwkaW1hZ2VXcmFwRWw6dm9pZCAwLG1heFJhdGlvOjN9LGltYWdlOntpc1RvdWNoZWQ6dm9pZCAwLGlzTW92ZWQ6dm9pZCAwLGN1cnJlbnRYOnZvaWQgMCxjdXJyZW50WTp2b2lkIDAsbWluWDp2b2lkIDAsbWluWTp2b2lkIDAsbWF4WDp2b2lkIDAsbWF4WTp2b2lkIDAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsc3RhcnRYOnZvaWQgMCxzdGFydFk6dm9pZCAwLHRvdWNoZXNTdGFydDp7fSx0b3VjaGVzQ3VycmVudDp7fX0sdmVsb2NpdHk6e3g6dm9pZCAwLHk6dm9pZCAwLHByZXZQb3NpdGlvblg6dm9pZCAwLHByZXZQb3NpdGlvblk6dm9pZCAwLHByZXZUaW1lOnZvaWQgMH19LGVlKX0pO3ZhciBhPTE7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUuem9vbSxcInNjYWxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBhfSxzZXQ6ZnVuY3Rpb24odCl7aWYoYSE9PXQpe3ZhciBpPWUuem9vbS5nZXN0dXJlLiRpbWFnZUVsP2Uuem9vbS5nZXN0dXJlLiRpbWFnZUVsWzBdOnZvaWQgMCxzPWUuem9vbS5nZXN0dXJlLiRzbGlkZUVsP2Uuem9vbS5nZXN0dXJlLiRzbGlkZUVsWzBdOnZvaWQgMDtlLmVtaXQoXCJ6b29tQ2hhbmdlXCIsdCxpLHMpfWE9dH19KX0sb246e2luaXQ6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMuem9vbS5lbmFibGVkJiZlLnpvb20uZW5hYmxlKCl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS56b29tLmRpc2FibGUoKX0sdG91Y2hTdGFydDpmdW5jdGlvbihlLHQpe2Uuem9vbS5lbmFibGVkJiZlLnpvb20ub25Ub3VjaFN0YXJ0KHQpfSx0b3VjaEVuZDpmdW5jdGlvbihlLHQpe2Uuem9vbS5lbmFibGVkJiZlLnpvb20ub25Ub3VjaEVuZCh0KX0sZG91YmxlVGFwOmZ1bmN0aW9uKGUsdCl7ZS5wYXJhbXMuem9vbS5lbmFibGVkJiZlLnpvb20uZW5hYmxlZCYmZS5wYXJhbXMuem9vbS50b2dnbGUmJmUuem9vbS50b2dnbGUodCl9LHRyYW5zaXRpb25FbmQ6ZnVuY3Rpb24oZSl7ZS56b29tLmVuYWJsZWQmJmUucGFyYW1zLnpvb20uZW5hYmxlZCYmZS56b29tLm9uVHJhbnNpdGlvbkVuZCgpfSxzbGlkZUNoYW5nZTpmdW5jdGlvbihlKXtlLnpvb20uZW5hYmxlZCYmZS5wYXJhbXMuem9vbS5lbmFibGVkJiZlLnBhcmFtcy5jc3NNb2RlJiZlLnpvb20ub25UcmFuc2l0aW9uRW5kKCl9fX0se25hbWU6XCJsYXp5XCIscGFyYW1zOntsYXp5OntjaGVja0luVmlldzohMSxlbmFibGVkOiExLGxvYWRQcmV2TmV4dDohMSxsb2FkUHJldk5leHRBbW91bnQ6MSxsb2FkT25UcmFuc2l0aW9uU3RhcnQ6ITEsc2Nyb2xsaW5nRWxlbWVudDpcIlwiLGVsZW1lbnRDbGFzczpcInN3aXBlci1sYXp5XCIsbG9hZGluZ0NsYXNzOlwic3dpcGVyLWxhenktbG9hZGluZ1wiLGxvYWRlZENsYXNzOlwic3dpcGVyLWxhenktbG9hZGVkXCIscHJlbG9hZGVyQ2xhc3M6XCJzd2lwZXItbGF6eS1wcmVsb2FkZXJcIn19LGNyZWF0ZTpmdW5jdGlvbigpe00odGhpcyx7bGF6eTp0KHtpbml0aWFsSW1hZ2VMb2FkZWQ6ITF9LHRlKX0pfSxvbjp7YmVmb3JlSW5pdDpmdW5jdGlvbihlKXtlLnBhcmFtcy5sYXp5LmVuYWJsZWQmJmUucGFyYW1zLnByZWxvYWRJbWFnZXMmJihlLnBhcmFtcy5wcmVsb2FkSW1hZ2VzPSExKX0saW5pdDpmdW5jdGlvbihlKXtlLnBhcmFtcy5sYXp5LmVuYWJsZWQmJiFlLnBhcmFtcy5sb29wJiYwPT09ZS5wYXJhbXMuaW5pdGlhbFNsaWRlJiYoZS5wYXJhbXMubGF6eS5jaGVja0luVmlldz9lLmxhenkuY2hlY2tJblZpZXdPbkxvYWQoKTplLmxhenkubG9hZCgpKX0sc2Nyb2xsOmZ1bmN0aW9uKGUpe2UucGFyYW1zLmZyZWVNb2RlJiYhZS5wYXJhbXMuZnJlZU1vZGVTdGlja3kmJmUubGF6eS5sb2FkKCl9LHJlc2l6ZTpmdW5jdGlvbihlKXtlLnBhcmFtcy5sYXp5LmVuYWJsZWQmJmUubGF6eS5sb2FkKCl9LHNjcm9sbGJhckRyYWdNb3ZlOmZ1bmN0aW9uKGUpe2UucGFyYW1zLmxhenkuZW5hYmxlZCYmZS5sYXp5LmxvYWQoKX0sdHJhbnNpdGlvblN0YXJ0OmZ1bmN0aW9uKGUpe2UucGFyYW1zLmxhenkuZW5hYmxlZCYmKGUucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0fHwhZS5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQmJiFlLmxhenkuaW5pdGlhbEltYWdlTG9hZGVkKSYmZS5sYXp5LmxvYWQoKX0sdHJhbnNpdGlvbkVuZDpmdW5jdGlvbihlKXtlLnBhcmFtcy5sYXp5LmVuYWJsZWQmJiFlLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCYmZS5sYXp5LmxvYWQoKX0sc2xpZGVDaGFuZ2U6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMubGF6eS5lbmFibGVkJiZlLnBhcmFtcy5jc3NNb2RlJiZlLmxhenkubG9hZCgpfX19LHtuYW1lOlwiY29udHJvbGxlclwiLHBhcmFtczp7Y29udHJvbGxlcjp7Y29udHJvbDp2b2lkIDAsaW52ZXJzZTohMSxieTpcInNsaWRlXCJ9fSxjcmVhdGU6ZnVuY3Rpb24oKXtNKHRoaXMse2NvbnRyb2xsZXI6dCh7Y29udHJvbDp0aGlzLnBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2x9LGFlKX0pfSxvbjp7dXBkYXRlOmZ1bmN0aW9uKGUpe2UuY29udHJvbGxlci5jb250cm9sJiZlLmNvbnRyb2xsZXIuc3BsaW5lJiYoZS5jb250cm9sbGVyLnNwbGluZT12b2lkIDAsZGVsZXRlIGUuY29udHJvbGxlci5zcGxpbmUpfSxyZXNpemU6ZnVuY3Rpb24oZSl7ZS5jb250cm9sbGVyLmNvbnRyb2wmJmUuY29udHJvbGxlci5zcGxpbmUmJihlLmNvbnRyb2xsZXIuc3BsaW5lPXZvaWQgMCxkZWxldGUgZS5jb250cm9sbGVyLnNwbGluZSl9LG9ic2VydmVyVXBkYXRlOmZ1bmN0aW9uKGUpe2UuY29udHJvbGxlci5jb250cm9sJiZlLmNvbnRyb2xsZXIuc3BsaW5lJiYoZS5jb250cm9sbGVyLnNwbGluZT12b2lkIDAsZGVsZXRlIGUuY29udHJvbGxlci5zcGxpbmUpfSxzZXRUcmFuc2xhdGU6ZnVuY3Rpb24oZSx0LGEpe2UuY29udHJvbGxlci5jb250cm9sJiZlLmNvbnRyb2xsZXIuc2V0VHJhbnNsYXRlKHQsYSl9LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSx0LGEpe2UuY29udHJvbGxlci5jb250cm9sJiZlLmNvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbih0LGEpfX19LHtuYW1lOlwiYTExeVwiLHBhcmFtczp7YTExeTp7ZW5hYmxlZDohMCxub3RpZmljYXRpb25DbGFzczpcInN3aXBlci1ub3RpZmljYXRpb25cIixwcmV2U2xpZGVNZXNzYWdlOlwiUHJldmlvdXMgc2xpZGVcIixuZXh0U2xpZGVNZXNzYWdlOlwiTmV4dCBzbGlkZVwiLGZpcnN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGVcIixsYXN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgbGFzdCBzbGlkZVwiLHBhZ2luYXRpb25CdWxsZXRNZXNzYWdlOlwiR28gdG8gc2xpZGUge3tpbmRleH19XCIsY29udGFpbmVyTWVzc2FnZTpudWxsLGNvbnRhaW5lclJvbGVEZXNjcmlwdGlvbk1lc3NhZ2U6bnVsbCxpdGVtUm9sZURlc2NyaXB0aW9uTWVzc2FnZTpudWxsfX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHthMTF5OnQoe30saWUse2xpdmVSZWdpb246bSgnPHNwYW4gY2xhc3M9XCInK3RoaXMucGFyYW1zLmExMXkubm90aWZpY2F0aW9uQ2xhc3MrJ1wiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiPjwvc3Bhbj4nKX0pfSl9LG9uOnthZnRlckluaXQ6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMuYTExeS5lbmFibGVkJiYoZS5hMTF5LmluaXQoKSxlLmExMXkudXBkYXRlTmF2aWdhdGlvbigpKX0sdG9FZGdlOmZ1bmN0aW9uKGUpe2UucGFyYW1zLmExMXkuZW5hYmxlZCYmZS5hMTF5LnVwZGF0ZU5hdmlnYXRpb24oKX0sZnJvbUVkZ2U6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMuYTExeS5lbmFibGVkJiZlLmExMXkudXBkYXRlTmF2aWdhdGlvbigpfSxwYWdpbmF0aW9uVXBkYXRlOmZ1bmN0aW9uKGUpe2UucGFyYW1zLmExMXkuZW5hYmxlZCYmZS5hMTF5LnVwZGF0ZVBhZ2luYXRpb24oKX0sZGVzdHJveTpmdW5jdGlvbihlKXtlLnBhcmFtcy5hMTF5LmVuYWJsZWQmJmUuYTExeS5kZXN0cm95KCl9fX0se25hbWU6XCJoaXN0b3J5XCIscGFyYW1zOntoaXN0b3J5OntlbmFibGVkOiExLHJlcGxhY2VTdGF0ZTohMSxrZXk6XCJzbGlkZXNcIn19LGNyZWF0ZTpmdW5jdGlvbigpe00odGhpcyx7aGlzdG9yeTp0KHt9LHNlKX0pfSxvbjp7aW5pdDpmdW5jdGlvbihlKXtlLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQmJmUuaGlzdG9yeS5pbml0KCl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMuaGlzdG9yeS5lbmFibGVkJiZlLmhpc3RvcnkuZGVzdHJveSgpfSx0cmFuc2l0aW9uRW5kOmZ1bmN0aW9uKGUpe2UuaGlzdG9yeS5pbml0aWFsaXplZCYmZS5oaXN0b3J5LnNldEhpc3RvcnkoZS5wYXJhbXMuaGlzdG9yeS5rZXksZS5hY3RpdmVJbmRleCl9LHNsaWRlQ2hhbmdlOmZ1bmN0aW9uKGUpe2UuaGlzdG9yeS5pbml0aWFsaXplZCYmZS5wYXJhbXMuY3NzTW9kZSYmZS5oaXN0b3J5LnNldEhpc3RvcnkoZS5wYXJhbXMuaGlzdG9yeS5rZXksZS5hY3RpdmVJbmRleCl9fX0se25hbWU6XCJoYXNoLW5hdmlnYXRpb25cIixwYXJhbXM6e2hhc2hOYXZpZ2F0aW9uOntlbmFibGVkOiExLHJlcGxhY2VTdGF0ZTohMSx3YXRjaFN0YXRlOiExfX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHtoYXNoTmF2aWdhdGlvbjp0KHtpbml0aWFsaXplZDohMX0scmUpfSl9LG9uOntpbml0OmZ1bmN0aW9uKGUpe2UucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQmJmUuaGFzaE5hdmlnYXRpb24uaW5pdCgpfSxkZXN0cm95OmZ1bmN0aW9uKGUpe2UucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQmJmUuaGFzaE5hdmlnYXRpb24uZGVzdHJveSgpfSx0cmFuc2l0aW9uRW5kOmZ1bmN0aW9uKGUpe2UuaGFzaE5hdmlnYXRpb24uaW5pdGlhbGl6ZWQmJmUuaGFzaE5hdmlnYXRpb24uc2V0SGFzaCgpfSxzbGlkZUNoYW5nZTpmdW5jdGlvbihlKXtlLmhhc2hOYXZpZ2F0aW9uLmluaXRpYWxpemVkJiZlLnBhcmFtcy5jc3NNb2RlJiZlLmhhc2hOYXZpZ2F0aW9uLnNldEhhc2goKX19fSx7bmFtZTpcImF1dG9wbGF5XCIscGFyYW1zOnthdXRvcGxheTp7ZW5hYmxlZDohMSxkZWxheTozZTMsd2FpdEZvclRyYW5zaXRpb246ITAsZGlzYWJsZU9uSW50ZXJhY3Rpb246ITAsc3RvcE9uTGFzdFNsaWRlOiExLHJldmVyc2VEaXJlY3Rpb246ITF9fSxjcmVhdGU6ZnVuY3Rpb24oKXtNKHRoaXMse2F1dG9wbGF5OnQoe30sbmUse3J1bm5pbmc6ITEscGF1c2VkOiExfSl9KX0sb246e2luaXQ6ZnVuY3Rpb24oZSl7ZS5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCYmKGUuYXV0b3BsYXkuc3RhcnQoKSxyKCkuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixlLmF1dG9wbGF5Lm9uVmlzaWJpbGl0eUNoYW5nZSkpfSxiZWZvcmVUcmFuc2l0aW9uU3RhcnQ6ZnVuY3Rpb24oZSx0LGEpe2UuYXV0b3BsYXkucnVubmluZyYmKGF8fCFlLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbj9lLmF1dG9wbGF5LnBhdXNlKHQpOmUuYXV0b3BsYXkuc3RvcCgpKX0sc2xpZGVyRmlyc3RNb3ZlOmZ1bmN0aW9uKGUpe2UuYXV0b3BsYXkucnVubmluZyYmKGUucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uP2UuYXV0b3BsYXkuc3RvcCgpOmUuYXV0b3BsYXkucGF1c2UoKSl9LHRvdWNoRW5kOmZ1bmN0aW9uKGUpe2UucGFyYW1zLmNzc01vZGUmJmUuYXV0b3BsYXkucGF1c2VkJiYhZS5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24mJmUuYXV0b3BsYXkucnVuKCl9LGRlc3Ryb3k6ZnVuY3Rpb24oZSl7ZS5hdXRvcGxheS5ydW5uaW5nJiZlLmF1dG9wbGF5LnN0b3AoKSxyKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixlLmF1dG9wbGF5Lm9uVmlzaWJpbGl0eUNoYW5nZSl9fX0se25hbWU6XCJlZmZlY3QtZmFkZVwiLHBhcmFtczp7ZmFkZUVmZmVjdDp7Y3Jvc3NGYWRlOiExfX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHtmYWRlRWZmZWN0OnQoe30sbGUpfSl9LG9uOntiZWZvcmVJbml0OmZ1bmN0aW9uKGUpe2lmKFwiZmFkZVwiPT09ZS5wYXJhbXMuZWZmZWN0KXtlLmNsYXNzTmFtZXMucHVzaChlLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzK1wiZmFkZVwiKTt2YXIgdD17c2xpZGVzUGVyVmlldzoxLHNsaWRlc1BlckNvbHVtbjoxLHNsaWRlc1Blckdyb3VwOjEsd2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzcGFjZUJldHdlZW46MCx2aXJ0dWFsVHJhbnNsYXRlOiEwfTtTKGUucGFyYW1zLHQpLFMoZS5vcmlnaW5hbFBhcmFtcyx0KX19LHNldFRyYW5zbGF0ZTpmdW5jdGlvbihlKXtcImZhZGVcIj09PWUucGFyYW1zLmVmZmVjdCYmZS5mYWRlRWZmZWN0LnNldFRyYW5zbGF0ZSgpfSxzZXRUcmFuc2l0aW9uOmZ1bmN0aW9uKGUsdCl7XCJmYWRlXCI9PT1lLnBhcmFtcy5lZmZlY3QmJmUuZmFkZUVmZmVjdC5zZXRUcmFuc2l0aW9uKHQpfX19LHtuYW1lOlwiZWZmZWN0LWN1YmVcIixwYXJhbXM6e2N1YmVFZmZlY3Q6e3NsaWRlU2hhZG93czohMCxzaGFkb3c6ITAsc2hhZG93T2Zmc2V0OjIwLHNoYWRvd1NjYWxlOi45NH19LGNyZWF0ZTpmdW5jdGlvbigpe00odGhpcyx7Y3ViZUVmZmVjdDp0KHt9LG9lKX0pfSxvbjp7YmVmb3JlSW5pdDpmdW5jdGlvbihlKXtpZihcImN1YmVcIj09PWUucGFyYW1zLmVmZmVjdCl7ZS5jbGFzc05hbWVzLnB1c2goZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcytcImN1YmVcIiksZS5jbGFzc05hbWVzLnB1c2goZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcytcIjNkXCIpO3ZhciB0PXtzbGlkZXNQZXJWaWV3OjEsc2xpZGVzUGVyQ29sdW1uOjEsc2xpZGVzUGVyR3JvdXA6MSx3YXRjaFNsaWRlc1Byb2dyZXNzOiEwLHJlc2lzdGFuY2VSYXRpbzowLHNwYWNlQmV0d2VlbjowLGNlbnRlcmVkU2xpZGVzOiExLHZpcnR1YWxUcmFuc2xhdGU6ITB9O1MoZS5wYXJhbXMsdCksUyhlLm9yaWdpbmFsUGFyYW1zLHQpfX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKGUpe1wiY3ViZVwiPT09ZS5wYXJhbXMuZWZmZWN0JiZlLmN1YmVFZmZlY3Quc2V0VHJhbnNsYXRlKCl9LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSx0KXtcImN1YmVcIj09PWUucGFyYW1zLmVmZmVjdCYmZS5jdWJlRWZmZWN0LnNldFRyYW5zaXRpb24odCl9fX0se25hbWU6XCJlZmZlY3QtZmxpcFwiLHBhcmFtczp7ZmxpcEVmZmVjdDp7c2xpZGVTaGFkb3dzOiEwLGxpbWl0Um90YXRpb246ITB9fSxjcmVhdGU6ZnVuY3Rpb24oKXtNKHRoaXMse2ZsaXBFZmZlY3Q6dCh7fSxkZSl9KX0sb246e2JlZm9yZUluaXQ6ZnVuY3Rpb24oZSl7aWYoXCJmbGlwXCI9PT1lLnBhcmFtcy5lZmZlY3Qpe2UuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MrXCJmbGlwXCIpLGUuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MrXCIzZFwiKTt2YXIgdD17c2xpZGVzUGVyVmlldzoxLHNsaWRlc1BlckNvbHVtbjoxLHNsaWRlc1Blckdyb3VwOjEsd2F0Y2hTbGlkZXNQcm9ncmVzczohMCxzcGFjZUJldHdlZW46MCx2aXJ0dWFsVHJhbnNsYXRlOiEwfTtTKGUucGFyYW1zLHQpLFMoZS5vcmlnaW5hbFBhcmFtcyx0KX19LHNldFRyYW5zbGF0ZTpmdW5jdGlvbihlKXtcImZsaXBcIj09PWUucGFyYW1zLmVmZmVjdCYmZS5mbGlwRWZmZWN0LnNldFRyYW5zbGF0ZSgpfSxzZXRUcmFuc2l0aW9uOmZ1bmN0aW9uKGUsdCl7XCJmbGlwXCI9PT1lLnBhcmFtcy5lZmZlY3QmJmUuZmxpcEVmZmVjdC5zZXRUcmFuc2l0aW9uKHQpfX19LHtuYW1lOlwiZWZmZWN0LWNvdmVyZmxvd1wiLHBhcmFtczp7Y292ZXJmbG93RWZmZWN0Ontyb3RhdGU6NTAsc3RyZXRjaDowLGRlcHRoOjEwMCxzY2FsZToxLG1vZGlmaWVyOjEsc2xpZGVTaGFkb3dzOiEwfX0sY3JlYXRlOmZ1bmN0aW9uKCl7TSh0aGlzLHtjb3ZlcmZsb3dFZmZlY3Q6dCh7fSxwZSl9KX0sb246e2JlZm9yZUluaXQ6ZnVuY3Rpb24oZSl7XCJjb3ZlcmZsb3dcIj09PWUucGFyYW1zLmVmZmVjdCYmKGUuY2xhc3NOYW1lcy5wdXNoKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MrXCJjb3ZlcmZsb3dcIiksZS5jbGFzc05hbWVzLnB1c2goZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcytcIjNkXCIpLGUucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3M9ITAsZS5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzPSEwKX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKGUpe1wiY292ZXJmbG93XCI9PT1lLnBhcmFtcy5lZmZlY3QmJmUuY292ZXJmbG93RWZmZWN0LnNldFRyYW5zbGF0ZSgpfSxzZXRUcmFuc2l0aW9uOmZ1bmN0aW9uKGUsdCl7XCJjb3ZlcmZsb3dcIj09PWUucGFyYW1zLmVmZmVjdCYmZS5jb3ZlcmZsb3dFZmZlY3Quc2V0VHJhbnNpdGlvbih0KX19fSx7bmFtZTpcInRodW1ic1wiLHBhcmFtczp7dGh1bWJzOntzd2lwZXI6bnVsbCxtdWx0aXBsZUFjdGl2ZVRodW1iczohMCxhdXRvU2Nyb2xsT2Zmc2V0OjAsc2xpZGVUaHVtYkFjdGl2ZUNsYXNzOlwic3dpcGVyLXNsaWRlLXRodW1iLWFjdGl2ZVwiLHRodW1ic0NvbnRhaW5lckNsYXNzOlwic3dpcGVyLWNvbnRhaW5lci10aHVtYnNcIn19LGNyZWF0ZTpmdW5jdGlvbigpe00odGhpcyx7dGh1bWJzOnQoe3N3aXBlcjpudWxsLGluaXRpYWxpemVkOiExfSx1ZSl9KX0sb246e2JlZm9yZUluaXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJhbXMudGh1bWJzO3QmJnQuc3dpcGVyJiYoZS50aHVtYnMuaW5pdCgpLGUudGh1bWJzLnVwZGF0ZSghMCkpfSxzbGlkZUNoYW5nZTpmdW5jdGlvbihlKXtlLnRodW1icy5zd2lwZXImJmUudGh1bWJzLnVwZGF0ZSgpfSx1cGRhdGU6ZnVuY3Rpb24oZSl7ZS50aHVtYnMuc3dpcGVyJiZlLnRodW1icy51cGRhdGUoKX0scmVzaXplOmZ1bmN0aW9uKGUpe2UudGh1bWJzLnN3aXBlciYmZS50aHVtYnMudXBkYXRlKCl9LG9ic2VydmVyVXBkYXRlOmZ1bmN0aW9uKGUpe2UudGh1bWJzLnN3aXBlciYmZS50aHVtYnMudXBkYXRlKCl9LHNldFRyYW5zaXRpb246ZnVuY3Rpb24oZSx0KXt2YXIgYT1lLnRodW1icy5zd2lwZXI7YSYmYS5zZXRUcmFuc2l0aW9uKHQpfSxiZWZvcmVEZXN0cm95OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGh1bWJzLnN3aXBlcjt0JiZlLnRodW1icy5zd2lwZXJDcmVhdGVkJiZ0JiZ0LmRlc3Ryb3koKX19fV07cmV0dXJuIFIudXNlKGNlKSxSfSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2lwZXItYnVuZGxlLm1pbi5qcy5tYXBcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/swiper.min.js\n");

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.20';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcz8yZWYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sYUFBYSxPQUFPOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxFQUFFOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVC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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTyxXQUFXO0FBQ2pDLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTyxXQUFXO0FBQ2pDLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsd0NBQXdDO0FBQ3hDLCtEQUErRDtBQUMvRCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUyxHQUFHLFNBQVMsS0FBSyxTQUFTO0FBQzNELGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVEO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRCxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDLFVBQVUscUNBQXFDO0FBQy9DLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DLFVBQVUscUNBQXFDO0FBQy9DLFVBQVU7QUFDVjtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQixFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9DQUFvQztBQUM5QyxVQUFVLHFDQUFxQztBQUMvQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDJDQUEyQyw0QkFBNEIsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsS0FBSyxTQUFTLEdBQUcsU0FBUztBQUM3RCxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUQsc0JBQXNCLGlCQUFpQixHQUFHLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsR0FBRyxTQUFTLEdBQUcsU0FBUyxHQUFHLFNBQVM7QUFDbEU7QUFDQSw0QkFBNEIsU0FBUyxHQUFHLFNBQVM7QUFDakQ7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUM5RTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQSxlQUFlLGlCQUFpQixHQUFHLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUM7QUFDQSxpQ0FBaUMsU0FBUyxlQUFlLFlBQVksRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUM7QUFDQSxxQ0FBcUMsU0FBUyxlQUFlLFlBQVksRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0M7QUFDOUMsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCLEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFDQUFxQztBQUMvQyxVQUFVLHFDQUFxQztBQUMvQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0IsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTLEtBQUssU0FBUyxHQUFHLFNBQVM7QUFDdEQsZUFBZSxTQUFTLEdBQUcsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVELHNCQUFzQixpQkFBaUIsR0FBRyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBLGVBQWUsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ25ELGVBQWUsU0FBUyxHQUFHLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQixHQUFHLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUyxLQUFLLFNBQVMsR0FBRyxTQUFTO0FBQ3BELGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVELHNCQUFzQixpQkFBaUIsR0FBRyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBLGVBQWUsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sUUFBUSxTQUFTLEdBQUcsU0FBUyxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSxPQUFPLFNBQVMsRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4Qjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQThDO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQixFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUErQztBQUN6RCxVQUFVLGdEQUFnRDtBQUMxRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUIsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsY0FBYyxPQUFPLDRCQUE0QixRQUFRLDhCQUE4QjtBQUN2RjtBQUNBO0FBQ0EsY0FBYyxVQUFVLDRCQUE0QixZQUFZLDhCQUE4QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGNBQWMsaUJBQWlCLEVBQUU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1osY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUErQztBQUN6RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0IsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQ0FBbUM7QUFDN0MsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLHlCQUF5QjtBQUN4QztBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUNBQXFDLGVBQWUsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLFlBQVk7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLHlCQUF5QjtBQUN4QztBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU8sWUFBWTtBQUNsQyxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0JBQW9CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsNkJBQTZCLG1CQUFtQixjQUFjLEVBQUUsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQixjQUFjLEVBQUUsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQixFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCLEVBQUU7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLFlBQVk7QUFDbEMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0Esc0VBQXNFLDJCQUEyQixFQUFFO0FBQ25HLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRCxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMkJBQTJCLEVBQUU7QUFDbEYsd0NBQXdDLGFBQWEsZUFBZSxFQUFFO0FBQ3RFLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFDQUFxQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxQkFBcUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZELDBDQUEwQyxRQUFRO0FBQ2xELGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywrQkFBK0IsaUNBQWlDO0FBQ2hFLGNBQWM7QUFDZDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTyxZQUFZO0FBQ2xDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLGFBQWEsUUFBUSxRQUFRLFVBQVUsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUIsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CLGNBQWMsRUFBRSxFQUFFO0FBQzFFLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0EsZUFBZSxTQUFTLEdBQUcsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUE4QztBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RSxlQUFlLDhDQUE4QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBLGdEQUFnRCxTQUFTLGNBQWMsU0FBUztBQUNoRixlQUFlLHlCQUF5QixHQUFHLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QixHQUFHLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU8scUJBQXFCLEVBQUU7QUFDeEMsVUFBVSxPQUFPLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTyxZQUFZO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQixHQUFHLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVMsR0FBRyxTQUFTO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU8sU0FBUyxFQUFFO0FBQzVCLFVBQVUsT0FBTyxTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0EsdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDO0FBQ0EscUNBQXFDLFlBQVksRUFBRTtBQUNuRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ3BFO0FBQ0Esc0NBQXNDLFlBQVksRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUM7QUFDQSxxQ0FBcUMsWUFBWSxFQUFFO0FBQ25ELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ3BFO0FBQ0EscUNBQXFDLFlBQVksRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssTUFBTSxpQkFBaUI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUE0RDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDO0FBQ3RFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBTztBQUNYO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ047QUFDQTtBQUNBLE9BQU8sRUFTSjtBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMjAnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2csXG4gICAgICByZVRyaW1TdGFydCA9IC9eXFxzKy8sXG4gICAgICByZVRyaW1FbmQgPSAvXFxzKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgICAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF0sXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGBhcmdzYFxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgICAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgICAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmludGVyc2VjdGlvbmAsIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnRlcnNlY3Rpb24oYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgICAgICBtYXhMZW5ndGggPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoIShzZWVuXG4gICAgICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZlcnRgIGFuZCBgXy5pbnZlcnRCeWAgd2hpY2ggaW52ZXJ0c1xuICAgICAqIGBvYmplY3RgIHdpdGggdmFsdWVzIHRyYW5zZm9ybWVkIGJ5IGBpdGVyYXRlZWAgYW5kIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUodmFsdWUpLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZva2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIG1ldGhvZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJyYXlCdWZmZXJgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNEYXRlYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgICAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICAgICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgICAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICAgICAqIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcbiAgICAgIHZhciBhcnJheSA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXG4gICAgICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICAgICAqIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZVxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24gJiYgbmF0aXZlSXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gICAgICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG90aGVyICE9ICdmdW5jdGlvbicgfHwgIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gICAgICogZXhlY3V0ZWQgaW1wb3J0YW50LCBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICAgICAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLCBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIHVwZGF0ZVdyYXBEZXRhaWxzKGdldFdyYXBEZXRhaWxzKHNvdXJjZSksIGJpdG1hc2spKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAgICogbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIENvbWJpbmluZyBzZXZlcmFsIHByZWRpY2F0ZXMgdXNpbmcgYF8ub3ZlckV2ZXJ5YCBvciBgXy5vdmVyU29tZWAuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ub3ZlclNvbWUoW3sgJ2FnZSc6IDM2IH0sIFsnYWdlJywgNDBdXSkpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiAzMCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gICAgICAvLyB0byBub3JtYWxpemUgYWxsIGtpbmRzIG9mIHdoaXRlc3BhY2UsIHNvIGUuZy4gbmV3bGluZXMgKGFuZCB1bmljb2RlIHZlcnNpb25zIG9mIGl0KSBjYW4ndCBzbmVhayBpblxuICAgICAgLy8gYW5kIGVzY2FwZSB0aGUgY29tbWVudCwgdGh1cyBpbmplY3RpbmcgY29kZSB0aGF0IGdldHMgZXZhbGVkLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICAgICAgICA/IChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9cXHMvZywgJyAnKVxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb2JhcidcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byB1cHBlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICctLUZPTy1CQVItLSdcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPT0JBUidcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnX19GT09fQkFSX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbUVuZCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgXy5tYXRjaGVzKHsgJ2EnOiA0IH0pXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDEpLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgbWF0Y2hlc0Z1bmMgPSBfLm92ZXJTb21lKFt7ICdhJzogMSB9LCB7ICdhJzogMiB9XSlcbiAgICAgKiB2YXIgbWF0Y2hlc1Byb3BlcnR5RnVuYyA9IF8ub3ZlclNvbWUoW1snYScsIDFdLCBbJ2EnLCAyXV0pXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/lodash.js\n");

/***/ }),

/***/ "./resources/css/app.scss":
/*!********************************!*\
  !*** ./resources/css/app.scss ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvY3NzL2FwcC5zY3NzPzlkZTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2Nzcy9hcHAuc2Nzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/css/app.scss\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	// It's empty as some runtime module handles the default behavior
/******/ 	__webpack_require__.x = x => {}
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// Promise = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0
/******/ 		};
/******/ 		
/******/ 		var deferredModules = [
/******/ 			["./resources/js/app.js"],
/******/ 			["./resources/css/app.scss"]
/******/ 		];
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		var checkDeferredModules = x => {};
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime, executeModules] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0, resolves = [];
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					resolves.push(installedChunks[chunkId][0]);
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			while(resolves.length) {
/******/ 				resolves.shift()();
/******/ 			}
/******/ 		
/******/ 			// add entry modules from loaded chunk to deferred list
/******/ 			if(executeModules) deferredModules.push.apply(deferredModules, executeModules);
/******/ 		
/******/ 			// run deferred modules when all chunks ready
/******/ 			return checkDeferredModules();
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 		
/******/ 		function checkDeferredModulesImpl() {
/******/ 			var result;
/******/ 			for(var i = 0; i < deferredModules.length; i++) {
/******/ 				var deferredModule = deferredModules[i];
/******/ 				var fulfilled = true;
/******/ 				for(var j = 1; j < deferredModule.length; j++) {
/******/ 					var depId = deferredModule[j];
/******/ 					if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferredModules.splice(i--, 1);
/******/ 					result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 				}
/******/ 			}
/******/ 			if(deferredModules.length === 0) {
/******/ 				__webpack_require__.x();
/******/ 				__webpack_require__.x = x => {};
/******/ 			}
/******/ 			return result;
/******/ 		}
/******/ 		var startup = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			// reset startup function so it can be called again when more startup code is added
/******/ 			__webpack_require__.x = startup || (x => {});
/******/ 			return (checkDeferredModules = checkDeferredModulesImpl)();
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// run startup
/******/ 	return __webpack_require__.x();
/******/ })()
;